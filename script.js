// Store data
const stores = {
    salaya: '‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤',
    klongyong: '‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á'
};

let currentStore = 'salaya';
let currentMonth = new Date().toISOString().slice(0, 7); // Format: YYYY-MM
let completeRepairAccessoriesData = []; // Store accessories for searchable dropdown
let selectedAccessories = []; // Store selected accessories list for complete repair
let equipmentData = []; // Equipment data (global scope to avoid TDZ error)
let currentEquipmentTab = 'charger-set'; // Current equipment tab (global scope)
let currentChargerSubTab = 'all'; // Current charger sub-tab (all, usb-type-c, usb-lightning, etc.)
let currentCableSubTab = 'all'; // Current cable sub-tab (all, usb-type-c, usb-lightning, etc.)
let currentAdapterSubTab = 'all'; // Current adapter sub-tab (all, usb, type-c, 2-usb, multi-charger, car-charger, etc.)
let currentEarphoneSubTab = 'all'; // Current earphone sub-tab (all, flat, earbuds, over-ear, c-earphone, l-earphone, aux, adapter, other)
let currentScreenProtectorSubTab = 'all'; // Current screen-protector sub-tab (all, focus, u-i, orange-box, lens, tablet, other)
let currentScreenProtectorBrand = 'all'; // Current screen-protector brand filter (all, apple, samsung, oppo, vivo, redmi, other)
let currentCaseSubTab = 'all'; // Current case sub-tab (all, apple, samsung, oppo, vivo, redmi, other)
const BRAND_CATEGORIES = ['Apple', 'Samsung', 'Redmi', 'Oppo', 'Vivo', 'Realme', 'Infinix']; // Brand categories for grouping equipment
let currentSimcardEditId = null; // Current editing simcard ID (global scope to avoid TDZ error)
let currentSellSimcardId = null; // Current selling simcard ID (global scope to avoid TDZ error)
let currentCutSimcardId = null; // Current cutting simcard ID (global scope to avoid TDZ error)
let currentSimcardTab = 'available'; // Current simcard tab (available, sold, expired)
let currentSimcardProvider = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î'; // Current simcard provider filter (‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î, AIS, DTAC, TRUE)
let simcardData = { available: [], sold: [], expired: [] }; // Global simcard data for filtering

// API Endpoints
const API_ENDPOINTS = {
    newDevices: 'http://localhost:5001/api/new-devices',
    usedDevices: 'http://localhost:5001/api/used-devices',
    repairs: 'http://localhost:5001/api/repairs',
    installment: 'http://localhost:5001/api/installments',
    installments: 'http://localhost:5001/api/installments', // alias
    pawn: 'http://localhost:5001/api/pawn',
    accessories: 'http://localhost:5001/api/accessories',
    equipment: 'http://localhost:5001/api/equipment',
    simcard: 'http://localhost:5001/api/simcard',
    accessoryClaim: (id) => `http://localhost:5001/api/accessories/${id}/claim`,
    accessoryReturnStock: (id) => `http://localhost:5001/api/accessories/${id}/return-stock`,
    accessoryDamage: (id) => `http://localhost:5001/api/accessories/${id}/damage`,
    accessoryRemoveDamage: (id) => `http://localhost:5001/api/accessories/${id}/remove-damage`,
    accessoryUpdateDamage: (id) => `http://localhost:5001/api/accessories/${id}/update-damage`,
    accessoryCut: (id) => `http://localhost:5001/api/accessories/${id}/cut`,
    accessoryCutList: 'http://localhost:5001/api/accessories/cut/list',
    equipmentCut: (id) => `http://localhost:5001/api/equipment/${id}/cut`,
    equipmentDamage: (id) => `http://localhost:5001/api/equipment/${id}/damage`,
    equipmentRemoveDamage: (id) => `http://localhost:5001/api/equipment/${id}/remove-damage`,
    equipmentUpdateDamage: (id) => `http://localhost:5001/api/equipment/${id}/update-damage`
};

// ========================================
// Custom Alert/Confirm Dialog Functions
// ========================================

/**
 * ‡πÅ‡∏™‡∏î‡∏á Custom Alert Dialog
 * @param {Object} options - ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö alert
 * @param {string} options.title - ‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠
 * @param {string} options.message - ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
 * @param {Array} options.list - ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡∏ö list (optional)
 * @param {string} options.icon - ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó icon: 'success', 'error', 'warning', 'info', 'question'
 * @param {string} options.confirmText - ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏∏‡πà‡∏°‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô (default: '‡∏ï‡∏Å‡∏•‡∏á')
 * @param {string} options.confirmType - ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏õ‡∏∏‡πà‡∏°: 'success', 'danger', 'primary'
 * @returns {Promise<void>}
 */
function customAlert(options) {
    return new Promise((resolve) => {
        const {
            title = '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message = '',
            list = [],
            icon = 'info',
            confirmText = '‡∏ï‡∏Å‡∏•‡∏á',
            confirmType = 'primary'
        } = options;

        const dialog = document.getElementById('customDialog');
        const dialogIcon = document.getElementById('customDialogIcon');
        const dialogTitle = document.getElementById('customDialogTitle');
        const dialogMessage = document.getElementById('customDialogMessage');
        const dialogList = document.getElementById('customDialogList');
        const dialogFooter = dialog.querySelector('.custom-dialog-footer');
        const cancelBtn = document.getElementById('customDialogCancel');
        const confirmBtn = document.getElementById('customDialogConfirm');

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ icon
        const iconSymbols = {
            success: '‚úÖ',
            error: '‚ùå',
            warning: '‚ö†Ô∏è',
            info: '‚ÑπÔ∏è',
            question: '‚ùì'
        };

        dialogIcon.className = `custom-dialog-icon ${icon}`;
        dialogIcon.querySelector('.dialog-icon-symbol').textContent = iconSymbols[icon] || iconSymbols.info;

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤
        dialogTitle.textContent = title;
        dialogMessage.textContent = message;

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ list
        if (list.length > 0) {
            dialogList.style.display = 'block';
            dialogList.innerHTML = list.map(item => {
                const iconClass = item.icon || 'check';
                const iconSymbol = item.iconSymbol || '‚úì';
                return `
                    <div class="custom-dialog-list-item">
                        <div class="icon ${iconClass}">${iconSymbol}</div>
                        <div class="text">${item.text}</div>
                    </div>
                `;
            }).join('');
        } else {
            dialogList.style.display = 'none';
            dialogList.innerHTML = '';
        }

        // ‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏∏‡πà‡∏°‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö alert)
        cancelBtn.style.display = 'none';
        dialogFooter.classList.add('single-button');

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏∏‡πà‡∏°‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
        confirmBtn.textContent = confirmText;
        confirmBtn.className = `custom-dialog-btn btn-confirm ${confirmType}`;

        // Event handlers
        const handleConfirm = () => {
            closeCustomDialog();
            resolve();
        };

        const handleOverlayClick = (e) => {
            if (e.target.classList.contains('custom-dialog-overlay')) {
                closeCustomDialog();
                resolve();
            }
        };

        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeCustomDialog();
                resolve();
            }
        };

        // ‡∏ú‡∏π‡∏Å event listeners
        confirmBtn.onclick = handleConfirm;
        dialog.querySelector('.custom-dialog-overlay').onclick = handleOverlayClick;
        document.addEventListener('keydown', handleEscape);

        // ‡πÄ‡∏Å‡πá‡∏ö handlers ‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö cleanup
        dialog._cleanup = () => {
            confirmBtn.onclick = null;
            dialog.querySelector('.custom-dialog-overlay').onclick = null;
            document.removeEventListener('keydown', handleEscape);
        };

        // ‡πÅ‡∏™‡∏î‡∏á dialog
        dialog.classList.add('show');
    });
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á Custom Confirm Dialog
 * @param {Object} options - ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö confirm
 * @param {string} options.title - ‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠
 * @param {string} options.message - ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
 * @param {Array} options.list - ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡∏ö list (optional)
 * @param {string} options.icon - ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó icon: 'success', 'error', 'warning', 'info', 'question'
 * @param {string} options.confirmText - ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏∏‡πà‡∏°‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô (default: '‡∏ï‡∏Å‡∏•‡∏á')
 * @param {string} options.cancelText - ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏∏‡πà‡∏°‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å (default: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å')
 * @param {string} options.confirmType - ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏õ‡∏∏‡πà‡∏°: 'success', 'danger', 'primary'
 * @returns {Promise<boolean>} - true ‡∏ñ‡πâ‡∏≤‡∏Å‡∏î‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô, false ‡∏ñ‡πâ‡∏≤‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
 */
function customConfirm(options) {
    return new Promise((resolve) => {
        const {
            title = '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô',
            message = '',
            list = [],
            icon = 'question',
            confirmText = '‡∏ï‡∏Å‡∏•‡∏á',
            cancelText = '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType = 'primary'
        } = options;

        const dialog = document.getElementById('customDialog');
        const dialogIcon = document.getElementById('customDialogIcon');
        const dialogTitle = document.getElementById('customDialogTitle');
        const dialogMessage = document.getElementById('customDialogMessage');
        const dialogList = document.getElementById('customDialogList');
        const dialogFooter = dialog.querySelector('.custom-dialog-footer');
        const cancelBtn = document.getElementById('customDialogCancel');
        const confirmBtn = document.getElementById('customDialogConfirm');

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ icon
        const iconSymbols = {
            success: '‚úÖ',
            error: '‚ùå',
            warning: '‚ö†Ô∏è',
            info: '‚ÑπÔ∏è',
            question: '‚ùì'
        };

        dialogIcon.className = `custom-dialog-icon ${icon}`;
        dialogIcon.querySelector('.dialog-icon-symbol').textContent = iconSymbols[icon] || iconSymbols.question;

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤
        dialogTitle.textContent = title;
        dialogMessage.innerHTML = message; // ‡πÉ‡∏ä‡πâ innerHTML ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö HTML

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ list
        if (list.length > 0) {
            dialogList.style.display = 'block';
            dialogList.innerHTML = list.map(item => {
                const iconClass = item.icon || 'check';
                const iconSymbol = item.iconSymbol || '‚úì';
                return `
                    <div class="custom-dialog-list-item">
                        <div class="icon ${iconClass}">${iconSymbol}</div>
                        <div class="text">${item.text}</div>
                    </div>
                `;
            }).join('');
        } else {
            dialogList.style.display = 'none';
            dialogList.innerHTML = '';
        }

        // ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö confirm)
        cancelBtn.style.display = 'block';
        dialogFooter.classList.remove('single-button');

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏∏‡πà‡∏°
        cancelBtn.textContent = cancelText;
        confirmBtn.textContent = confirmText;
        confirmBtn.className = `custom-dialog-btn btn-confirm ${confirmType}`;

        // Event handlers
        const handleConfirm = () => {
            closeCustomDialog();
            resolve(true);
        };

        const handleCancel = () => {
            closeCustomDialog();
            resolve(false);
        };

        const handleOverlayClick = (e) => {
            if (e.target.classList.contains('custom-dialog-overlay')) {
                closeCustomDialog();
                resolve(false);
            }
        };

        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeCustomDialog();
                resolve(false);
            }
        };

        // ‡∏ú‡∏π‡∏Å event listeners
        confirmBtn.onclick = handleConfirm;
        cancelBtn.onclick = handleCancel;
        dialog.querySelector('.custom-dialog-overlay').onclick = handleOverlayClick;
        document.addEventListener('keydown', handleEscape);

        // ‡πÄ‡∏Å‡πá‡∏ö handlers ‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö cleanup
        dialog._cleanup = () => {
            confirmBtn.onclick = null;
            cancelBtn.onclick = null;
            dialog.querySelector('.custom-dialog-overlay').onclick = null;
            document.removeEventListener('keydown', handleEscape);
        };

        // ‡πÅ‡∏™‡∏î‡∏á dialog
        dialog.classList.add('show');
    });
}

/**
 * ‡∏õ‡∏¥‡∏î Custom Dialog
 */
function closeCustomDialog() {
    const dialog = document.getElementById('customDialog');
    
    // Cleanup event listeners
    if (dialog._cleanup) {
        dialog._cleanup();
        delete dialog._cleanup;
    }
    
    dialog.classList.remove('show');
}

// ===== GLOBAL DATA ARRAYS =====
let newDevices = [];
let usedDevices = [];
let repairDevices = [];
let installmentDevices = [];

// ===== GLOBAL EDIT IDs =====
let currentPawnEditId = null;
let currentEditId = null;
let currentInstallmentEditId = null;

// ===== TRANSFER VARIABLES =====
let transferSourceDeviceId = null;
let transferSourceDeviceType = null; // 'new' or 'used'
let transferTargetStore = null; // ‡∏£‡πâ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏ú‡πà‡∏≠‡∏ô

// ===== OTHER EDIT IDs =====
let currentUsedEditId = null;
let currentRepairEditId = null;
let currentAccessoryEditId = null;

// ===== EXPENSE DETAIL DATA =====
let usedDevicesExpenseDetailData = {
    devices: [],
    month: '',
    year: '',
    total: 0
};

// ===== GLOBAL FILTERS =====
let currentPawnFilter = { startDate: '', endDate: '' };
let currentNewDevicesFilter = { startDate: '', endDate: '' };
let currentUsedDevicesFilter = { startDate: '', endDate: '' };
let currentRepairFilter = { startDate: '', endDate: '' };
let currentInstallmentFilter = { startDate: '', endDate: '' };
let currentDashboardFilter = { startDate: '', endDate: '' };
let currentAccessoryFilter = {
    search: '',
    startDate: '',
    endDate: ''
};

let currentEquipmentFilter = {
    search: '',
    startDate: '',
    endDate: ''
};

// Helper functions for date filtering
function getFirstDayOfMonth() {
    const now = new Date();
    const firstDay = new Date(now.getFullYear(), now.getMonth(), 1);
    return firstDay.toISOString().split('T')[0]; // YYYY-MM-DD
}

function getLastDayOfMonth() {
    const now = new Date();
    const lastDay = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    return lastDay.toISOString().split('T')[0]; // YYYY-MM-DD
}

// ===== GLOBAL TABS =====
let currentAccessoryTab = 'battery';
let currentAccessoryBrand = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î'; // ‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ô‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 2 (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)
let currentInstallmentType = 'partner';

// ===== ACCESSORIES DATA CACHE =====
let accessoriesDataCache = {
    battery: [],
    screen: [],
    charging: [],
    switch: [],
    flex: [],
    speaker: [],
    removed: [],
    outofstock: [],
    claim: []
};

// ===== PAWN DETAIL DATA =====
let pawnDetailData = {
    activePawns: [],
    allPawns: [],
    returnedPawns: [],
    interestTransactions: [],
    totalExpense: 0,
    totalIncome: 0,
    totalProfit: 0
};

// ===== API HELPER FUNCTIONS =====
const API = {
    // GET request
    async get(endpoint, params = {}) {
        try {
            const queryString = new URLSearchParams(params).toString();
            const url = queryString ? `${endpoint}?${queryString}` : endpoint;

            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('API GET Error:', error);
            throw error;
        }
    },

    // POST request
    async post(endpoint, data = {}) {
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.log('Error response data:', errorData);
                // Extract error message properly from various formats
                let errorMessage = errorData.message
                    || (typeof errorData.error === 'string' ? errorData.error : errorData.error?.message)
                    || `HTTP error! status: ${response.status}`;
                console.log('Extracted error message:', errorMessage);
                const error = new Error(errorMessage);
                // Preserve all error data properties
                Object.assign(error, errorData);
                throw error;
            }

            return await response.json();
        } catch (error) {
            console.error('API POST Error:', error);
            console.error('Error message:', error.message);
            console.error('Error details:', JSON.stringify(error, Object.getOwnPropertyNames(error)));
            throw error;
        }
    },

    // PUT request
    async put(endpoint, data = {}) {
        try {
            const response = await fetch(endpoint, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            });

            if (!response.ok) {
                const errorData = await response.json();
                let errorMessage = errorData.message
                    || (typeof errorData.error === 'string' ? errorData.error : errorData.error?.message)
                    || `HTTP error! status: ${response.status}`;
                const error = new Error(errorMessage);
                // Preserve all error data properties
                Object.assign(error, errorData);
                throw error;
            }

            return await response.json();
        } catch (error) {
            console.error('API PUT Error:', error);
            throw error;
        }
    },

    // DELETE request
    async delete(endpoint) {
        try {
            const response = await fetch(endpoint, {
                method: 'DELETE'
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('API DELETE Error:', error);
            throw error;
        }
    }
};

// Page titles
const pageTitles = {
    'dashboard': '‡πÅ‡∏î‡∏ä‡∏ö‡∏≠‡∏£‡πå‡∏î',
    'income-breakdown': '‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó',
    'expense-breakdown': '‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó',
    'profit-breakdown': '‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó',
    'new-devices': '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏´‡∏ô‡∏∂‡πà‡∏á',
    'used-devices': '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á',
    'installment': '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ú‡πà‡∏≠‡∏ô',
    'pawn': '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å',
    'repair': '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
    'accessories': '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà',
    'equipment': '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå',
    'simcard': '‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î',
    'expenses': '‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö-‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢',
    'bills': '‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏¥‡∏•',
    'settings': '‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤',
    'settings-notifications': '‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
    'settings-employees': '‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô'
};

// ===== REAL DATA ONLY - NO MOCK DATA =====
// All data is now fetched from the database via API

// Thai month names
const thaiMonths = [
    '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
    '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'
];

// ===== EXPENSE FORM MANAGEMENT =====

// Store expenses data
let expenses = [];
let currentExpenseEditId = null;

// Open expense modal
function openExpenseModal(type = null, expenseId = null) {
    const modal = document.getElementById('expenseModal');
    const modalTitle = document.getElementById('expenseModalTitle');
    const form = document.getElementById('expenseForm');
    
    form.reset();
    currentExpenseEditId = expenseId;
    
    if (expenseId) {
        // Edit mode
        modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£';
        const expense = expenses.find(e => e.id === expenseId);
        
        if (expense) {
            document.getElementById('expenseType').value = expense.type || 'expense';
            document.getElementById('expenseCategory').value = expense.category;
            document.getElementById('expenseDescription').value = expense.description;
            document.getElementById('expenseAmount').value = expense.amount;
            document.getElementById('expenseDate').value = expense.date;
            document.getElementById('expenseStore').value = expense.store;
            document.getElementById('expenseNote').value = expense.note || '';
        }
    } else {
        // Add mode
        if (type === 'income') {
            modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö';
            document.getElementById('expenseType').value = 'income';
        } else if (type === 'expense') {
            modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢';
            document.getElementById('expenseType').value = 'expense';
        } else {
            modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£';
        }
        
        // Set default date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('expenseDate').value = today;
        
        // Set default store to current store
        document.getElementById('expenseStore').value = currentStore;
    }
    
    handleExpenseTypeChange();
    modal.classList.add('show');
}

// Handle expense type change (income/expense)
function handleExpenseTypeChange() {
    const typeSelect = document.getElementById('expenseType');
    const categorySelect = document.getElementById('expenseCategory');
    
    if (!typeSelect || !categorySelect) return;
    
    const selectedType = typeSelect.value;
    
    // Clear current options
    categorySelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà --</option>';
    
    if (selectedType === 'income') {
        // Income categories
        categorySelect.innerHTML += `
            <option value="topup">‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô</option>
            <option value="topup-internet">‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏ô‡πá‡∏ï</option>
            <option value="device-commission">‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏¢‡∏≠‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
            <option value="sim-commission">‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏ã‡∏¥‡∏°</option>
        `;
    } else if (selectedType === 'expense') {
        // Expense categories
        categorySelect.innerHTML += `
            <option value="topup-rom">‡πÄ‡∏ï‡∏¥‡∏°‡∏£‡∏≠‡∏°</option>
            <option value="salary">‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô</option>
            <option value="staff-commission">‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô</option>
            <option value="salary-wage">‡∏Ñ‡πà‡∏≤‡πÅ‡∏£‡∏á‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô</option>
            <option value="rent">‡∏Ñ‡πà‡∏≤‡πÄ‡∏ä‡πà‡∏≤‡∏£‡πâ‡∏≤‡∏ô</option>
            <option value="utilities">‡∏Ñ‡πà‡∏≤‡∏ô‡πâ‡∏≥-‡∏Ñ‡πà‡∏≤‡πÑ‡∏ü</option>
            <option value="internet">‡∏Ñ‡πà‡∏≤‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï</option>
            <option value="transport">‡∏Ñ‡πà‡∏≤‡∏Ç‡∏ô‡∏™‡πà‡∏á</option>
            <option value="marketing">‡∏Ñ‡πà‡∏≤‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤/‡∏Å‡∏≤‡∏£‡∏ï‡∏•‡∏≤‡∏î</option>
            <option value="maintenance">‡∏Ñ‡πà‡∏≤‡∏ã‡πà‡∏≠‡∏°‡∏ö‡∏≥‡∏£‡∏∏‡∏á</option>
            <option value="supplies">‡∏Ñ‡πà‡∏≤‡∏ß‡∏±‡∏™‡∏î‡∏∏‡∏™‡∏¥‡πâ‡∏ô‡πÄ‡∏õ‡∏•‡∏∑‡∏≠‡∏á</option>
            <option value="other">‡∏≠‡∏∑‡πà‡∏ô‡πÜ</option>
        `;
    }
}

// Close expense modal
function closeExpenseModal() {
    const modal = document.getElementById('expenseModal');
    modal.classList.remove('show');
    currentExpenseEditId = null;
}

// Save expense
async function saveExpense(event) {
    event.preventDefault();

    const formData = new FormData(event.target);

    const expenseData = {
        type: formData.get('type') || 'expense',
        category: formData.get('category'),
        description: formData.get('description'),
        amount: parseFloat(formData.get('amount')),
        date: formData.get('date'),
        store: formData.get('store'),
        note: formData.get('note') || ''
    };

    try {
        const typeText = expenseData.type === 'income' ? '‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö' : '‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢';

        if (currentExpenseEditId) {
            // Update existing expense via API
            const response = await fetch(`http://localhost:5001/api/expenses/${currentExpenseEditId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(expenseData)
            });

            if (!response.ok) throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ');

            showNotification(`‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç${typeText}‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`, 'success');
        } else {
            // Create new expense via API
            const response = await fetch('http://localhost:5001/api/expenses', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(expenseData)
            });

            if (!response.ok) throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ');

            showNotification(`‡πÄ‡∏û‡∏¥‡πà‡∏°${typeText}‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`, 'success');
        }

        // Reload expense table
        await loadExpensesFromStorage();

        // Close modal
        closeExpenseModal();

    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Load expense table
function loadExpenseTable() {
    const incomeTbody = document.getElementById('incomeDetailsTableBody');
    const expenseTbody = document.getElementById('expenseDetailsTableBody');
    
    if (!incomeTbody || !expenseTbody) return;
    
    // Get selected month
    const selectedMonth = document.getElementById('expenseMonthSelect')?.value;
    
    // Filter by month (if selected)
    let filteredExpenses = expenses;
    if (selectedMonth) {
        filteredExpenses = expenses.filter(expense => {
            const expenseMonth = expense.date.slice(0, 7);
            return expenseMonth === selectedMonth;
        });
    }
    
    // Separate income and expenses
    const incomeItems = filteredExpenses.filter(item => item.type === 'income');
    const expenseItems = filteredExpenses.filter(item => item.type !== 'income');
    
    // Category labels
    const categoryLabels = {
        // Income categories
        'topup': '‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô',
        'topup-internet': '‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏ô‡πá‡∏ï',
        'topup-rom': '‡πÄ‡∏ï‡∏¥‡∏°‡∏£‡∏≠‡∏°',
        'salary': '‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',
        'staff-commission': '‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô',
        'device-commission': '‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏¢‡∏≠‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
        'sim-commission': '‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏ã‡∏¥‡∏°',
        // Expense categories
        'salary-wage': '‡∏Ñ‡πà‡∏≤‡πÅ‡∏£‡∏á‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô',
        'rent': '‡∏Ñ‡πà‡∏≤‡πÄ‡∏ä‡πà‡∏≤‡∏£‡πâ‡∏≤‡∏ô',
        'utilities': '‡∏Ñ‡πà‡∏≤‡∏ô‡πâ‡∏≥-‡∏Ñ‡πà‡∏≤‡πÑ‡∏ü',
        'internet': '‡∏Ñ‡πà‡∏≤‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï',
        'transport': '‡∏Ñ‡πà‡∏≤‡∏Ç‡∏ô‡∏™‡πà‡∏á',
        'marketing': '‡∏Ñ‡πà‡∏≤‡πÇ‡∏Ü‡∏©‡∏ì‡∏≤/‡∏Å‡∏≤‡∏£‡∏ï‡∏•‡∏≤‡∏î',
        'maintenance': '‡∏Ñ‡πà‡∏≤‡∏ã‡πà‡∏≠‡∏°‡∏ö‡∏≥‡∏£‡∏∏‡∏á',
        'supplies': '‡∏Ñ‡πà‡∏≤‡∏ß‡∏±‡∏™‡∏î‡∏∏‡∏™‡∏¥‡πâ‡∏ô‡πÄ‡∏õ‡∏•‡∏∑‡∏≠‡∏á',
        'other': '‡∏≠‡∏∑‡πà‡∏ô‡πÜ'
    };
    
    // Display income items
    if (incomeItems.length === 0) {
        incomeTbody.innerHTML = '<tr><td colspan="6" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        incomeItems.sort((a, b) => new Date(b.date) - new Date(a.date));
        incomeTbody.innerHTML = incomeItems.map(item => `
            <tr>
                <td>${categoryLabels[item.category] || item.category}</td>
                <td>${item.description}</td>
                <td>${formatCurrency(item.amount)}</td>
                <td>${formatDate(item.date)}</td>
                <td>${item.note || '-'}</td>
                <td>
                    <button class="action-btn btn-edit" onclick="openExpenseModal(null, '${item.id}')">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
                    <button class="action-btn btn-delete" onclick="deleteExpense('${item.id}')">‡∏•‡∏ö</button>
                </td>
            </tr>
        `).join('');
    }
    
    // Display expense items
    if (expenseItems.length === 0) {
        expenseTbody.innerHTML = '<tr><td colspan="6" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        expenseItems.sort((a, b) => new Date(b.date) - new Date(a.date));
        expenseTbody.innerHTML = expenseItems.map(item => `
            <tr>
                <td>${categoryLabels[item.category] || item.category}</td>
                <td>${item.description}</td>
                <td>${formatCurrency(item.amount)}</td>
                <td>${formatDate(item.date)}</td>
                <td>${item.note || '-'}</td>
                <td>
                    <button class="action-btn btn-edit" onclick="openExpenseModal(null, '${item.id}')">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
                    <button class="action-btn btn-delete" onclick="deleteExpense('${item.id}')">‡∏•‡∏ö</button>
                </td>
            </tr>
        `).join('');
    }
    
    // Calculate total
    const total = expenseItems.reduce((sum, item) => sum + item.amount, 0);
    updateExpenseTotal(total);
}

// Update expense total
function updateExpenseTotal(total) {
    const totalElement = document.getElementById('totalExpenseAmount');
    if (totalElement) {
        totalElement.textContent = formatCurrency(total);
    }
}

// Delete expense
async function deleteExpense(expenseId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
        message: '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'warning',
        confirmText: '‡∏•‡∏ö',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
        confirmType: 'danger'
    });

    if (!confirmed) return;

    try {
        // Delete via API
        const response = await fetch(`http://localhost:5001/api/expenses/${expenseId}`, {
            method: 'DELETE'
        });

        if (!response.ok) throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ');

        // Reload expense data
        await loadExpensesFromStorage();

        showNotification('‡∏•‡∏ö‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Load expenses from API
async function loadExpensesFromStorage() {
    try {
        const response = await fetch(`http://localhost:5001/api/expenses?store=${currentStore}`);
        if (!response.ok) throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ');

        expenses = await response.json();
        loadExpenseTable();
    } catch (error) {
        console.error('Error loading expenses:', error);
        expenses = [];
        loadExpenseTable();
    }
}

// Initialize page store selectors
function initializePageStoreSelectors() {
    const pageSelectors = document.querySelectorAll('.page-store-dropdown');
    pageSelectors.forEach(selector => {
        selector.value = currentStore;
    });
}

// ===== LOGO MANAGEMENT FUNCTIONS =====

// Default logo URL
const DEFAULT_LOGO_URL = 'https://i.imgur.com/z8R4qGK.png';

// Load logo from localStorage or use default
function loadStoreLogo() {
    const savedLogo = localStorage.getItem('storeLogo');
    const logoImg = document.getElementById('storeLogo');
    const logoPreview = document.getElementById('logoPreview');
    
    const logoUrl = savedLogo || DEFAULT_LOGO_URL;
    
    if (logoImg) {
        logoImg.src = logoUrl;
    }
    
    if (logoPreview) {
        logoPreview.src = logoUrl;
    }
}

// Handle logo upload
function handleLogoUpload(event) {
    const file = event.target.files[0];
    
    if (!file) return;
    
    // Validate file type
    if (!file.type.startsWith('image/')) {
        customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô',
            icon: 'error'
        });
        return;
    }
    
    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
        customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 5MB',
            icon: 'error'
        });
        return;
    }
    
    // Read and convert to base64
    const reader = new FileReader();
    
    reader.onload = function(e) {
        const logoUrl = e.target.result;
        
        // Save to localStorage
        localStorage.setItem('storeLogo', logoUrl);
        
        // Update logo in sidebar
        const logoImg = document.getElementById('storeLogo');
        if (logoImg) {
            logoImg.src = logoUrl;
        }
        
        // Update preview
        const logoPreview = document.getElementById('logoPreview');
        if (logoPreview) {
            logoPreview.src = logoUrl;
        }
        
        customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏•‡πÇ‡∏Å‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            icon: 'success'
        });
    };
    
    reader.onerror = function() {
        customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    };
    
    reader.readAsDataURL(file);
}

// Reset logo to default
async function resetLogoToDefault() {
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÇ‡∏•‡πÇ‡∏Å‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'warning'
    });
    
    if (confirmed) {
        // Remove from localStorage
        localStorage.removeItem('storeLogo');
        
        // Update logo in sidebar
        const logoImg = document.getElementById('storeLogo');
        if (logoImg) {
            logoImg.src = DEFAULT_LOGO_URL;
        }
        
        // Update preview
        const logoPreview = document.getElementById('logoPreview');
        if (logoPreview) {
            logoPreview.src = DEFAULT_LOGO_URL;
        }
        
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÇ‡∏•‡πÇ‡∏Å‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            icon: 'success'
        });
    }
}

// ===== SIDEBAR TOGGLE FUNCTIONS =====

// Toggle sidebar collapsed state
function toggleSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const isCollapsed = sidebar.classList.toggle('collapsed');
    
    // Save state to localStorage
    localStorage.setItem('sidebarCollapsed', isCollapsed);
}

// Load sidebar state on page load
function loadSidebarState() {
    const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
    const sidebar = document.querySelector('.sidebar');
    
    if (isCollapsed && sidebar) {
        sidebar.classList.add('collapsed');
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    // Load sidebar state
    loadSidebarState();
    // Load current store from localStorage or use default
    const savedStore = localStorage.getItem('currentStore');
    if (savedStore) {
        currentStore = savedStore;
    } else {
        // Save default store to localStorage
        localStorage.setItem('currentStore', currentStore);
    }

    // Load store logo
    loadStoreLogo();
    
    initializeNavigation();
    initializeMonthSelector();
    initializePageStoreSelectors();
    updateDashboard();
    
    // Add event listeners for brand inputs to toggle RAM requirement
    const brandInput = document.getElementById('brand');
    if (brandInput) {
        brandInput.addEventListener('input', toggleRamRequired);
        brandInput.addEventListener('change', toggleRamRequired);
    }
    
    const usedBrandInput = document.getElementById('usedBrand');
    if (usedBrandInput) {
        usedBrandInput.addEventListener('input', toggleUsedRamRequired);
        usedBrandInput.addEventListener('change', toggleUsedRamRequired);
    }
});

// Navigation functionality
function initializeNavigation() {
    const navItems = document.querySelectorAll('.nav-item');

    navItems.forEach(item => {
        item.addEventListener('click', function() {
            // Remove active class from all items
            navItems.forEach(nav => nav.classList.remove('active'));

            // Add active class to clicked item
            this.classList.add('active');

            // Get page to show
            const page = this.getAttribute('data-page');

            // Hide all pages
            const allPages = document.querySelectorAll('.page-content');
            allPages.forEach(p => p.classList.remove('active'));

            // Show selected page
            const selectedPage = document.getElementById(page);
            if (selectedPage) {
                selectedPage.classList.add('active');
            }

            // Update page title
            const pageTitle = document.getElementById('pageTitle');
            pageTitle.textContent = pageTitles[page] || '‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏£‡πâ‡∏≤‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠';

            // Load data for specific pages
            if (page === 'accessories') {
                loadAccessoriesData();
                // Ensure accessories tabs work when navigating via sidebar
                switchAccessoryTab(currentAccessoryTab || 'battery');
            } else if (page === 'equipment') {
                loadEquipmentData();
                // Ensure equipment tabs work when navigating via sidebar
                switchEquipmentTab(currentEquipmentTab || 'charger-set');
            } else if (page === 'new-devices') {
                loadNewDevicesData();
                // Ensure new devices tabs work when navigating via sidebar
                initializeNewTabs();
                // Initialize date filter
                initializeNewDevicesDateFilter();
                // Initialize search
                initializeSearch();
            } else if (page === 'used-devices') {
                loadUsedDevicesData();
                // Ensure used-devices tabs work when navigating via sidebar
                initializeUsedTabs();
                // Initialize date filter
                initializeUsedDevicesDateFilter();
                // Initialize search
                initializeUsedSearch();
            } else if (page === 'repair') {
                loadRepairData();
                // Ensure repair tabs work when navigating via sidebar
                initializeRepairTabs();
            } else if (page === 'installment') {
                loadInstallmentData();
                // Ensure installment tabs work when navigating via sidebar
                initializeInstallmentTabs();
            } else if (page === 'pawn') {
                loadPawnData();
                // Ensure pawn tabs work when navigating via sidebar
                initializePawnTabs();
                // Initialize date filter
                initializePawnDateFilter();
            } else if (page === 'simcard') {
                loadSimcardData();
                initializeSimcardTabs();
                initializeSimcardSearch();
            } else if (page === 'expenses') {
                loadExpensesFromStorage();
                initializeExpenseMonthSelector();
            } else if (page === 'settings-notifications') {
                loadNotificationSettings();
            } else if (page === 'settings-employees') {
                loadEmployeesData();
            }
        });
    });
}

// Store selector functionality (removed from sidebar, now only in pages)
function initializeStoreSelector() {
    // No longer needed as store selector removed from sidebar
    // Store selection now handled by page-store-dropdown via changeStoreFromPage()
    return;
}

// Switch store within page
function switchStoreInPage(store, page) {
    // Update current store
    currentStore = store;

    // Save to localStorage so displayEquipmentByTab can use it
    localStorage.setItem('currentStore', store);

    // Update store display in sidebar
    const currentStoreDisplay = document.getElementById('currentStore');
    const storeSelect = document.getElementById('storeSelect');
    if (currentStoreDisplay) {
        currentStoreDisplay.textContent = stores[store];
    }
    if (storeSelect) {
        storeSelect.value = store;
    }

    // Update all store toggle buttons
    updateStoreToggleButtons();

    // Reload data for the specific page
    if (page === 'newDevices') {
        loadNewDevicesData();
    } else if (page === 'usedDevices') {
        loadUsedDevicesData();
    }

    // Update dashboard
    updateDashboard();
}

// Change store from page selector
function changeStoreFromPage(store) {
    // Update current store
    currentStore = store;

    // Save to localStorage so displayEquipmentByTab can use it
    localStorage.setItem('currentStore', store);

    // Update store display in header
    const currentStoreDisplay = document.getElementById('currentStore');
    if (currentStoreDisplay) {
        currentStoreDisplay.textContent = stores[store];
    }

    // Update sidebar selector
    const storeSelect = document.getElementById('storeSelect');
    if (storeSelect) {
        storeSelect.value = store;
    }

    // Update all page selectors
    const pageSelectors = document.querySelectorAll('.page-store-dropdown');
    pageSelectors.forEach(selector => {
        selector.value = store;
    });

    // Update store toggle buttons
    updateStoreToggleButtons();

    // Update dashboard
    updateDashboard();

    // Reload data for all pages
    loadNewDevicesData();
    loadUsedDevicesData();
    loadRepairData();
    loadInstallmentData();
    loadPawnData();
    loadAccessoriesData();
    loadEquipmentData();

    // Show notification
    showStoreChangeNotification();
}

// Month selector functionality
function initializeMonthSelector() {
    const monthSelect = document.getElementById('monthSelect');
    if (!monthSelect) return;

    // Generate last 12 months
    const months = [];
    const today = new Date();

    for (let i = 0; i < 12; i++) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const yearMonth = date.toISOString().slice(0, 7);
        const year = date.getFullYear();
        const month = date.getMonth();
        const thaiYear = year + 543; // Convert to Buddhist calendar

        months.push({
            value: yearMonth,
            label: `${thaiMonths[month]} ${thaiYear}`
        });
    }

    // Populate month selector
    monthSelect.innerHTML = months.map(m =>
        `<option value="${m.value}">${m.label}</option>`
    ).join('');

    // Set current month as selected
    monthSelect.value = currentMonth;

    // Add change event listener
    monthSelect.addEventListener('change', function() {
        currentMonth = this.value;
        updateDashboard();
    });
}

// Update dashboard with data
// Calculate installment data for all stores combined
function calculateAllStoresInstallmentData(installmentDevicesData, filter = null) {
    console.log('\nüí≥ [Calculate Installment Data] ========== START ==========');
    console.log('üí≥ Total Installments:', installmentDevicesData?.length || 0);
    console.log('üí≥ Filter:', filter);
    
    if (!installmentDevicesData || installmentDevicesData.length === 0) {
        return {
            totalIncome: 0,
            totalExpense: 0,
            totalProfit: 0
        };
    }
    
    // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ filter (‡πÉ‡∏ä‡πâ down_payment_date)
    let filteredInstallments = installmentDevicesData.filter(i => 
        i.status === 'active' || i.status === 'completed'
    );
    
    if (filter && (filter.startDate || filter.endDate)) {
        console.log('üí≥ [MODE: Date Range Filter]');
        console.log(`   Filter Start: ${filter.startDate}`);
        console.log(`   Filter End: ${filter.endDate}`);
        
        filteredInstallments = filteredInstallments.filter(i => {
            const downPaymentDate = i.down_payment_date || i.downPaymentDate;
            
            console.log(`\n   üìã Checking Installment ID ${i.id}:`);
            console.log(`      Brand/Model: ${i.brand} ${i.model}`);
            console.log(`      Status: ${i.status}`);
            console.log(`      down_payment_date: ${downPaymentDate}`);
            console.log(`      commission: ‡∏ø${(i.commission || 0).toLocaleString()}`);
            
            if (!downPaymentDate) {
                console.log(`      ‚ùå No down_payment_date`);
                return false;
            }
            
            const date = new Date(downPaymentDate);
            const filterStart = new Date(filter.startDate);
            const filterEnd = new Date(filter.endDate);
            
            console.log(`      Date Comparison:`);
            console.log(`         down_payment_date: ${date.toISOString().split('T')[0]}`);
            console.log(`         filter start:      ${filterStart.toISOString().split('T')[0]}`);
            console.log(`         filter end:        ${filterEnd.toISOString().split('T')[0]}`);
            
            const startMatch = !filter.startDate || date >= filterStart;
            const endMatch = !filter.endDate || date <= filterEnd;
            const isMatch = startMatch && endMatch;
            
            console.log(`         date >= start: ${startMatch}`);
            console.log(`         date <= end:   ${endMatch}`);
            console.log(`         ‚Üí ${isMatch ? '‚úÖ MATCH' : '‚ùå NO MATCH'}`);
            
            return isMatch;
        });
    } else {
        console.log('üí≥ [MODE: No Filter - All active/completed]');
    }
    
    console.log(`\nüí≥ After filtering: ${filteredInstallments.length} items`);
    
    // ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏° installment_type (‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏£‡πâ‡∏≤‡∏ô)
    const partnerInstallments = filteredInstallments.filter(i => 
        (i.installment_type || i.installmentType) === 'partner'
    );
    const storeOnlyInstallments = filteredInstallments.filter(i => 
        (i.installment_type || i.installmentType) === 'store'
    );
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢
    // Partner: ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ = 0 (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏≠‡∏á)
    // ‡∏£‡πâ‡∏≤‡∏ô: ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ = ‡∏¢‡∏≠‡∏î‡∏à‡∏±‡∏î + ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ
    const expensePartner = 0;
    const expenseStore = storeOnlyInstallments.reduce((sum, i) => {
        const salePrice = parseFloat(i.sale_price || i.salePrice) || 0;
        const lockSystemFee = parseFloat(i.lock_system_fee || i.lockSystemFee) || 0;
        return sum + salePrice + lockSystemFee;
    }, 0);
    const totalExpense = expensePartner + expenseStore;
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö
    // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö = ‡∏£‡∏ß‡∏° commission ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏ó‡∏±‡πâ‡∏á partner ‡πÅ‡∏•‡∏∞ store)
    console.log('\nüí≥ [Calculating Income - Commission only]:');
    const totalIncome = filteredInstallments.reduce((sum, i) => {
        const commission = parseFloat(i.commission) || 0;
        if (commission > 0) {
            console.log(`   üíµ ID ${i.id}: ${i.brand} ${i.model} = ‡∏ø${commission.toLocaleString()}`);
        }
        return sum + commission;
    }, 0);
    
    const incomePartner = partnerInstallments.reduce((sum, i) => sum + (parseFloat(i.commission) || 0), 0);
    const incomeStore = storeOnlyInstallments.reduce((sum, i) => sum + (parseFloat(i.commission) || 0), 0);
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£
    const totalProfit = totalIncome - totalExpense;
    
    console.log('\nüí≥ [FINAL RESULT]');
    console.log('üìä Installment Data (ALL STORES):');
    console.log('   Partner:', {
            count: partnerInstallments.length,
        income: `‡∏ø${incomePartner.toLocaleString()} (commission)`,
        expense: `‡∏ø${expensePartner.toLocaleString()}`
    });
    console.log('   Store:', {
            count: storeOnlyInstallments.length,
        income: `‡∏ø${incomeStore.toLocaleString()} (commission)`,
        expense: `‡∏ø${expenseStore.toLocaleString()}`
    });
    console.log('   Total:', {
        income: `‡∏ø${totalIncome.toLocaleString()} (commission only)`,
        expense: `‡∏ø${totalExpense.toLocaleString()}`,
        profit: `‡∏ø${totalProfit.toLocaleString()}`
    });
    console.log('üí≥ [Calculate Installment Data] ========== END ==========\n');
    
    return {
        totalIncome,
        totalExpense,
        totalProfit,
        partnerInstallments,
        storeOnlyInstallments
    };
}

// Calculate pawn data for all stores combined (using date filter)
async function calculateAllStoresPawnData(pawnDevicesData, filter = null) {
    if (!pawnDevicesData || pawnDevicesData.length === 0) {
        return {
            totalIncome: 0,
            totalExpense: 0,
            totalProfit: 0
        };
    }
    
    // ‡πÉ‡∏ä‡πâ filter ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ currentDashboardFilter ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏
    const appliedFilter = filter || currentDashboardFilter;
    
    // Helper function to check if date is within filter range
    const isDateInRange = (dateString) => {
        if (!dateString) return false;
        
        const date = new Date(dateString);
        
        if (appliedFilter.startDate || appliedFilter.endDate) {
            // Use date range filter
            const startMatch = !appliedFilter.startDate || 
                              date >= new Date(appliedFilter.startDate);
            const endMatch = !appliedFilter.endDate || 
                            date <= new Date(appliedFilter.endDate + 'T23:59:59');
            return startMatch && endMatch;
        } else {
            // Default: current month
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        }
    };
    
    // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å (‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏£‡πâ‡∏≤‡∏ô ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date)
    let totalIncome = 0;
    
    // 1. ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å (deducted) - ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° receive_date
    const deductedPawns = pawnDevicesData.filter(pawn => {
        if ((pawn.interest_collection_method || pawn.interestCollectionMethod) !== 'deducted') return false;
        const receiveDate = pawn.receive_date || pawn.receiveDate;
        return isDateInRange(receiveDate);
    });
    const deductedInterest = deductedPawns.reduce((sum, pawn) => {
        return sum + (parseFloat(pawn.interest) || 0);
    }, 0);
    totalIncome += deductedInterest;
    
    // 2. ‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô - ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° return_date
    const returnedPawns = pawnDevicesData.filter(pawn => {
        if (pawn.status !== 'returned') return false;
        const returnDate = pawn.return_date || pawn.returnDate;
        return isDateInRange(returnDate);
    });
    const returnedRedemption = returnedPawns.reduce((sum, pawn) => {
        return sum + (parseFloat(pawn.redemption_amount || pawn.redemptionAmount) || 0);
    }, 0);
    totalIncome += returnedRedemption;
    
    // 3. ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å (‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å pawn-interest table) - ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° transaction_date
    let renewalIncome = 0;
    try {
        const interestTransactions = await API.get('http://localhost:5001/api/pawn-interest');
        const renewalTransactions = interestTransactions.filter(t => {
            if (t.transaction_type !== 'renewal') return false;
            const transactionDate = t.transaction_date || t.transactionDate;
            return isDateInRange(transactionDate);
        });
        renewalIncome = renewalTransactions.reduce((sum, t) => {
            return sum + (parseFloat(t.interest_amount) || 0) + (parseFloat(t.late_fee) || 0);
        }, 0);
        totalIncome += renewalIncome;
    } catch (error) {
        console.warn('Could not fetch pawn interest transactions:', error);
    }
    
    // ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å = ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏¢‡∏∑‡∏° (pawn_amount) - ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° receive_date
    const expensePawns = pawnDevicesData.filter(pawn => {
        if (pawn.status !== 'active' && pawn.status !== 'returned') return false;
        const receiveDate = pawn.receive_date || pawn.receiveDate;
        return isDateInRange(receiveDate);
    });
    const totalExpense = expensePawns.reduce((sum, pawn) => {
        return sum + (parseFloat(pawn.pawn_amount || pawn.pawnAmount) || 0);
    }, 0);
    
    // ‡∏Å‡∏≥‡πÑ‡∏£ = ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö - ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢
    const totalProfit = totalIncome - totalExpense;
    
    console.log('üìä Pawn Data (ALL STORES - With Date Filter):', {
        filter: appliedFilter,
        deductedPawns: {
            count: deductedPawns.length,
            interest: deductedInterest
        },
        returnedPawns: {
            count: returnedPawns.length,
            redemption: returnedRedemption
        },
        renewalIncome: renewalIncome,
        expensePawns: {
            count: expensePawns.length,
            expense: totalExpense
        },
        total: {
            income: totalIncome,
            expense: totalExpense,
            profit: totalProfit
        }
    });
    
    return {
        totalIncome,
        totalExpense,
        totalProfit,
        deductedPawns,
        returnedPawns,
        expensePawns
    };
}

async function updateDashboard() {
    console.log('üîÑ Updating dashboard with real data from API (ALL STORES)...');
    console.log('Month:', currentMonth);

    // Get real data from new devices database via API - ALL STORES
    let realNewDevicesCount = 0;
    let newDevicesData = [];
    try {
        newDevicesData = await API.get(API_ENDPOINTS.newDevices); // ‡πÑ‡∏°‡πà filter ‡∏ï‡∏≤‡∏° store
        realNewDevicesCount = newDevicesData.filter(d => d.status === 'stock').length;
    } catch (error) {
        console.error('Error fetching new devices for dashboard:', error);
    }

    // Get real data from used devices database via API - ALL STORES
    let realUsedDevicesCount = 0;
    let usedDevicesData = [];
    try {
        usedDevicesData = await API.get(API_ENDPOINTS.usedDevices); // ‡πÑ‡∏°‡πà filter ‡∏ï‡∏≤‡∏° store
        realUsedDevicesCount = usedDevicesData.filter(d => d.status === 'stock').length;
    } catch (error) {
        console.error('Error fetching used devices for dashboard:', error);
    }

    // Get real data from pawn devices database via API - ALL STORES
    let realPawnDevicesCount = 0;
    let pawnDevicesData = [];
    try {
        pawnDevicesData = await API.get(API_ENDPOINTS.pawn); // ‡πÑ‡∏°‡πà filter ‡∏ï‡∏≤‡∏° store
        realPawnDevicesCount = pawnDevicesData.filter(p => p.status === 'active').length;
        console.log('Pawn devices count (ALL STORES):', {
            total: pawnDevicesData.length,
            active: realPawnDevicesCount
        });
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Pawn Dashboard ‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏£‡πâ‡∏≤‡∏ô (‡πÉ‡∏ä‡πâ currentDashboardFilter)
        window.allStoresPawnData = await calculateAllStoresPawnData(pawnDevicesData, currentDashboardFilter);
    } catch (error) {
        console.error('Error fetching pawn devices for dashboard:', error);
    }

    // Get real data from installment devices database via API - ALL STORES
    let installmentDevicesData = [];
    try {
        installmentDevicesData = await API.get(API_ENDPOINTS.installments); // ‡πÑ‡∏°‡πà filter ‡∏ï‡∏≤‡∏° store
        console.log('Installment devices count (ALL STORES):', {
            total: installmentDevicesData.length,
            active: installmentDevicesData.filter(i => i.status === 'active').length,
            completed: installmentDevicesData.filter(i => i.status === 'completed').length
        });
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Installment Dashboard ‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏£‡πâ‡∏≤‡∏ô (‡∏û‡∏£‡πâ‡∏≠‡∏° filter)
        window.allStoresInstallmentData = calculateAllStoresInstallmentData(installmentDevicesData, currentDashboardFilter);
    } catch (error) {
        console.error('Error fetching installment devices for dashboard:', error);
    }

    // Calculate income breakdown from real data
    const currentYear = currentMonth.substring(0, 4);
    const currentMonthNum = currentMonth.substring(5, 7);

    // Income from new devices (sold in current month or date range)
    let incomeNewDevices = 0;
    if (newDevicesData.length > 0) {
        let filteredNewDevicesForIncome;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ sale_date)
            filteredNewDevicesForIncome = newDevicesData
                .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
                .filter(d => {
                    const saleDate = new Date(d.sale_date || d.saleDate);
                    const filterStart = new Date(currentDashboardFilter.startDate);
                    const filterEnd = new Date(currentDashboardFilter.endDate);
                    return saleDate >= filterStart && saleDate <= filterEnd;
                });
        } else {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ sale_date)
            filteredNewDevicesForIncome = newDevicesData
            .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
            .filter(d => {
                const saleDate = new Date(d.sale_date || d.saleDate);
                return saleDate.getFullYear().toString() === currentYear &&
                       (saleDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
                });
    }

        incomeNewDevices = filteredNewDevicesForIncome.reduce((sum, d) => sum + (parseFloat(d.sale_price || d.salePrice) || 0), 0);
    }

    // Income from used devices (sold in current month or date range)
    let incomeUsedDevices = 0;
    if (usedDevicesData.length > 0) {
        let filteredUsedDevicesForIncome;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ sale_date)
            filteredUsedDevicesForIncome = usedDevicesData
                .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
                .filter(d => {
                    const saleDate = new Date(d.sale_date || d.saleDate);
                    const filterStart = new Date(currentDashboardFilter.startDate);
                    const filterEnd = new Date(currentDashboardFilter.endDate);
                    return saleDate >= filterStart && saleDate <= filterEnd;
                });
        } else {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ sale_date)
            filteredUsedDevicesForIncome = usedDevicesData
            .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
            .filter(d => {
                const saleDate = new Date(d.sale_date || d.saleDate);
                return saleDate.getFullYear().toString() === currentYear &&
                       (saleDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
                });
    }

        incomeUsedDevices = filteredUsedDevicesForIncome.reduce((sum, d) => sum + (parseFloat(d.sale_price || d.salePrice) || 0), 0);
    }

    // Income from installments - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Installment Dashboard (ALL STORES + filtered by down_payment_date)
    let incomeInstallment = 0;
    if (window.allStoresInstallmentData) {
        incomeInstallment = window.allStoresInstallmentData.totalIncome || 0;
        console.log('‚úÖ Installment income from dashboard data (ALL STORES + filtered):', {
            totalIncome: `‡∏ø${incomeInstallment.toLocaleString()} (commission only)`,
            source: 'allStoresInstallmentData',
            filter: currentDashboardFilter
        });
                } else {
        console.warn('‚ö†Ô∏è allStoresInstallmentData not available, installment income = 0');
    }

    // Income from pawn - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Pawn Dashboard (ALL STORES)
    let incomePawn = 0;
    if (window.allStoresPawnData) {
        incomePawn = window.allStoresPawnData.totalIncome || 0;
        console.log('‚úÖ Pawn income from dashboard data (ALL STORES):', {
            totalIncome: incomePawn,
            source: 'allStoresPawnData'
        });
    } else {
        console.warn('‚ö†Ô∏è allStoresPawnData not available, pawn income = 0');
    }

    // Income from repairs - ALL STORES (Salaya + Klongyong)
    let incomeRepair = 0;
    try {
        const salayaRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'salaya' });
        const klongyongRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'klongyong' });
        const allRepairsForIncome = [...salayaRepairs, ...klongyongRepairs];
        
        console.log(`\nüí∞ [Income Repair Card] ========== START ==========`);
        console.log(`üí∞ Total Repairs - Salaya: ${salayaRepairs.length}, Klongyong: ${klongyongRepairs.length}, All: ${allRepairsForIncome.length}`);
        console.log(`üí∞ Current Dashboard Filter:`, currentDashboardFilter);
        
        let filteredRepairsForIncome;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ returned_date - ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô)
            console.log(`üí∞ [MODE: Date Range Filter]`);
            console.log(`   Filter Start: ${currentDashboardFilter.startDate}`);
            console.log(`   Filter End: ${currentDashboardFilter.endDate}`);
            
            filteredRepairsForIncome = allRepairsForIncome.filter(r => {
                const returnedDate = r.returned_date || r.returnedDate;
                const isReceived = r.status === 'received';
                
                console.log(`\n   üìã Checking Repair ID ${r.id}:`);
                console.log(`      Brand/Model: ${r.brand} ${r.model}`);
                console.log(`      Status: ${r.status} ‚Üí ${isReceived ? '‚úÖ' : '‚ùå (not received)'}`);
                console.log(`      returned_date: ${returnedDate || 'N/A'}`);
                
                if (!isReceived) return false;
                if (!returnedDate) {
                    console.log(`      ‚ùå No returned_date`);
                    return false;
                }
                
                const date = new Date(returnedDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);
                
                console.log(`      Date Comparison:`);
                console.log(`         returned_date: ${date.toISOString().split('T')[0]}`);
                console.log(`         filter start:  ${filterStart.toISOString().split('T')[0]}`);
                console.log(`         filter end:    ${filterEnd.toISOString().split('T')[0]}`);
                
                const startMatch = date >= filterStart;
                const endMatch = date <= filterEnd;
                const isMatch = startMatch && endMatch;
                
                console.log(`         date >= start: ${startMatch}`);
                console.log(`         date <= end:   ${endMatch}`);
                console.log(`         ‚Üí ${isMatch ? '‚úÖ MATCH' : '‚ùå NO MATCH'}`);
                
                return isMatch;
            });
        } else {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ returned_date)
            console.log(`üí∞ [MODE: Current Month Filter]`);
            console.log(`   Current Year: ${currentYear}, Month: ${currentMonthNum}`);
            
            filteredRepairsForIncome = allRepairsForIncome.filter(r => {
                if (r.status !== 'received') return false;
                
                const returnedDate = r.returned_date || r.returnedDate;
                if (!returnedDate) return false;
                
                const date = new Date(returnedDate);
                const match = date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
                
                console.log(`   ${match ? '‚úÖ' : '‚ùå'} ID ${r.id}: ${returnedDate} => ${date.getMonth() + 1}/${date.getFullYear()}`);
                
                return match;
            });
        }
        
        // ‡∏£‡∏ß‡∏° repair_cost
        incomeRepair = filteredRepairsForIncome.reduce((sum, r) => {
            const repairCost = parseFloat(r.repair_cost || r.repairCost || r.price || 0);
            console.log(`   üíµ Adding ID ${r.id}: ‡∏ø${repairCost.toLocaleString()}`);
            return sum + repairCost;
        }, 0);
        
        console.log(`\nüí∞ [FINAL RESULT]`);
        console.log(`   Filtered Count: ${filteredRepairsForIncome.length} items`);
        console.log(`   Total Income: ‡∏ø${incomeRepair.toLocaleString()}`);
        console.log(`üí∞ [Income Repair Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error loading repair income:', error);
        incomeRepair = 0;
    }

    // Income from accessories (parts/‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà) - ALL STORES
    let incomeParts = 0;
    try {
        const salayaCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: 'salaya' });
        const klongyongCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: 'klongyong' });
        const allCutAccessories = [...salayaCutAccessories, ...klongyongCutAccessories];

        console.log(`\nüî© [Income Parts Card] ========== START ==========`);
        console.log(`üî© Total Cut Accessories - Salaya: ${salayaCutAccessories.length}, Klongyong: ${klongyongCutAccessories.length}, All: ${allCutAccessories.length}`);

        let filteredCutAccessories;

        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            filteredCutAccessories = allCutAccessories.filter(a => {
                const cutDate = a.cut_date || a.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);

                return date >= filterStart && date <= filterEnd;
            });
        } else {
            filteredCutAccessories = allCutAccessories.filter(a => {
                const cutDate = a.cut_date || a.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            });
        }

        incomeParts = filteredCutAccessories.reduce((sum, a) => {
            const cutPrice = parseFloat(a.cut_price || a.cutPrice) || 0;
            const cutQty = parseFloat(a.cut_quantity || a.cutQuantity) || 0;
            return sum + (cutPrice * cutQty);
        }, 0);

        console.log(`üî© [FINAL RESULT] Total Income: ‡∏ø${incomeParts.toLocaleString()}`);
        console.log(`üî© [Income Parts Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error loading accessories income:', error);
        incomeParts = 0;
    }

    // Income from equipment (‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå) - ALL STORES
    let incomeAccessories = 0;
    try {
        const salayaEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'salaya' });
        const klongyongEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'klongyong' });
        const allEquipment = [...salayaEquipment, ...klongyongEquipment];

        console.log(`\nüì¶ [Income Accessories Card] ========== START ==========`);
        console.log(`üì¶ Total Equipment - Salaya: ${salayaEquipment.length}, Klongyong: ${klongyongEquipment.length}, All: ${allEquipment.length}`);

        let filteredEquipment;

        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            filteredEquipment = allEquipment.filter(e => {
                const cutDate = e.cut_date || e.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);

                return date >= filterStart && date <= filterEnd;
            });
        } else {
            filteredEquipment = allEquipment.filter(e => {
                const cutDate = e.cut_date || e.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            });
        }

        incomeAccessories = filteredEquipment.reduce((sum, e) => {
            const cutPrice = parseFloat(e.cut_price || e.cutPrice) || 0;
            const cutQty = parseFloat(e.cut_quantity || e.cutQuantity) || 0;
            return sum + (cutPrice * cutQty);
        }, 0);

        console.log(`üì¶ [FINAL RESULT] Total Income: ‡∏ø${incomeAccessories.toLocaleString()}`);
        console.log(`üì¶ [Income Accessories Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error loading equipment income:', error);
        incomeAccessories = 0;
    }

    // Income from simcard (‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î) - ALL STORES
    let incomeSimcard = 0;
    try {
        const salayaSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'salaya' });
        const klongyongSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'klongyong' });
        const allSimcards = [...salayaSimcards, ...klongyongSimcards];

        console.log(`\nüî∑ [Income Simcard Card] ========== START ==========`);
        console.log(`üî∑ Total Simcards - Salaya: ${salayaSimcards.length}, Klongyong: ${klongyongSimcards.length}, All: ${allSimcards.length}`);

        let filteredSimcards;

        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            filteredSimcards = allSimcards.filter(s => {
                if (s.status !== 'sold') return false;
                const soldDate = s.sold_date || s.soldDate;
                if (!soldDate) return false;

                const date = new Date(soldDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);

                return date >= filterStart && date <= filterEnd;
            });
        } else {
            filteredSimcards = allSimcards.filter(s => {
                if (s.status !== 'sold') return false;
                const soldDate = s.sold_date || s.soldDate;
                if (!soldDate) return false;

                const date = new Date(soldDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            });
        }

        incomeSimcard = filteredSimcards.reduce((sum, s) => {
            const salePrice = parseFloat(s.sale_price || s.salePrice) || 0;
            return sum + salePrice;
        }, 0);

        console.log(`üî∑ [FINAL RESULT] Total Income: ‡∏ø${incomeSimcard.toLocaleString()}`);
        console.log(`üî∑ [Income Simcard Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error loading simcard income:', error);
        incomeSimcard = 0;
    }

    // Calculate total income (ensure all values are numbers)
    const totalIncomeAmount = parseFloat(incomeNewDevices || 0) +
                              parseFloat(incomeUsedDevices || 0) +
                              parseFloat(incomeInstallment || 0) +
                              parseFloat(incomePawn || 0) +
                              parseFloat(incomeRepair || 0) +
                              parseFloat(incomeParts || 0) +
                              parseFloat(incomeAccessories || 0) +
                              parseFloat(incomeSimcard || 0);

    // Log income breakdown by menu for verification
    console.log('üìä [Dashboard Cards Verification] Income Breakdown by Menu:', {
        newDevices: formatCurrency(incomeNewDevices),
        usedDevices: formatCurrency(incomeUsedDevices),
        installment: formatCurrency(incomeInstallment),
        pawn: formatCurrency(incomePawn),
        repair: formatCurrency(incomeRepair),
        parts: formatCurrency(incomeParts),
        accessories: formatCurrency(incomeAccessories),
        simcard: formatCurrency(incomeSimcard),
        total: formatCurrency(totalIncomeAmount)
    });

    // Update Main Dashboard Cards (4 ‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏´‡∏•‡∏±‡∏Å)
    const statPawnCount = document.getElementById('statPawnCount');
    const statTotalExpense = document.getElementById('statTotalExpense');
    const statTotalIncome = document.getElementById('statTotalIncome');
    const statProfit = document.getElementById('statProfit');

    // Update ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ù‡∏≤‡∏Å
    if (statPawnCount) statPawnCount.textContent = realPawnDevicesCount;

    // Update Quick Access Menu counts
    const quickNewDevices = document.getElementById('quickNewDevices');
    const quickUsedDevices = document.getElementById('quickUsedDevices');
    const quickInstallment = document.getElementById('quickInstallment');
    const quickRepair = document.getElementById('quickRepair');
    const quickAccessories = document.getElementById('quickAccessories');
    const quickEquipment = document.getElementById('quickEquipment');
    const quickSimcard = document.getElementById('quickSimcard');

    if (quickNewDevices) quickNewDevices.textContent = `${realNewDevicesCount} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á`;
    if (quickUsedDevices) quickUsedDevices.textContent = `${realUsedDevicesCount} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á`;

    // Count installment devices - ALL STORES (‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
    try {
        let installmentCount = 0;
        
        if (installmentDevicesData && installmentDevicesData.length > 0) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ active ‡πÅ‡∏•‡∏∞ down_payment_date ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            installmentCount = installmentDevicesData.filter(i => {
                if (i.status !== 'active') return false;
                
                const downPaymentDate = i.down_payment_date || i.downPaymentDate;
                if (!downPaymentDate) return false;
                
                const date = new Date(downPaymentDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            }).length;
        }
        
        console.log(`üí≥ [Dashboard Installment] Count for current month (${currentYear}-${currentMonthNum}): ${installmentCount}`);
        
        if (quickInstallment) quickInstallment.textContent = `${installmentCount} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á`;
    } catch (error) {
        console.error('Error loading installment count:', error);
        if (quickInstallment) quickInstallment.textContent = '0 ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á';
    }

    // Count repair devices - ALL STORES (Salaya + Klongyong)
    try {
        const salayaRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'salaya' });
        const klongyongRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'klongyong' });
        const allRepairs = [...salayaRepairs, ...klongyongRepairs];
        
        console.log(`üîß [Dashboard Repair] Total Repairs - Salaya: ${salayaRepairs.length}, Klongyong: ${klongyongRepairs.length}, All: ${allRepairs.length}`);
        
        let filteredRepairs;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ received_date)
            console.log(`üîß [Dashboard Repair] Filtering by date range: ${currentDashboardFilter.startDate} to ${currentDashboardFilter.endDate}`);
            filteredRepairs = allRepairs.filter(r => {
                const receivedDate = r.received_date || r.receivedDate || r.receive_date || r.receiveDate;
                if (!receivedDate) return false;
                
                const date = new Date(receivedDate);
                const startMatch = !currentDashboardFilter.startDate || 
                                  date >= new Date(currentDashboardFilter.startDate);
                const endMatch = !currentDashboardFilter.endDate || 
                                date <= new Date(currentDashboardFilter.endDate);
                
                return startMatch && endMatch;
            });
        } else {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ received_date)
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();
            
            console.log(`üîß [Dashboard Repair] Filtering by current month: ${currentMonth}/${currentYear}`);
            filteredRepairs = allRepairs.filter(r => {
                const receivedDate = r.received_date || r.receivedDate || r.receive_date || r.receiveDate;
                if (!receivedDate) return false;
                
                const date = new Date(receivedDate);
                const repairMonth = date.getMonth() + 1;
                const repairYear = date.getFullYear();
                
                return repairMonth === currentMonth && repairYear === currentYear;
            });
        }
        
        const filteredCount = filteredRepairs.length;
        console.log(`üîß [Dashboard Repair] Filtered Count: ${filteredCount}`);
        
        if (quickRepair) quickRepair.textContent = `${filteredCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`;
    } catch (error) {
        console.error('Error loading repair count:', error);
        if (quickRepair) quickRepair.textContent = '0 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£';
    }

    // Get accessories stock from ALL STORES (sum of quantities)
    try {
        const salayaAccessories = await API.get(API_ENDPOINTS.accessories, { store: 'salaya' });
        const klongyongAccessories = await API.get(API_ENDPOINTS.accessories, { store: 'klongyong' });
        
        // Sum total quantity from both stores
        const salayaStock = salayaAccessories.reduce((sum, a) => sum + Number(a.quantity || 0), 0);
        const klongyongStock = klongyongAccessories.reduce((sum, a) => sum + Number(a.quantity || 0), 0);
        const totalAccessoriesStock = salayaStock + klongyongStock;
        
        if (quickAccessories) quickAccessories.textContent = `${totalAccessoriesStock} ‡∏ä‡∏¥‡πâ‡∏ô`;
        console.log(`[Dashboard] Accessories Stock: Salaya ${salayaStock}, Klongyong ${klongyongStock}, Total ${totalAccessoriesStock}`);
    } catch (error) {
        console.error('[Dashboard] Error loading accessories stock:', error);
        if (quickAccessories) quickAccessories.textContent = `0 ‡∏ä‡∏¥‡πâ‡∏ô`;
    }

    // Get equipment stock from ALL STORES (sum of quantities)
    try {
        const salayaEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'salaya' });
        const klongyongEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'klongyong' });

        // Sum total quantity from both stores
        const salayaEquipStock = salayaEquipment.reduce((sum, e) => sum + Number(e.quantity || 0), 0);
        const klongyongEquipStock = klongyongEquipment.reduce((sum, e) => sum + Number(e.quantity || 0), 0);
        const totalEquipmentStock = salayaEquipStock + klongyongEquipStock;

        if (quickEquipment) quickEquipment.textContent = `${totalEquipmentStock} ‡∏ä‡∏¥‡πâ‡∏ô`;
        console.log(`[Dashboard] Equipment Stock: Salaya ${salayaEquipStock}, Klongyong ${klongyongEquipStock}, Total ${totalEquipmentStock}`);
    } catch (error) {
        console.error('[Dashboard] Error loading equipment stock:', error);
        if (quickEquipment) quickEquipment.textContent = `0 ‡∏ä‡∏¥‡πâ‡∏ô`;
    }

    // Get simcard count from ALL STORES (available status only)
    try {
        const salayaSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'salaya' });
        const klongyongSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'klongyong' });
        
        // Count only available simcards
        const salayaAvailable = salayaSimcards.filter(s => s.status === 'available').length;
        const klongyongAvailable = klongyongSimcards.filter(s => s.status === 'available').length;
        const totalAvailableSimcards = salayaAvailable + klongyongAvailable;

        if (quickSimcard) quickSimcard.textContent = `${totalAvailableSimcards} ‡πÉ‡∏ö`;
        console.log(`[Dashboard] Available Simcards: Salaya ${salayaAvailable}, Klongyong ${klongyongAvailable}, Total ${totalAvailableSimcards}`);
    } catch (error) {
        console.error('[Dashboard] Error loading simcard count:', error);
        if (quickSimcard) quickSimcard.textContent = `0 ‡πÉ‡∏ö`;
    }

    // Update income first (will update total income, expense, and profit later after calculating expenses)
    const totalIncome = document.getElementById('totalIncome');
    const totalExpense = document.getElementById('totalExpense');
    const netProfit = document.getElementById('netProfit');

    if (totalIncome) totalIncome.textContent = formatCurrency(totalIncomeAmount);

    // Update income breakdown
    const incomeNewDevicesEl = document.getElementById('incomeNewDevices');
    const incomeUsedDevicesEl = document.getElementById('incomeUsedDevices');
    const incomeInstallmentEl = document.getElementById('incomeInstallment');
    const incomePawnEl = document.getElementById('incomePawn');
    const incomeRepairEl = document.getElementById('incomeRepair');
    const incomePartsEl = document.getElementById('incomeParts');
    const incomeAccessoriesEl = document.getElementById('incomeAccessories');
    const incomeSimcardEl = document.getElementById('incomeSimcard');

    if (incomeNewDevicesEl) {
        incomeNewDevicesEl.textContent = formatCurrency(incomeNewDevices);
        console.log('üí∞ Income New Devices Card Updated (sold):', formatCurrency(incomeNewDevices));
    }
    if (incomeUsedDevicesEl) {
        incomeUsedDevicesEl.textContent = formatCurrency(incomeUsedDevices);
        console.log('üí∞ Income Used Devices Card Updated (sold):', formatCurrency(incomeUsedDevices));
    }
    if (incomeInstallmentEl) {
        incomeInstallmentEl.textContent = formatCurrency(incomeInstallment);
        console.log('üí≥ Income Installment Card Updated (commission only, filtered by down_payment_date):', formatCurrency(incomeInstallment));
    }
    if (incomePawnEl) {
        incomePawnEl.textContent = formatCurrency(incomePawn);
        console.log('üí∞ Income Pawn Card Updated:', formatCurrency(incomePawn));
    }
    if (incomeRepairEl) incomeRepairEl.textContent = formatCurrency(incomeRepair);
    if (incomePartsEl) {
        incomePartsEl.textContent = formatCurrency(incomeParts);
        console.log('üî© Income Parts Card Updated:', formatCurrency(incomeParts));
    }
    if (incomeAccessoriesEl) {
        incomeAccessoriesEl.textContent = formatCurrency(incomeAccessories);
        console.log('üì¶ Income Accessories Card Updated:', formatCurrency(incomeAccessories));
    }
    if (incomeSimcardEl) {
        incomeSimcardEl.textContent = formatCurrency(incomeSimcard);
        console.log('üî∑ Income Simcard Card Updated:', formatCurrency(incomeSimcard));
    }

    // Calculate expense breakdown
    // Expense from new devices (purchase price of devices SOLD in current month or date range)
    let expenseNewDevices = 0;
    if (newDevicesData.length > 0) {
        console.log('\nüì± [Expense New Devices Card] ========== START ==========');
        console.log('üì± Total New Devices:', newDevicesData.length);
        console.log('üì± Current Dashboard Filter:', currentDashboardFilter);
        
        let filteredNewDevices;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ sale_date)
            console.log('üì± [MODE: Date Range Filter]');
            console.log(`   Filter Start: ${currentDashboardFilter.startDate}`);
            console.log(`   Filter End: ${currentDashboardFilter.endDate}`);
            
            filteredNewDevices = newDevicesData
            .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
            .filter(d => {
                const saleDate = new Date(d.sale_date || d.saleDate);
                    const filterStart = new Date(currentDashboardFilter.startDate);
                    const filterEnd = new Date(currentDashboardFilter.endDate);
                    
                    const startMatch = saleDate >= filterStart;
                    const endMatch = saleDate <= filterEnd;
                    const match = startMatch && endMatch;
                    
                    console.log(`   ${match ? '‚úÖ' : '‚ùå'} ${d.brand} ${d.model}:`);
                    console.log(`      sale_date: ${d.sale_date || d.saleDate} => ${saleDate.toISOString().split('T')[0]}`);
                    console.log(`      filter: ${filterStart.toISOString().split('T')[0]} to ${filterEnd.toISOString().split('T')[0]}`);
                    console.log(`      purchase_price: ‡∏ø${(d.purchase_price || d.purchasePrice || 0).toLocaleString()}`);
                    
                    return match;
                });
        } else {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ sale_date)
            console.log('üì± [MODE: Current Month Filter]');
            console.log(`   Current Month/Year: ${currentMonthNum}/${currentYear}`);
            
            filteredNewDevices = newDevicesData
                .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
                .filter(d => {
                    const saleDate = new Date(d.sale_date || d.saleDate);
                    const year = saleDate.getFullYear().toString();
                    const month = (saleDate.getMonth() + 1).toString().padStart(2, '0');
                    const match = year === currentYear && month === currentMonthNum;
                    
                    console.log(`   ${match ? '‚úÖ' : '‚ùå'} ${d.brand} ${d.model}:`);
                    console.log(`      sale_date: ${d.sale_date || d.saleDate} => ${month}/${year}`);
                    console.log(`      purchase_price: ‡∏ø${(d.purchase_price || d.purchasePrice || 0).toLocaleString()}`);
                    
                    return match;
                });
        }
        
        // ‡∏£‡∏ß‡∏° purchase_price ‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ
        expenseNewDevices = filteredNewDevices.reduce((sum, d) => {
            const price = parseFloat(d.purchase_price || d.purchasePrice) || 0;
            console.log(`   üíµ Adding: ${d.brand} ${d.model} = ‡∏ø${price.toLocaleString()}`);
            return sum + price;
        }, 0);
        
        console.log('\nüì± [FINAL RESULT]');
        console.log(`   Filtered Count: ${filteredNewDevices.length} items (sold)`);
        console.log(`   Total Expense: ‡∏ø${expenseNewDevices.toLocaleString()}`);
        console.log('üì± [Expense New Devices Card] ========== END ==========\n');
    }

    // Expense from used devices (purchase price of devices SOLD in current month or date range)
    let expenseUsedDevices = 0;
    if (usedDevicesData.length > 0) {
        console.log('\nüì≤ [Expense Used Devices Card] ========== START ==========');
        console.log('üì≤ Total Used Devices:', usedDevicesData.length);
        console.log('üì≤ Current Dashboard Filter:', currentDashboardFilter);
        
        let filteredUsedDevices;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ sale_date)
            console.log('üì≤ [MODE: Date Range Filter]');
            console.log(`   Filter Start: ${currentDashboardFilter.startDate}`);
            console.log(`   Filter End: ${currentDashboardFilter.endDate}`);
            
            filteredUsedDevices = usedDevicesData
            .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
            .filter(d => {
                const saleDate = new Date(d.sale_date || d.saleDate);
                    const filterStart = new Date(currentDashboardFilter.startDate);
                    const filterEnd = new Date(currentDashboardFilter.endDate);
                    
                    const startMatch = saleDate >= filterStart;
                    const endMatch = saleDate <= filterEnd;
                    const match = startMatch && endMatch;
                    
                    console.log(`   ${match ? '‚úÖ' : '‚ùå'} ${d.brand} ${d.model}:`);
                    console.log(`      sale_date: ${d.sale_date || d.saleDate} => ${saleDate.toISOString().split('T')[0]}`);
                    console.log(`      filter: ${filterStart.toISOString().split('T')[0]} to ${filterEnd.toISOString().split('T')[0]}`);
                    console.log(`      purchase_price: ‡∏ø${(d.purchase_price || d.purchasePrice || 0).toLocaleString()}`);
                    
                    return match;
                });
        } else {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ sale_date)
            console.log('üì≤ [MODE: Current Month Filter]');
            console.log(`   Current Month/Year: ${currentMonthNum}/${currentYear}`);
            
            filteredUsedDevices = usedDevicesData
                .filter(d => d.status === 'sold' && (d.sale_date || d.saleDate))
                .filter(d => {
                    const saleDate = new Date(d.sale_date || d.saleDate);
                    const year = saleDate.getFullYear().toString();
                    const month = (saleDate.getMonth() + 1).toString().padStart(2, '0');
                    const match = year === currentYear && month === currentMonthNum;
                    
                    console.log(`   ${match ? '‚úÖ' : '‚ùå'} ${d.brand} ${d.model}:`);
                    console.log(`      sale_date: ${d.sale_date || d.saleDate} => ${month}/${year}`);
                    console.log(`      purchase_price: ‡∏ø${(d.purchase_price || d.purchasePrice || 0).toLocaleString()}`);
                    
                    return match;
                });
        }
        
        // ‡∏£‡∏ß‡∏° purchase_price ‡∏Ç‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ
        expenseUsedDevices = filteredUsedDevices.reduce((sum, d) => {
            const price = parseFloat(d.purchase_price || d.purchasePrice) || 0;
            console.log(`   üíµ Adding: ${d.brand} ${d.model} = ‡∏ø${price.toLocaleString()}`);
            return sum + price;
        }, 0);
        
        console.log('\nüì≤ [FINAL RESULT]');
        console.log(`   Filtered Count: ${filteredUsedDevices.length} items (sold)`);
        console.log(`   Total Expense: ‡∏ø${expenseUsedDevices.toLocaleString()}`);
        console.log('üì≤ [Expense Used Devices Card] ========== END ==========\n');
    }

    // Expense from installments - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Installment Dashboard (ALL STORES + filtered)
    let expenseInstallment = 0;
    if (window.allStoresInstallmentData) {
        expenseInstallment = window.allStoresInstallmentData.totalExpense || 0;
        console.log('‚úÖ Installment expense from dashboard data (ALL STORES + filtered):', {
            totalExpense: expenseInstallment,
            source: 'allStoresInstallmentData',
            filter: currentDashboardFilter
        });
    } else {
        console.warn('‚ö†Ô∏è allStoresInstallmentData not available, installment expense = 0');
    }

    // Expense from pawn - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Pawn Dashboard (ALL STORES)
    let expensePawn = 0;
    if (window.allStoresPawnData) {
        expensePawn = window.allStoresPawnData.totalExpense || 0;
        console.log('‚úÖ Pawn expense from dashboard data (ALL STORES):', {
            totalExpense: expensePawn,
            source: 'allStoresPawnData'
        });
    } else {
        console.warn('‚ö†Ô∏è allStoresPawnData not available, pawn expense = 0');
    }

    // Expense from repairs (accessory_cost + commission from completed repairs) - ALL STORES
    let expenseRepair = 0;
    try {
        const salayaRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'salaya' });
        const klongyongRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'klongyong' });
        const allRepairsForExpense = [...salayaRepairs, ...klongyongRepairs];
        
        console.log(`\nüí∏ [Expense Repair Card] ========== START ==========`);
        console.log(`üí∏ Total Repairs - Salaya: ${salayaRepairs.length}, Klongyong: ${klongyongRepairs.length}, All: ${allRepairsForExpense.length}`);
        console.log(`üí∏ Current Dashboard Filter:`, currentDashboardFilter);
        
        let completedRepairsForExpense;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ completed_date)
            console.log(`üí∏ [MODE: Date Range Filter]`);
            console.log(`   Filter Start: ${currentDashboardFilter.startDate}`);
            console.log(`   Filter End: ${currentDashboardFilter.endDate}`);
            
            completedRepairsForExpense = allRepairsForExpense.filter(r => {
                console.log(`\n   üìã Checking Repair ID ${r.id}:`);
                console.log(`      Brand/Model: ${r.brand} ${r.model}`);
                console.log(`      Status: ${r.status}`);
                console.log(`      Store: ${r.store}`);
                console.log(`      completed_date: ${r.completed_date}`);
                console.log(`      completedDate: ${r.completedDate}`);
                
                if (r.status !== 'completed' && r.status !== 'received') {
                    console.log(`      ‚ùå Status is not 'completed' or 'received'`);
                    return false;
                }
                
                const completedDate = r.completed_date || r.completedDate;
                if (!completedDate) {
                    console.log(`      ‚ùå No completed_date`);
                    return false;
                }
                
                const date = new Date(completedDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);
                
                console.log(`      Date Comparison:`);
                console.log(`         completed_date: ${date.toISOString().split('T')[0]}`);
                console.log(`         filter start:   ${filterStart.toISOString().split('T')[0]}`);
                console.log(`         filter end:     ${filterEnd.toISOString().split('T')[0]}`);
                
                const startMatch = date >= filterStart;
                const endMatch = date <= filterEnd;
                const isMatch = startMatch && endMatch;
                
                console.log(`         date >= start: ${startMatch}`);
                console.log(`         date <= end:   ${endMatch}`);
                console.log(`         ‚Üí ${isMatch ? '‚úÖ MATCH' : '‚ùå NO MATCH'}`);
                
                return isMatch;
            });
        } else {
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÉ‡∏ä‡πâ completed_date)
            console.log(`üí∏ [MODE: Current Month Filter]`);
            console.log(`   Current Year: ${currentYear}, Month: ${currentMonthNum}`);
            
            completedRepairsForExpense = allRepairsForExpense.filter(r => {
                if (r.status !== 'completed' && r.status !== 'received') return false;
                
                const completedDate = r.completed_date || r.completedDate;
                if (!completedDate) return false;
                
                const date = new Date(completedDate);
                const match = date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
                
                console.log(`   ${match ? '‚úÖ' : '‚ùå'} ID ${r.id}: ${completedDate} => ${date.getMonth() + 1}/${date.getFullYear()}`);
                
                return match;
            });
        }
        
        // ‡∏£‡∏ß‡∏° accessory_cost + commission
        console.log(`\nüí∏ [Calculating Expense from ${completedRepairsForExpense.length} items]:`);
        expenseRepair = completedRepairsForExpense.reduce((sum, r) => {
            const accessoryCost = parseFloat(r.accessory_cost || r.accessoryCost || 0);
            const commission = parseFloat(r.commission || 0);
            const total = accessoryCost + commission;
            console.log(`   üíµ Adding ID ${r.id} (${r.brand} ${r.model}):`);
            console.log(`      accessory_cost = ‡∏ø${accessoryCost.toLocaleString()}`);
            console.log(`      commission = ‡∏ø${commission.toLocaleString()}`);
            console.log(`      subtotal = ‡∏ø${total.toLocaleString()}`);
            console.log(`      running total = ‡∏ø${(sum + total).toLocaleString()}`);
            return sum + total;
        }, 0);
        
        console.log(`\nüí∏ [FINAL RESULT]`);
        console.log(`   Filtered Count: ${completedRepairsForExpense.length} items`);
        console.log(`   Total Expense: ‡∏ø${expenseRepair.toLocaleString()}`);
        console.log(`üí∏ [Expense Repair Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error fetching repairs for expense calculation:', error);
        expenseRepair = 0;
    }

    // Expense from accessories (parts/‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà) - ALL STORES
    let expenseParts = 0;
    try {
        const salayaCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: 'salaya' });
        const klongyongCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: 'klongyong' });
        const allCutAccessories = [...salayaCutAccessories, ...klongyongCutAccessories];

        console.log(`\nüí∏ [Expense Parts Card] ========== START ==========`);

        let filteredCutAccessories;

        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            filteredCutAccessories = allCutAccessories.filter(a => {
                const cutDate = a.cut_date || a.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);

                return date >= filterStart && date <= filterEnd;
            });
        } else {
            filteredCutAccessories = allCutAccessories.filter(a => {
                const cutDate = a.cut_date || a.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            });
        }

        expenseParts = filteredCutAccessories.reduce((sum, a) => {
            const costPrice = parseFloat(a.cost_price || a.costPrice) || 0;
            const cutQty = parseFloat(a.cut_quantity || a.cutQuantity) || 0;
            return sum + (costPrice * cutQty);
        }, 0);

        console.log(`üí∏ [FINAL RESULT] Total Expense: ‡∏ø${expenseParts.toLocaleString()}`);
        console.log(`üí∏ [Expense Parts Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error loading accessories expense:', error);
        expenseParts = 0;
    }

    // Expense from equipment (‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå) - ALL STORES
    let expenseAccessories = 0;
    try {
        const salayaEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'salaya' });
        const klongyongEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'klongyong' });
        const allEquipment = [...salayaEquipment, ...klongyongEquipment];

        console.log(`\nüí∏ [Expense Accessories Card] ========== START ==========`);

        let filteredEquipment;

        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            filteredEquipment = allEquipment.filter(e => {
                const cutDate = e.cut_date || e.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);

                return date >= filterStart && date <= filterEnd;
            });
        } else {
            filteredEquipment = allEquipment.filter(e => {
                const cutDate = e.cut_date || e.cutDate;
                if (!cutDate) return false;

                const date = new Date(cutDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            });
        }

        expenseAccessories = filteredEquipment.reduce((sum, e) => {
            const costPrice = parseFloat(e.cost_price || e.costPrice) || 0;
            const cutQty = parseFloat(e.cut_quantity || e.cutQuantity) || 0;
            return sum + (costPrice * cutQty);
        }, 0);

        console.log(`üí∏ [FINAL RESULT] Total Expense: ‡∏ø${expenseAccessories.toLocaleString()}`);
        console.log(`üí∏ [Expense Accessories Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error loading equipment expense:', error);
        expenseAccessories = 0;
    }

    // Expense from simcard (‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î) - ALL STORES
    let expenseSimcard = 0;
    try {
        const salayaSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'salaya' });
        const klongyongSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'klongyong' });
        const allSimcards = [...salayaSimcards, ...klongyongSimcards];

        console.log(`\nüí∏ [Expense Simcard Card] ========== START ==========`);
        console.log(`üí∏ Total Simcards - Salaya: ${salayaSimcards.length}, Klongyong: ${klongyongSimcards.length}, All: ${allSimcards.length}`);

        let filteredSimcards;

        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            filteredSimcards = allSimcards.filter(s => {
                if (s.status !== 'sold') return false;
                const soldDate = s.sold_date || s.soldDate;
                if (!soldDate) return false;

                const date = new Date(soldDate);
                const filterStart = new Date(currentDashboardFilter.startDate);
                const filterEnd = new Date(currentDashboardFilter.endDate);

                return date >= filterStart && date <= filterEnd;
            });
        } else {
            filteredSimcards = allSimcards.filter(s => {
                if (s.status !== 'sold') return false;
                const soldDate = s.sold_date || s.soldDate;
                if (!soldDate) return false;

                const date = new Date(soldDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            });
        }

        expenseSimcard = filteredSimcards.reduce((sum, s) => {
            const costPrice = parseFloat(s.cost_price || s.costPrice) || 0;
            return sum + costPrice;
        }, 0);

        console.log(`üí∏ [FINAL RESULT] Total Expense: ‡∏ø${expenseSimcard.toLocaleString()}`);
        console.log(`üí∏ [Expense Simcard Card] ========== END ==========\n`);
    } catch (error) {
        console.error('Error loading simcard expense:', error);
        expenseSimcard = 0;
    }

    // Calculate total expense (‡πÄ‡∏û‡∏¥‡πà‡∏° expenseRepair, expenseParts, expenseAccessories, expenseSimcard ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ)
    const totalExpenseAmount = expenseNewDevices + expenseUsedDevices + expenseInstallment + expensePawn + expenseRepair + expenseParts + expenseAccessories + expenseSimcard;
    
    // Log expense breakdown by menu for verification
    console.log('üìä [Dashboard Cards Verification] Expense Breakdown by Menu:', {
        newDevices: formatCurrency(expenseNewDevices),
        usedDevices: formatCurrency(expenseUsedDevices),
        installment: formatCurrency(expenseInstallment),
        pawn: formatCurrency(expensePawn),
        repair: formatCurrency(expenseRepair),
        parts: formatCurrency(expenseParts),
        accessories: formatCurrency(expenseAccessories),
        simcard: formatCurrency(expenseSimcard),
        total: formatCurrency(totalExpenseAmount)
    });

    // Update expense breakdown
    const expenseNewDevicesEl = document.getElementById('expenseNewDevices');
    const expenseUsedDevicesEl = document.getElementById('expenseUsedDevices');
    const expenseInstallmentEl = document.getElementById('expenseInstallment');
    const expensePawnEl = document.getElementById('expensePawn');
    const expenseRepairEl = document.getElementById('expenseRepair');
    const expensePartsEl = document.getElementById('expenseParts');
    const expenseAccessoriesEl = document.getElementById('expenseAccessories');
    const expenseSimcardEl = document.getElementById('expenseSimcard');

    if (expenseNewDevicesEl) {
        expenseNewDevicesEl.textContent = formatCurrency(expenseNewDevices);
        console.log('üì± Expense New Devices Card Updated (sold):', formatCurrency(expenseNewDevices));
    }
    if (expenseUsedDevicesEl) {
        expenseUsedDevicesEl.textContent = formatCurrency(expenseUsedDevices);
        console.log('üì≤ Expense Used Devices Card Updated (sold):', formatCurrency(expenseUsedDevices));
    }
    if (expenseInstallmentEl) {
        expenseInstallmentEl.textContent = formatCurrency(expenseInstallment);
        console.log('üí≥ Expense Installment Card Updated (filtered by down_payment_date):', formatCurrency(expenseInstallment));
    }
    if (expensePawnEl) {
        expensePawnEl.textContent = formatCurrency(expensePawn);
        console.log('üì§ Expense Pawn Card Updated:', formatCurrency(expensePawn));
    }
    if (expenseRepairEl) {
        expenseRepairEl.textContent = formatCurrency(expenseRepair);
        console.log('üîß Expense Repair Card Updated (accessory + commission):', formatCurrency(expenseRepair));
    }
    if (expensePartsEl) {
        expensePartsEl.textContent = formatCurrency(expenseParts);
        console.log('üî© Expense Parts Card Updated:', formatCurrency(expenseParts));
    }
    if (expenseAccessoriesEl) {
        expenseAccessoriesEl.textContent = formatCurrency(expenseAccessories);
        console.log('üì¶ Expense Accessories Card Updated:', formatCurrency(expenseAccessories));
    }
    if (expenseSimcardEl) {
        expenseSimcardEl.textContent = formatCurrency(expenseSimcard);
        console.log('üî∑ Expense Simcard Card Updated:', formatCurrency(expenseSimcard));
    }

    // Calculate profit breakdown
    const profitNewDevices = incomeNewDevices - expenseNewDevices;
    const profitUsedDevices = incomeUsedDevices - expenseUsedDevices;
    const profitInstallment = incomeInstallment - expenseInstallment;
    const profitPawn = incomePawn - expensePawn; // Income (interest + returned) - Expense (pawn amount)
    const profitRepair = incomeRepair - expenseRepair; // Income (repair cost) - Expense (accessory cost + commission)
    const profitParts = incomeParts - expenseParts; // Income (parts sold) - Expense (parts cost)
    const profitAccessories = incomeAccessories - expenseAccessories; // Income (equipment sold) - Expense (equipment cost)
    const profitSimcard = incomeSimcard - expenseSimcard; // Income (simcard sold) - Expense (simcard cost)

    // Verify installment profit calculation
    if (window.allStoresInstallmentData) {
        const calculatedProfit = profitInstallment;
        const dashboardProfit = window.allStoresInstallmentData.totalProfit || 0;
        console.log('üí∞ Installment Profit Verification (ALL STORES):', {
            calculated: calculatedProfit,
            fromDashboard: dashboardProfit,
            match: Math.abs(calculatedProfit - dashboardProfit) < 0.01
        });
    }
    
    // Verify pawn profit calculation
    if (window.allStoresPawnData) {
        const calculatedProfit = profitPawn;
        const dashboardProfit = window.allStoresPawnData.totalProfit || 0;
        console.log('üí∞ Pawn Profit Verification (ALL STORES):', {
            calculated: calculatedProfit,
            fromDashboard: dashboardProfit,
            match: Math.abs(calculatedProfit - dashboardProfit) < 0.01
        });
    }

    // Update profit breakdown
    const profitNewDevicesEl = document.getElementById('profitNewDevices');
    const profitUsedDevicesEl = document.getElementById('profitUsedDevices');
    const profitInstallmentEl = document.getElementById('profitInstallment');
    const profitPawnEl = document.getElementById('profitPawn');
    const profitRepairEl = document.getElementById('profitRepair');
    const profitPartsEl = document.getElementById('profitParts');
    const profitAccessoriesEl = document.getElementById('profitAccessories');
    const profitSimcardEl = document.getElementById('profitSimcard');

    if (profitNewDevicesEl) {
        profitNewDevicesEl.textContent = formatCurrency(profitNewDevices);
        profitNewDevicesEl.parentElement.parentElement.classList.toggle('negative', profitNewDevices < 0);
    }
    if (profitUsedDevicesEl) {
        profitUsedDevicesEl.textContent = formatCurrency(profitUsedDevices);
        profitUsedDevicesEl.parentElement.parentElement.classList.toggle('negative', profitUsedDevices < 0);
    }
    if (profitInstallmentEl) {
        profitInstallmentEl.textContent = formatCurrency(profitInstallment);
        profitInstallmentEl.parentElement.parentElement.classList.toggle('negative', profitInstallment < 0);
    }
    if (profitPawnEl) {
        profitPawnEl.textContent = formatCurrency(profitPawn);
        profitPawnEl.parentElement.parentElement.classList.toggle('negative', profitPawn < 0);
        console.log('üìä Profit Pawn Card Updated:', formatCurrency(profitPawn), `(Income: ${formatCurrency(incomePawn)} - Expense: ${formatCurrency(expensePawn)})`);
    }
    if (profitRepairEl) {
        profitRepairEl.textContent = formatCurrency(profitRepair);
        profitRepairEl.parentElement.parentElement.classList.toggle('negative', profitRepair < 0);
        console.log('üîß Profit Repair Card Updated (ALL STORES):', formatCurrency(profitRepair), `(Income: ${formatCurrency(incomeRepair)} - Expense: ${formatCurrency(expenseRepair)})`);
    }
    if (profitPartsEl) {
        profitPartsEl.textContent = formatCurrency(profitParts);
        profitPartsEl.parentElement.parentElement.classList.toggle('negative', profitParts < 0);
        console.log('üî© Profit Parts Card Updated:', formatCurrency(profitParts), `(Income: ${formatCurrency(incomeParts)} - Expense: ${formatCurrency(expenseParts)})`);
    }
    if (profitAccessoriesEl) {
        profitAccessoriesEl.textContent = formatCurrency(profitAccessories);
        profitAccessoriesEl.parentElement.parentElement.classList.toggle('negative', profitAccessories < 0);
        console.log('üì¶ Profit Accessories Card Updated:', formatCurrency(profitAccessories), `(Income: ${formatCurrency(incomeAccessories)} - Expense: ${formatCurrency(expenseAccessories)})`);
    }
    if (profitSimcardEl) {
        profitSimcardEl.textContent = formatCurrency(profitSimcard);
        profitSimcardEl.parentElement.parentElement.classList.toggle('negative', profitSimcard < 0);
        console.log('üî∑ Profit Simcard Card Updated:', formatCurrency(profitSimcard), `(Income: ${formatCurrency(incomeSimcard)} - Expense: ${formatCurrency(expenseSimcard)})`);
    }

    // Update Main Dashboard Cards (‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢, ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö, ‡∏£‡∏≤‡∏¢‡πÑ‡∏î‡πâ)
    if (statTotalExpense) {
        statTotalExpense.textContent = formatCurrency(totalExpenseAmount);
    }
    
    if (statTotalIncome) {
        statTotalIncome.textContent = formatCurrency(totalIncomeAmount);
    }
    
    const profit = totalIncomeAmount - totalExpenseAmount;
    if (statProfit) {
        statProfit.textContent = formatCurrency(profit);
    }

    // Log profit breakdown by menu for verification
    console.log('üìä [Dashboard Cards Verification] Profit Breakdown by Menu:', {
        newDevices: formatCurrency(profitNewDevices),
        usedDevices: formatCurrency(profitUsedDevices),
        installment: formatCurrency(profitInstallment),
        pawn: formatCurrency(profitPawn),
        repair: formatCurrency(profitRepair),
        parts: formatCurrency(profitParts),
        accessories: formatCurrency(profitAccessories),
        simcard: formatCurrency(profitSimcard),
        total: formatCurrency(profitNewDevices + profitUsedDevices + profitInstallment + profitPawn + profitRepair + profitParts + profitAccessories + profitSimcard)
    });

    // Verify card totals match sum of all menu items
    const calculatedIncomeTotal = parseFloat(incomeNewDevices || 0) +
                                  parseFloat(incomeUsedDevices || 0) +
                                  parseFloat(incomeInstallment || 0) +
                                  parseFloat(incomePawn || 0) +
                                  parseFloat(incomeRepair || 0) +
                                  parseFloat(incomeParts || 0) +
                                  parseFloat(incomeAccessories || 0) +
                                  parseFloat(incomeSimcard || 0);

    const calculatedExpenseTotal = expenseNewDevices + expenseUsedDevices + expenseInstallment + expensePawn + expenseRepair + expenseParts + expenseAccessories + expenseSimcard;

    const incomeDiff = Math.abs(calculatedIncomeTotal - totalIncomeAmount);
    const expenseDiff = Math.abs(calculatedExpenseTotal - totalExpenseAmount);
    const incomeMatch = incomeDiff < 0.01;
    const expenseMatch = expenseDiff < 0.01;

    const calculatedProfitTotal = profitNewDevices + profitUsedDevices + profitInstallment + profitPawn + profitRepair + profitParts + profitAccessories + profitSimcard;
    const profitDiff = Math.abs(calculatedProfitTotal - profit);
    const profitMatch = profitDiff < 0.01;
    
    console.log('üîç [Dashboard Cards Verification] Card Totals vs Sum of Menus:', {
        incomeCard: formatCurrency(totalIncomeAmount),
        incomeSumOfMenus: formatCurrency(calculatedIncomeTotal),
        incomeMatch: incomeMatch ? '‚úÖ MATCH' : `‚ùå DIFFERENCE: ${formatCurrency(incomeDiff)}`,
        expenseCard: formatCurrency(totalExpenseAmount),
        expenseSumOfMenus: formatCurrency(calculatedExpenseTotal),
        expenseMatch: expenseMatch ? '‚úÖ MATCH' : `‚ùå DIFFERENCE: ${formatCurrency(expenseDiff)}`,
        profitCard: formatCurrency(profit),
        profitSumOfMenus: formatCurrency(calculatedProfitTotal),
        profitMatch: profitMatch ? '‚úÖ MATCH' : `‚ùå DIFFERENCE: ${formatCurrency(profitDiff)}`
    });
    
    if (!incomeMatch || !expenseMatch || !profitMatch) {
        console.warn('‚ö†Ô∏è [Dashboard Cards Verification] MISMATCH DETECTED!', {
            incomeDiff: formatCurrency(incomeDiff),
            expenseDiff: formatCurrency(expenseDiff),
            profitDiff: formatCurrency(profitDiff),
            message: 'Please check calculation logic - card totals should equal sum of all menu items'
        });
    }

    // Update old total cards (for other pages)
    if (totalExpense) {
        totalExpense.textContent = formatCurrency(totalExpenseAmount);
        console.log('Total expense updated:', totalExpenseAmount);
    }

    // Recalculate net profit with real data
    console.log('Profit calculation:', {
        income: totalIncomeAmount,
        expense: totalExpenseAmount,
        profit: profit
    });
    
    if (netProfit) {
        netProfit.textContent = formatCurrency(profit);

        // Change color based on profit/loss
        netProfit.classList.remove('income', 'expense', 'profit');
        if (profit > 0) {
            netProfit.classList.add('profit');
        } else if (profit < 0) {
            netProfit.classList.add('expense');
        }
    }

    // Animate numbers
    animateStats();
    
    // Update dashboard charts
    updateDashboardCharts({
        newDevicesData,
        usedDevicesData,
        incomeNewDevices,
        incomeUsedDevices,
        incomeInstallment,
        incomePawn,
        incomeRepair,
        expenseNewDevices,
        expenseUsedDevices,
        expenseInstallment,
        expensePawn,
        profitNewDevices,
        profitUsedDevices,
        profitInstallment,
        profitPawn,
        profitRepair,
        totalIncome: totalIncomeAmount,
        totalExpense: totalExpenseAmount
    });
}

// Global chart instances
let salesByStoreChart = null;
let incomeByTypeChart = null;
let expenseByTypeChart = null;
let profitByTypeChart = null;
let monthlyIncomeExpenseChart = null;

// Update dashboard charts
async function updateDashboardCharts(data) {
    try {
        // Get current month/year for filtering
        const currentYear = currentMonth.substring(0, 4);
        const currentMonthNum = currentMonth.substring(5, 7);
        
        // Calculate sales by store (count of devices sold in current month)
        const salayaSales = (data.newDevicesData || [])
            .filter(d => {
                if (d.store !== 'salaya' || d.status !== 'sold') return false;
                const saleDate = d.sale_date || d.saleDate;
                if (!saleDate) return false;
                const date = new Date(saleDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            }).length +
            (data.usedDevicesData || [])
            .filter(d => {
                if (d.store !== 'salaya' || d.status !== 'sold') return false;
                const saleDate = d.sale_date || d.saleDate;
                if (!saleDate) return false;
                const date = new Date(saleDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            }).length;
            
        const klongyongSales = (data.newDevicesData || [])
            .filter(d => {
                if (d.store !== 'klongyong' || d.status !== 'sold') return false;
                const saleDate = d.sale_date || d.saleDate;
                if (!saleDate) return false;
                const date = new Date(saleDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            }).length +
            (data.usedDevicesData || [])
            .filter(d => {
                if (d.store !== 'klongyong' || d.status !== 'sold') return false;
                const saleDate = d.sale_date || d.saleDate;
                if (!saleDate) return false;
                const date = new Date(saleDate);
                return date.getFullYear().toString() === currentYear &&
                       (date.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            }).length;
        
        console.log('üìä ‡∏Å‡∏£‡∏≤‡∏ü‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô):', {
            month: `${currentYear}-${currentMonthNum}`,
            salaya: salayaSales,
            klongyong: klongyongSales,
            total: salayaSales + klongyongSales
        });
        
        // Chart 1: Sales by Store
        const salesCtx = document.getElementById('salesByStoreChart');
        if (salesCtx) {
            // Destroy existing chart
            if (salesByStoreChart) {
                salesByStoreChart.destroy();
            }
            
            salesByStoreChart = new Chart(salesCtx, {
                type: 'pie',
                data: {
                    labels: ['‡∏£‡πâ‡∏≤‡∏ô‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤', '‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á'],
                    datasets: [{
                        data: [salayaSales, klongyongSales],
                        backgroundColor: [
                            'rgba(155, 135, 245, 0.8)',  // ‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á‡∏≠‡πà‡∏≠‡∏ô
                            'rgba(129, 212, 250, 0.8)'   // ‡∏™‡∏µ‡∏ü‡πâ‡∏≤‡∏≠‡πà‡∏≠‡∏ô
                        ],
                        borderColor: [
                            'rgba(155, 135, 245, 1)',
                            'rgba(129, 212, 250, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Custom legend
            const legend = document.getElementById('salesByStoreLegend');
            if (legend) {
                const total = salayaSales + klongyongSales;
                legend.innerHTML = `
                    <div class="chart-legend-item">
                        <div class="chart-legend-label">
                            <div class="chart-legend-color" style="background: rgba(155, 135, 245, 0.8);"></div>
                            <span>‡∏£‡πâ‡∏≤‡∏ô‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤</span>
                        </div>
                        <div class="chart-legend-value">${salayaSales} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (${((salayaSales/total)*100).toFixed(1)}%)</div>
                    </div>
                    <div class="chart-legend-item">
                        <div class="chart-legend-label">
                            <div class="chart-legend-color" style="background: rgba(129, 212, 250, 0.8);"></div>
                            <span>‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á</span>
                        </div>
                        <div class="chart-legend-value">${klongyongSales} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (${((klongyongSales/total)*100).toFixed(1)}%)</div>
                    </div>
                `;
            }
        }
        
        // Chart 2: Income by Type
        const incomeCtx = document.getElementById('incomeByTypeChart');
        if (incomeCtx) {
            // Destroy existing chart
            if (incomeByTypeChart) {
                incomeByTypeChart.destroy();
            }
            
            const incomeData = [
                { label: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà', value: data.incomeNewDevices || 0, color: 'rgba(102, 187, 106, 0.8)' },
                { label: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á', value: data.incomeUsedDevices || 0, color: 'rgba(66, 165, 245, 0.8)' },
                { label: '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô', value: data.incomeInstallment || 0, color: 'rgba(255, 167, 38, 0.8)' },
                { label: '‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å', value: data.incomePawn || 0, color: 'rgba(239, 83, 80, 0.8)' },
                { label: '‡∏ã‡πà‡∏≠‡∏°', value: data.incomeRepair || 0, color: 'rgba(171, 71, 188, 0.8)' }
            ].filter(item => item.value > 0);
            
            incomeByTypeChart = new Chart(incomeCtx, {
                type: 'pie',
                data: {
                    labels: incomeData.map(d => d.label),
                    datasets: [{
                        data: incomeData.map(d => d.value),
                        backgroundColor: incomeData.map(d => d.color),
                        borderColor: incomeData.map(d => d.color.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${formatCurrency(value)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Custom legend
            const legend = document.getElementById('incomeByTypeLegend');
            if (legend) {
                const total = incomeData.reduce((sum, d) => sum + d.value, 0);
                legend.innerHTML = incomeData.map(item => `
                    <div class="chart-legend-item">
                        <div class="chart-legend-label">
                            <div class="chart-legend-color" style="background: ${item.color};"></div>
                            <span>${item.label}</span>
                        </div>
                        <div class="chart-legend-value">${formatCurrency(item.value)} (${((item.value/total)*100).toFixed(1)}%)</div>
                    </div>
                `).join('');
            }
        }
        
        // Chart 3: Expense by Type
        const expenseCtx = document.getElementById('expenseByTypeChart');
        if (expenseCtx) {
            // Destroy existing chart
            if (expenseByTypeChart) {
                expenseByTypeChart.destroy();
            }
            
            // Use real expense data from updateDashboard
            const expenseData = [
                { label: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà', value: data.expenseNewDevices || 0, color: 'rgba(102, 187, 106, 0.8)' },
                { label: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á', value: data.expenseUsedDevices || 0, color: 'rgba(66, 165, 245, 0.8)' },
                { label: '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô', value: data.expenseInstallment || 0, color: 'rgba(255, 167, 38, 0.8)' },
                { label: '‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å', value: data.expensePawn || 0, color: 'rgba(239, 83, 80, 0.8)' }
            ].filter(item => item.value > 0);
            
            console.log('üìä ‡∏Å‡∏£‡∏≤‡∏ü‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢:', expenseData);
            
            if (expenseData.length > 0) {
                expenseByTypeChart = new Chart(expenseCtx, {
                    type: 'pie',
                    data: {
                        labels: expenseData.map(d => d.label),
                        datasets: [{
                            data: expenseData.map(d => d.value),
                            backgroundColor: expenseData.map(d => d.color),
                            borderColor: expenseData.map(d => d.color.replace('0.8', '1')),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${label}: ${formatCurrency(value)} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Custom legend
                const expenseLegend = document.getElementById('expenseByTypeLegend');
                if (expenseLegend) {
                    const total = expenseData.reduce((sum, d) => sum + d.value, 0);
                    expenseLegend.innerHTML = expenseData.map(item => `
                        <div class="chart-legend-item">
                            <div class="chart-legend-label">
                                <div class="chart-legend-color" style="background: ${item.color};"></div>
                                <span>${item.label}</span>
                            </div>
                            <div class="chart-legend-value">${formatCurrency(item.value)} (${((item.value/total)*100).toFixed(1)}%)</div>
                        </div>
                    `).join('');
                }
            } else {
                // Show "no data" message
                const expenseLegend = document.getElementById('expenseByTypeLegend');
                if (expenseLegend) {
                    expenseLegend.innerHTML = '<div style="text-align: center; color: #999;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
                }
            }
        }
        
        // Chart 4: Profit by Type
        const profitCtx = document.getElementById('profitByTypeChart');
        if (profitCtx) {
            // Destroy existing chart
            if (profitByTypeChart) {
                profitByTypeChart.destroy();
            }
            
            // Use real profit data from updateDashboard (income - expense for each type)
            const profitData = [
                { label: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà', value: data.profitNewDevices || 0, color: 'rgba(102, 187, 106, 0.8)' },
                { label: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á', value: data.profitUsedDevices || 0, color: 'rgba(66, 165, 245, 0.8)' },
                { label: '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô', value: data.profitInstallment || 0, color: 'rgba(255, 167, 38, 0.8)' },
                { label: '‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å', value: data.profitPawn || 0, color: 'rgba(239, 83, 80, 0.8)' },
                { label: '‡∏ã‡πà‡∏≠‡∏°', value: data.profitRepair || 0, color: 'rgba(171, 71, 188, 0.8)' }
            ].filter(item => item.value > 0);
            
            console.log('üìä ‡∏Å‡∏£‡∏≤‡∏ü‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Å‡∏≥‡πÑ‡∏£:', profitData);
            
            if (profitData.length > 0) {
                profitByTypeChart = new Chart(profitCtx, {
                    type: 'pie',
                    data: {
                        labels: profitData.map(d => d.label),
                        datasets: [{
                            data: profitData.map(d => d.value),
                            backgroundColor: profitData.map(d => d.color),
                            borderColor: profitData.map(d => d.color.replace('0.8', '1')),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        return `${label}: ${formatCurrency(value)} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Custom legend
                const profitLegend = document.getElementById('profitByTypeLegend');
                if (profitLegend) {
                    const total = profitData.reduce((sum, d) => sum + d.value, 0);
                    profitLegend.innerHTML = profitData.map(item => `
                        <div class="chart-legend-item">
                            <div class="chart-legend-label">
                                <div class="chart-legend-color" style="background: ${item.color};"></div>
                                <span>${item.label}</span>
                            </div>
                            <div class="chart-legend-value">${formatCurrency(item.value)} (${((item.value/total)*100).toFixed(1)}%)</div>
                        </div>
                    `).join('');
                }
            } else {
                // Show "no data" message
                const profitLegend = document.getElementById('profitByTypeLegend');
                if (profitLegend) {
                    profitLegend.innerHTML = '<div style="text-align: center; color: #999;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
                }
            }
        }
        
        // Update Monthly Income-Expense Chart
        await updateMonthlyIncomeExpenseChart(data);
        
    } catch (error) {
        console.error('Error updating dashboard charts:', error);
    }
}

// Helper function to get Thai month name
function getThaiMonthName(monthNumber) {
    const thaiMonths = [
        '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
        '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'
    ];
    return thaiMonths[monthNumber - 1] || '';
}

// Update Monthly Income-Expense Chart
async function updateMonthlyIncomeExpenseChart(data) {
    try {
        const monthlyChartCtx = document.getElementById('monthlyIncomeExpenseChart');
        if (!monthlyChartCtx) return;
        
        // Destroy existing chart
        if (monthlyIncomeExpenseChart) {
            monthlyIncomeExpenseChart.destroy();
        }
        
        // Get date range from currentDashboardFilter
        const currentYear = currentMonth.substring(0, 4);
        const currentMonthNum = parseInt(currentMonth.substring(5, 7));
        
        // Update chart title based on filter
        const chartTitleElement = document.getElementById('monthlyIncomeExpenseChartTitle');
        let displayMonth;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // Use month from filter
            const filterDate = new Date(currentDashboardFilter.startDate || currentDashboardFilter.endDate);
            displayMonth = getThaiMonthName(filterDate.getMonth() + 1);
        } else {
            // Use current month
            displayMonth = getThaiMonthName(currentMonthNum);
        }
        
        if (chartTitleElement && displayMonth) {
            chartTitleElement.textContent = `‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö-‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ ${displayMonth}`;
        }
        
        let startDate, endDate, daysInMonth, labels;
        const isSingleDay = currentDashboardFilter.startDate && 
                           currentDashboardFilter.endDate && 
                           currentDashboardFilter.startDate === currentDashboardFilter.endDate;
        
        if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
            // Use date range filter
            startDate = new Date(currentDashboardFilter.startDate || `${currentYear}-${String(currentMonthNum).padStart(2, '0')}-01`);
            endDate = new Date(currentDashboardFilter.endDate || new Date(currentYear, currentMonthNum, 0));
            
            // Normalize dates - startDate to start of day, endDate to end of day for proper comparison
            startDate.setHours(0, 0, 0, 0);
            // For endDate, set to end of day to include the entire day (like updateDashboard does with date range)
            endDate.setHours(23, 59, 59, 999);
            
            if (isSingleDay) {
                // Single day selected - show only that day
                daysInMonth = 1;
                const selectedDate = new Date(startDate);
                labels = [`${selectedDate.getDate()}/${selectedDate.getMonth() + 1}`];
            } else {
                // Calculate days between dates
                const diffTime = Math.abs(endDate - startDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
                daysInMonth = diffDays;
                
                // Create labels for date range
                labels = [];
                const currentDate = new Date(startDate);
                for (let i = 0; i < daysInMonth; i++) {
                    labels.push(`${currentDate.getDate()}`);
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            }
        } else {
            // Use current month
            daysInMonth = new Date(currentYear, currentMonthNum, 0).getDate();
            labels = Array.from({ length: daysInMonth }, (_, i) => `${i + 1}`);
            startDate = new Date(currentYear, currentMonthNum - 1, 1);
            endDate = new Date(currentYear, currentMonthNum, 0);
            startDate.setHours(0, 0, 0, 0);
            endDate.setHours(23, 59, 59, 999);
        }
        
        // Initialize daily data
        const dailyIncome = new Array(daysInMonth).fill(0);
        const dailyExpense = new Array(daysInMonth).fill(0);
        
        // Debug: Log date range and data availability
        console.log('üìä [Chart] Date Range:', {
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0],
            daysInMonth,
            isSingleDay,
            currentYear,
            currentMonthNum,
            hasNewDevicesData: !!(data.newDevicesData && data.newDevicesData.length > 0),
            hasUsedDevicesData: !!(data.usedDevicesData && data.usedDevicesData.length > 0),
            newDevicesCount: data.newDevicesData?.length || 0,
            usedDevicesCount: data.usedDevicesData?.length || 0
        });
        
        // If single day selected, use dashboard totals directly to ensure accuracy
        if (isSingleDay && data.totalIncome !== undefined && data.totalExpense !== undefined) {
            dailyIncome[0] = data.totalIncome || 0;
            dailyExpense[0] = data.totalExpense || 0;
            console.log('üìä [Chart] Single day mode - using dashboard totals:', {
                income: data.totalIncome,
                expense: data.totalExpense
            });
        } else {
            // Calculate daily data from raw data
            // Helper function to normalize date for day index calculation (set to start of day)
            const normalizeDateForIndex = (date) => {
                if (!date) return null;
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                return d;
            };
            
            // Helper function to check if date matches a specific day (for daily calculation)
            const isDateOnDay = (date, targetDate) => {
                if (!date || !targetDate) return false;
                const d = new Date(date);
                const target = new Date(targetDate);
                // Compare year, month, and day only (ignore time)
                return d.getFullYear() === target.getFullYear() &&
                       d.getMonth() === target.getMonth() &&
                       d.getDate() === target.getDate();
            };
            
            // Helper function to check if date is in range (match updateDashboard logic exactly)
            // IMPORTANT: This matches updateDashboard() which compares dates directly without normalizing
            const isDateInRange = (date) => {
                if (!date) return false;
                const d = new Date(date);
                // For date range filter, compare dates directly (like updateDashboard does - no normalization)
                if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
                    const filterStart = new Date(currentDashboardFilter.startDate);
                    const filterEnd = new Date(currentDashboardFilter.endDate);
                    // Match updateDashboard() logic: direct comparison without setHours
                    return d >= filterStart && d <= filterEnd;
                } else {
                    // For month filter, compare year and month only
                    const dateYear = d.getFullYear().toString();
                    const dateMonth = String(d.getMonth() + 1).padStart(2, '0');
                    const match = dateYear === currentYear && dateMonth === String(currentMonthNum).padStart(2, '0');
                    return match;
                }
            };
        
        // Helper function to get day index
        const getDayIndex = (date) => {
            if (!date) return -1;
            const d = normalizeDateForIndex(date);
            if (currentDashboardFilter.startDate || currentDashboardFilter.endDate) {
                // For date range, calculate days from start
                const start = normalizeDateForIndex(startDate);
                const diffTime = d - start;
                return Math.floor(diffTime / (1000 * 60 * 60 * 24));
            } else {
                // For month, use day of month
                return d.getDate() - 1;
            }
        };
        
        // Process new devices (sold) - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: sale_price, ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: purchase_price
        // Use same logic as updateDashboard(): filter by status='sold' and sale_date
        let newDevicesProcessed = 0;
        (data.newDevicesData || []).forEach(device => {
            if (device.status === 'sold' && (device.sale_date || device.saleDate)) {
                const saleDate = device.sale_date || device.saleDate;
                // Check if sale_date is in the current month/range
                if (isDateInRange(saleDate)) {
                    // Find which day this sale_date belongs to
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(saleDate, currentDayDate)) {
                            const salePrice = parseFloat(device.sale_price || device.salePrice) || 0;
                            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice) || 0;
                            dailyIncome[dayIdx] += salePrice;
                            dailyExpense[dayIdx] += purchasePrice;
                            newDevicesProcessed++;
                            break; // Found the day, move to next device
                        }
                    }
                }
            }
        });
        console.log(`üìä [Chart] Processed ${newDevicesProcessed} new devices`);
        
        // Process used devices (sold) - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: sale_price, ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: purchase_price
        // Use same logic as updateDashboard(): filter by status='sold' and sale_date
        let usedDevicesProcessed = 0;
        (data.usedDevicesData || []).forEach(device => {
            if (device.status === 'sold' && (device.sale_date || device.saleDate)) {
                const saleDate = device.sale_date || device.saleDate;
                // Check if sale_date is in the current month/range
                if (isDateInRange(saleDate)) {
                    // Find which day this sale_date belongs to
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(saleDate, currentDayDate)) {
                            const salePrice = parseFloat(device.sale_price || device.salePrice) || 0;
                            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice) || 0;
                            dailyIncome[dayIdx] += salePrice;
                            dailyExpense[dayIdx] += purchasePrice;
                            usedDevicesProcessed++;
                            break; // Found the day, move to next device
                        }
                    }
                }
            }
        });
        console.log(`üìä [Chart] Processed ${usedDevicesProcessed} used devices`);
        
        // Process installments - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: commission, ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: down_payment
        try {
            const allInstallments = await API.get(API_ENDPOINTS.installments);
            allInstallments.forEach(installment => {
                const downPaymentDate = installment.down_payment_date || installment.downPaymentDate;
                if (downPaymentDate && isDateInRange(downPaymentDate)) {
                    // Find which day this down_payment_date belongs to
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(downPaymentDate, currentDayDate)) {
                            const commission = parseFloat(installment.commission) || 0;
                            const downPayment = parseFloat(installment.down_payment || installment.downPayment) || 0;
                            dailyIncome[dayIdx] += commission;
                            dailyExpense[dayIdx] += downPayment;
                            break;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error fetching installments for chart:', error);
        }
        
        // Process pawn - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: interest + redemption, ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: pawn_amount
        try {
            const allPawns = await API.get(API_ENDPOINTS.pawn);
            allPawns.forEach(pawn => {
                // ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: pawn_amount ‡πÄ‡∏°‡∏∑‡πà‡∏≠ receive_date
                const receiveDate = pawn.receive_date || pawn.receiveDate;
                if (receiveDate && isDateInRange(receiveDate)) {
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(receiveDate, currentDayDate)) {
                            const pawnAmount = parseFloat(pawn.pawn_amount || pawn.pawnAmount) || 0;
                            dailyExpense[dayIdx] += pawnAmount;
                            break;
                        }
                    }
                }
                
                // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: interest + redemption ‡πÄ‡∏°‡∏∑‡πà‡∏≠ returned_date
                const returnedDate = pawn.returned_date || pawn.returnedDate;
                if (returnedDate && isDateInRange(returnedDate)) {
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(returnedDate, currentDayDate)) {
                            const interest = parseFloat(pawn.interest) || 0;
                            const redemptionAmount = parseFloat(pawn.redemption_amount || pawn.redemptionAmount) || 0;
                            dailyIncome[dayIdx] += interest + redemptionAmount;
                            break;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error fetching pawns for chart:', error);
        }
        
        // Process repairs - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: repair_price (returned_date), ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: accessory_cost + commission (completed_date)
        try {
            const salayaRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'salaya' });
            const klongyongRepairs = await API.get(API_ENDPOINTS.repairs, { store: 'klongyong' });
            const allRepairs = [...salayaRepairs, ...klongyongRepairs];
            
            allRepairs.forEach(repair => {
                // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: repair_cost ‡πÄ‡∏°‡∏∑‡πà‡∏≠ returned_date (status = received) - ‡πÉ‡∏ä‡πâ field ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö updateDashboard()
                const returnedDate = repair.returned_date || repair.returnedDate;
                if (repair.status === 'received' && returnedDate && isDateInRange(returnedDate)) {
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(returnedDate, currentDayDate)) {
                            const repairCost = parseFloat(repair.repair_cost || repair.repairCost || repair.repair_price || repair.repairPrice || 0);
                            dailyIncome[dayIdx] += repairCost;
                            break;
                        }
                    }
                }
                
                // ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: accessory_cost + commission ‡πÄ‡∏°‡∏∑‡πà‡∏≠ completed_date
                const completedDate = repair.completed_date || repair.completedDate;
                if ((repair.status === 'completed' || repair.status === 'received') && completedDate && isDateInRange(completedDate)) {
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(completedDate, currentDayDate)) {
                            const accessoryCost = parseFloat(repair.accessory_cost || repair.accessoryCost) || 0;
                            const commission = parseFloat(repair.commission) || 0;
                            dailyExpense[dayIdx] += accessoryCost + commission;
                            break;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error fetching repairs for chart:', error);
        }
        
        // Process accessories (parts) - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: cut_price, ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: cost_price * cut_quantity
        try {
            const salayaCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: 'salaya' });
            const klongyongCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: 'klongyong' });
            const allCutAccessories = [...salayaCutAccessories, ...klongyongCutAccessories];
            
            allCutAccessories.forEach(accessory => {
                const cutDate = accessory.cut_date || accessory.cutDate;
                if (cutDate && isDateInRange(cutDate)) {
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(cutDate, currentDayDate)) {
                            const cutPrice = parseFloat(accessory.cut_price || accessory.cutPrice) || 0;
                            const costPrice = parseFloat(accessory.cost_price || accessory.costPrice) || 0;
                            const cutQty = parseFloat(accessory.cut_quantity || accessory.cutQuantity) || 0;
                            dailyIncome[dayIdx] += cutPrice * cutQty;
                            dailyExpense[dayIdx] += costPrice * cutQty;
                            break;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error fetching accessories for chart:', error);
        }
        
        // Process equipment - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: cut_price, ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: cost_price * cut_quantity
        try {
            const salayaEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'salaya' });
            const klongyongEquipment = await API.get(API_ENDPOINTS.equipment, { store: 'klongyong' });
            const allEquipment = [...salayaEquipment, ...klongyongEquipment];
            
            allEquipment.forEach(equipment => {
                const cutDate = equipment.cut_date || equipment.cutDate;
                if (cutDate && isDateInRange(cutDate)) {
                    for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                        const currentDayDate = new Date(startDate);
                        currentDayDate.setDate(startDate.getDate() + dayIdx);
                        
                        if (isDateOnDay(cutDate, currentDayDate)) {
                            const cutPrice = parseFloat(equipment.cut_price || equipment.cutPrice) || 0;
                            const costPrice = parseFloat(equipment.cost_price || equipment.costPrice) || 0;
                            const cutQty = parseFloat(equipment.cut_quantity || equipment.cutQuantity) || 0;
                            dailyIncome[dayIdx] += cutPrice * cutQty;
                            dailyExpense[dayIdx] += costPrice * cutQty;
                            break;
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error fetching equipment for chart:', error);
        }
        
        // Process simcards - ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: sale_price, ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: cost_price
        try {
            const salayaSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'salaya' });
            const klongyongSimcards = await API.get(API_ENDPOINTS.simcard, { store: 'klongyong' });
            const allSimcards = [...salayaSimcards, ...klongyongSimcards];
            
            allSimcards.forEach(simcard => {
                if (simcard.status === 'sold') {
                    const soldDate = simcard.sold_date || simcard.soldDate;
                    if (soldDate && isDateInRange(soldDate)) {
                        for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                            const currentDayDate = new Date(startDate);
                            currentDayDate.setDate(startDate.getDate() + dayIdx);
                            
                            if (isDateOnDay(soldDate, currentDayDate)) {
                                const salePrice = parseFloat(simcard.sale_price || simcard.salePrice) || 0;
                                const costPrice = parseFloat(simcard.cost_price || simcard.costPrice) || 0;
                                dailyIncome[dayIdx] += salePrice;
                                dailyExpense[dayIdx] += costPrice;
                                break;
                            }
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Error fetching simcards for chart:', error);
        }

        // Process expenses from database - ALL STORES (match updateDashboard logic)
        try {
            // Fetch income expenses (ALL STORES)
            const incomeExpensesResponse = await fetch(`http://localhost:5001/api/expenses?type=income`);
            if (incomeExpensesResponse.ok) {
                const incomeExpensesData = await incomeExpensesResponse.json();
                incomeExpensesData.forEach(expense => {
                    const expenseDate = expense.date;
                    if (expenseDate && isDateInRange(expenseDate)) {
                        for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                            const currentDayDate = new Date(startDate);
                            currentDayDate.setDate(startDate.getDate() + dayIdx);
                            
                            if (isDateOnDay(expenseDate, currentDayDate)) {
                                const amount = parseFloat(expense.amount) || 0;
                                dailyIncome[dayIdx] += amount;
                                break;
                            }
                        }
                    }
                });
            }
            
            // Fetch expense expenses (ALL STORES)
            const expenseExpensesResponse = await fetch(`http://localhost:5001/api/expenses?type=expense`);
            if (expenseExpensesResponse.ok) {
                const expenseExpensesData = await expenseExpensesResponse.json();
                expenseExpensesData.forEach(expense => {
                    const expenseDate = expense.date;
                    if (expenseDate && isDateInRange(expenseDate)) {
                        for (let dayIdx = 0; dayIdx < daysInMonth; dayIdx++) {
                            const currentDayDate = new Date(startDate);
                            currentDayDate.setDate(startDate.getDate() + dayIdx);
                            
                            if (isDateOnDay(expenseDate, currentDayDate)) {
                                const amount = parseFloat(expense.amount) || 0;
                                dailyExpense[dayIdx] += amount;
                                break;
                            }
                        }
                    }
                });
            }
        } catch (error) {
            console.error('Error fetching expenses for chart:', error);
        }
        }
        
        // Debug: Log final daily data summary
        const totalDailyIncome = dailyIncome.reduce((sum, val) => sum + val, 0);
        const totalDailyExpense = dailyExpense.reduce((sum, val) => sum + val, 0);
        const daysWithData = dailyIncome.filter((val, idx) => val > 0 || dailyExpense[idx] > 0).length;
        
        // Compare chart totals with dashboard card totals
        const dashboardIncome = data.totalIncome || 0;
        const dashboardExpense = data.totalExpense || 0;
        const incomeDiff = Math.abs(totalDailyIncome - dashboardIncome);
        const expenseDiff = Math.abs(totalDailyExpense - dashboardExpense);
        const incomeMatch = incomeDiff < 0.01; // Allow small floating point differences
        const expenseMatch = expenseDiff < 0.01;
        
        console.log('üìä [Chart] Final Summary:', {
            totalDailyIncome,
            totalDailyExpense,
            daysWithData,
            maxDailyIncome: Math.max(...dailyIncome),
            maxDailyExpense: Math.max(...dailyExpense),
            dailyIncomeSample: dailyIncome.slice(0, 5),
            dailyExpenseSample: dailyExpense.slice(0, 5)
        });
        
        console.log('üîç [Chart vs Dashboard] Comparison:', {
            chartIncome: totalDailyIncome,
            dashboardIncome: dashboardIncome,
            incomeMatch: incomeMatch ? '‚úÖ MATCH' : `‚ùå DIFFERENCE: ${incomeDiff.toFixed(2)}`,
            chartExpense: totalDailyExpense,
            dashboardExpense: dashboardExpense,
            expenseMatch: expenseMatch ? '‚úÖ MATCH' : `‚ùå DIFFERENCE: ${expenseDiff.toFixed(2)}`,
            isSingleDay: isSingleDay,
            hasFilter: !!(currentDashboardFilter.startDate || currentDashboardFilter.endDate)
        });
        
        // Warn if totals don't match (only for current month view, not single day)
        if (!isSingleDay && (!incomeMatch || !expenseMatch)) {
            console.warn('‚ö†Ô∏è [Chart vs Dashboard] MISMATCH DETECTED!', {
                incomeDiff: incomeDiff,
                expenseDiff: expenseDiff,
                message: 'Please check data calculation logic'
            });
        }

        // Create chart with negative values for expenses (downward)
        monthlyIncomeExpenseChart = new Chart(monthlyChartCtx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: '‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö',
                        data: dailyIncome,
                        backgroundColor: 'rgba(34, 197, 94, 0.9)',
                        borderColor: 'rgba(34, 197, 94, 1)',
                        borderWidth: 0,
                        barThickness: 12
                    },
                    {
                        label: '‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢',
                        data: dailyExpense.map(val => -val), // Negative values for bottom display
                        backgroundColor: 'rgba(239, 68, 68, 0.9)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 0,
                        barThickness: 12
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'x',
                grouped: false,
                layout: {
                    padding: {
                        top: 10,
                        bottom: 10,
                        left: 10,
                        right: 10
                    }
                },
                scales: {
                    x: {
                        stacked: false,
                        grid: {
                            display: false
                        },
                        border: {
                            display: true,
                            color: '#e5e7eb',
                            width: 1
                        },
                        ticks: {
                            color: '#6b7280',
                            font: {
                                size: 11
                            },
                            padding: 8
                        },
                        title: {
                            display: true,
                            text: '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà',
                            color: '#374151',
                            font: {
                                size: 12,
                                weight: 'normal'
                            },
                            padding: {
                                top: 10
                            }
                        }
                    },
                    y: {
                        stacked: false,
                        grid: {
                            display: false
                        },
                        border: {
                            display: true,
                            color: '#e5e7eb',
                            width: 1
                        },
                        ticks: {
                            color: '#6b7280',
                            font: {
                                size: 11
                            },
                            padding: 8,
                            callback: function(value) {
                                return Math.abs(value).toLocaleString();
                            }
                        },
                        title: {
                            display: true,
                            text: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô (‡∏ø)',
                            color: '#374151',
                            font: {
                                size: 12,
                                weight: 'normal'
                            },
                            padding: {
                                bottom: 10
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        align: 'center',
                        labels: {
                            color: '#374151',
                            font: {
                                size: 12
                            },
                            padding: 15,
                            usePointStyle: true,
                            pointStyle: 'circle',
                            boxWidth: 8,
                            boxHeight: 8
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        padding: 12,
                        titleFont: {
                            size: 13,
                            weight: 'normal'
                        },
                        bodyFont: {
                            size: 12
                        },
                        borderColor: 'transparent',
                        borderWidth: 0,
                        cornerRadius: 6,
                        displayColors: true,
                        callbacks: {
                            label: function(context) {
                                const value = Math.abs(context.parsed.y);
                                return `${context.dataset.label}: ${formatCurrency(value)}`;
                            }
                        }
                    }
                },
                elements: {
                    bar: {
                        borderRadius: 2,
                        borderSkipped: false
                    }
                }
            }
        });
        
    } catch (error) {
        console.error('Error updating monthly income-expense chart:', error);
    }
}

// Format currency
function formatCurrency(amount) {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ amount ‡πÄ‡∏õ‡πá‡∏ô number ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (amount === undefined || amount === null || isNaN(amount)) {
        return '‡∏ø0';
    }
    // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô number ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô string
    const numAmount = typeof amount === 'string' ? parseFloat(amount) : amount;
    return '‡∏ø' + numAmount.toLocaleString('th-TH', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
}

// Format warranty
function formatWarranty(days) {
    if (days === undefined || days === null || days === 0) {
        return '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô';
    }
    const numDays = parseInt(days);
    switch(numDays) {
        case 7: return '7 ‡∏ß‡∏±‡∏ô';
        case 30: return '1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô';
        case 90: return '3 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô';
        case 180: return '6 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô';
        case 365: return '1 ‡∏õ‡∏µ';
        default: return numDays + ' ‡∏ß‡∏±‡∏ô';
    }
}

// Get today's date in YYYY-MM-DD format
function getTodayDate() {
    return new Date().toISOString().split('T')[0];
}

// Open Modal
function openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden'; // Prevent body scroll
    }
}

// Close Modal
function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto'; // Re-enable body scroll
    }
}

// Animate stat numbers
function animateStats() {
    const statValues = document.querySelectorAll('.stat-value, .summary-amount, .income-breakdown-amount, .expense-breakdown-amount, .profit-breakdown-amount');
    statValues.forEach(stat => {
        stat.style.animation = 'none';
        setTimeout(() => {
            stat.style.animation = 'fadeIn 0.5s ease';
        }, 10);
    });
}

// Navigate to page from dashboard
function navigateToPage(pageName) {
    // Remove active class from all nav items
    const navItems = document.querySelectorAll('.nav-item');
    navItems.forEach(item => item.classList.remove('active'));

    // Find and activate the target nav item
    const targetNavItem = document.querySelector(`.nav-item[data-page="${pageName}"]`);
    if (targetNavItem) {
        targetNavItem.classList.add('active');
    }

    // Hide all pages
    const allPages = document.querySelectorAll('.page-content');
    allPages.forEach(p => p.classList.remove('active'));

    // Show selected page
    const selectedPage = document.getElementById(pageName);
    if (selectedPage) {
        selectedPage.classList.add('active');
    }

    // Update page title
    const pageTitle = document.getElementById('pageTitle');
    pageTitle.textContent = pageTitles[pageName] || '‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏£‡πâ‡∏≤‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠';

    // Sync filter inputs with current page filter
    syncFilterInputs(pageName);

    // Initialize tabs for specific pages
    if (pageName === 'pawn') {
        loadPawnData();
        initializePawnTabs();
    } else if (pageName === 'used-devices') {
        initializeUsedTabs();
    } else if (pageName === 'installment') {
        initializeInstallmentTabs();
    } else if (pageName === 'new-devices') {
        initializeNewTabs();
    } else if (pageName === 'repair') {
        initializeRepairTabs();
    } else if (pageName === 'accessories') {
        switchAccessoryTab(currentAccessoryTab || 'battery');
    } else if (pageName === 'equipment') {
        loadEquipmentData();
        // Ensure equipment tabs work when navigating via quick access
        switchEquipmentTab(currentAccessoryTab || 'charger-set');
    } else if (pageName === 'simcard') {
        loadSimcardData();
        initializeSimcardTabs();
        initializeSimcardSearch();
    } else if (pageName === 'bills') {
        loadBillsData();
    } else if (pageName === 'members') {
        loadMembersData();
    } else if (pageName === 'installment-income-detail') {
        loadInstallmentIncomeDetailPage();
    } else if (pageName === 'pawn-income-breakdown-detail') {
        loadPawnIncomeBreakdownDetailPage();
    } else if (pageName === 'pawn-expense-breakdown-detail') {
        loadPawnExpenseBreakdownDetailPage();
    } else if (pageName === 'pawn-profit-breakdown-detail') {
        loadPawnProfitBreakdownDetailPage();
    } else if (pageName === 'new-devices-expense-detail') {
        showNewDevicesExpenseDetail();
    } else if (pageName === 'new-devices-income-detail') {
        showNewDevicesIncomeDetail();
    } else if (pageName === 'new-devices-profit-detail') {
        showNewDevicesProfitDetail();
    } else if (pageName === 'used-devices-expense-detail') {
        showUsedDevicesExpenseDetail();
    } else if (pageName === 'used-devices-income-detail') {
        showUsedDevicesIncomeDetail();
    } else if (pageName === 'used-devices-profit-detail') {
        showUsedDevicesProfitDetail();
    } else if (pageName === 'installment-expense-detail') {
        showInstallmentExpenseDetail();
    } else if (pageName === 'repair-expense-detail') {
        showRepairExpenseDetail();
    } else if (pageName === 'repair-income-detail') {
        showRepairIncomeDetail();
    } else if (pageName === 'repair-profit-detail') {
        showRepairProfitDetail();
    }

    // Smooth scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Show notification when store changes
function showStoreChangeNotification() {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 16px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease;
    `;
    notification.textContent = `‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô ${stores[currentStore]} ‡πÅ‡∏•‡πâ‡∏ß`;

    document.body.appendChild(notification);

    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 2000);
}

// Add animation styles
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from {
            transform: translateX(400px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    @keyframes slideOut {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(400px);
            opacity: 0;
        }
    }
`;
document.head.appendChild(style);

// ===== NEW DEVICES MANAGEMENT =====

// Mock database for new devices

// Data storage

// Initialize new devices database
async function initializeNewDevicesDatabase() {
    try {
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API ‡πÅ‡∏ó‡∏ô localStorage
        newDevices = await API.get(API_ENDPOINTS.newDevices);
        console.log('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        console.log(`üìä ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${newDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        loadNewDevicesData();
    } catch (error) {
        console.error('Error loading new devices from API:', error);
        newDevices = [];
    }
}

// ===== NEW DEVICES CRUD FUNCTIONS =====

// Initialize new devices tabs
function initializeNewTabs() {
    const tabButtons = document.querySelectorAll('#new-devices .tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');

            // Remove active class from all new devices tabs and contents
            document.querySelectorAll('#new-devices .tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#new-devices .tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            this.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        });
    });
}

// ===== USED DEVICES DATABASE =====

// Mock database for used devices

// Initialize used devices database
async function initializeUsedDevicesDatabase() {
    try {
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API ‡πÅ‡∏ó‡∏ô localStorage
        usedDevices = await API.get(API_ENDPOINTS.usedDevices);
        console.log('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏à‡∏≤‡∏Å API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        console.log(`üìä ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${usedDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        loadUsedDevicesData();
    } catch (error) {
        console.error('Error loading used devices from API:', error);
        usedDevices = [];
    }
}

// ===== USED DEVICES CRUD FUNCTIONS =====

// Initialize used devices tabs
function initializeUsedTabs() {
    const tabButtons = document.querySelectorAll('#used-devices .tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');

            // Remove active class from all used devices tabs and contents
            document.querySelectorAll('#used-devices .tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#used-devices .tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            this.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        });
    });
}

// Toggle RAM required for used devices based on brand
function toggleUsedRamRequired() {
    const brandInput = document.getElementById('usedBrand');
    const ramSelect = document.getElementById('usedRam');
    const ramLabel = document.querySelector('label[for="usedRam"]');
    
    if (brandInput && ramSelect && ramLabel) {
        const brand = brandInput.value.trim().toLowerCase();
        const isApple = brand === 'apple';
        
        if (isApple) {
            // Apple: RAM is optional
            ramSelect.removeAttribute('required');
            const requiredSpan = ramLabel.querySelector('.required');
            if (requiredSpan) {
                requiredSpan.style.display = 'none';
            }
        } else {
            // Other brands: RAM is required
            ramSelect.setAttribute('required', 'required');
            const requiredSpan = ramLabel.querySelector('.required');
            if (requiredSpan) {
                requiredSpan.style.display = 'inline';
            }
        }
    }
}

// Open used device modal
async function openUsedDeviceModal(deviceId = null) {
    const modal = document.getElementById('usedDeviceModal');
    const modalTitle = document.getElementById('usedModalTitle');
    const form = document.getElementById('usedDeviceForm');

    // Reset form
    form.reset();
    currentUsedEditId = deviceId;

    if (deviceId) {
        // Edit mode
        modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á';

        try {
            const device = await API.get(`${API_ENDPOINTS.usedDevices}/${deviceId}`);

            if (device) {
                document.getElementById('usedDeviceId').value = device.id;
                document.getElementById('usedBrand').value = device.brand;
                document.getElementById('usedModel').value = device.model;
                document.getElementById('usedColor').value = device.color;
                document.getElementById('usedImei').value = device.imei;
                document.getElementById('usedRam').value = device.ram;
                document.getElementById('usedRom').value = device.rom;
                document.getElementById('usedPurchasedFrom').value = device.purchased_from || '';
                document.getElementById('usedDeviceCategory').value = device.device_category || 'No Active';
                document.getElementById('usedPurchasePrice').value = device.purchase_price || device.purchasePrice;
                document.getElementById('usedPurchaseDate').value = device.import_date || device.purchase_date || device.purchaseDate;
                document.getElementById('usedSalePrice').value = device.sale_price || device.salePrice;
                document.getElementById('usedSaleDate').value = device.sale_date || device.saleDate || '';
                document.getElementById('usedCondition').value = device.device_condition || device.condition;
                document.getElementById('usedStatus').value = device.status;
                document.getElementById('usedNote').value = device.note || '';

                toggleUsedSaleDateField();
                toggleUsedRamRequired(); // Check brand and toggle RAM requirement
            }
        } catch (error) {
            console.error('Error loading device:', error);
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
                icon: 'error',
                confirmType: 'danger'
            });
        }
    } else {
        // Add mode
        modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á';
        // Set default purchase date to today
        document.getElementById('usedPurchaseDate').value = new Date().toISOString().split('T')[0];
        // Set default device category
        document.getElementById('usedDeviceCategory').value = 'No Active';
        toggleUsedRamRequired(); // Initialize RAM requirement check
    }

    modal.classList.add('show');
}

// Close used device modal
function closeUsedDeviceModal() {
    const modal = document.getElementById('usedDeviceModal');
    modal.classList.remove('show');
    currentUsedEditId = null;
}

// Toggle sale date field based on status for used devices
function toggleUsedSaleDateField() {
    const status = document.getElementById('usedStatus').value;
    const noteGroup = document.getElementById('usedNoteGroup');

    if (status === 'removed') {
        noteGroup.style.display = 'flex';
    } else {
        noteGroup.style.display = 'none';
    }
}

// Save used device
async function saveUsedDevice(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const deviceData = {
        brand: formData.get('brand'),
        model: formData.get('model'),
        color: formData.get('color'),
        imei: formData.get('imei'),
        ram: formData.get('ram'),
        rom: formData.get('rom'),
        purchased_from: formData.get('purchasedFrom') || '',
        device_category: formData.get('deviceCategory') || 'No Active',
        device_condition: formData.get('condition'),
        purchase_price: parseFloat(formData.get('purchasePrice')),
        import_date: formData.get('purchaseDate'),
        sale_price: parseFloat(formData.get('salePrice')),
        sale_date: formData.get('saleDate') || null,
        status: formData.get('status'),
        note: formData.get('note') || '',
        store: currentStore
    };

    // üõ°Ô∏è ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
    if (deviceData.status === 'sold' && deviceData.note) {
        const hasConflict = deviceData.note.includes('‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö') || 
                           deviceData.note.includes('‡πÇ‡∏≠‡∏ô') || 
                           deviceData.note.includes('‡∏¢‡πâ‡∏≤‡∏¢');
        
        if (hasConflict) {
            await customAlert({
                title: '‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ\n\n' +
                        '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á:\n' +
                        '‚Ä¢ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ "‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß" (sold) - ‡∏ñ‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ñ‡∏π‡∏Å‡∏Ç‡∏≤‡∏¢‡∏à‡∏£‡∏¥‡∏á\n' +
                        '‚Ä¢ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ "‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å" (removed) + ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏ "‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö/‡πÇ‡∏≠‡∏ô" - ‡∏ñ‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÇ‡∏≠‡∏ô‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô',
                icon: 'error'
            });
            return; // ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
        }
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ removed ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏Ç‡∏≤‡∏¢
    if (deviceData.status === 'removed' && deviceData.note) {
        const hasConflict = deviceData.note.includes('‡∏Ç‡∏≤‡∏¢') || deviceData.note.includes('sold');
        
        if (hasConflict) {
            await customAlert({
                title: '‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
                icon: 'error'
            });
            return; // ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
        }
    }

    try {
        if (currentUsedEditId) {
            await API.put(`${API_ENDPOINTS.usedDevices}/${currentUsedEditId}`, deviceData);
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } else {
            deviceData.id = 'U' + Date.now().toString();
            await API.post(API_ENDPOINTS.usedDevices, deviceData);
            showNotification('‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }

        loadUsedDevicesData();
        closeUsedDeviceModal();
    } catch (error) {
        console.error('Error saving used device:', error);

        // Check if it's a duplicate IMEI error
        if (error.duplicate || (error.message && error.message.includes('IMEI'))) {
            await customAlert({
                title: '‚ùå IMEI ‡∏ã‡πâ‡∏≥',
                message: `IMEI "${deviceData.imei}" ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö IMEI ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà`,
                icon: 'error'
            });
        }
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á
        else if (error.conflict || (error.message && error.message.includes('‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á'))) {
            await customAlert({
                title: '‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á',
                message: error.message || '‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å',
                icon: 'error'
            });
        }
        else {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
                icon: 'error'
            });
        }
    }
}

// Load and display used devices data
function loadUsedDevicesData() {
    // Apply current filter (which will show current month by default)
    applyUsedDevicesFilter();

    // Update dashboard stats
    updateDashboard();
}

// Update new devices tab counts
function updateNewDevicesTabCounts() {
    const storeDevices = newDevices.filter(d => d.store === currentStore);
    
    // Get current month and year
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth() + 1;
    const currentYear = currentDate.getFullYear();
    
    // Filter devices for current month
    const currentMonthDevices = storeDevices.filter(device => {
        const deviceDate = new Date(device.importDate);
        return deviceDate.getMonth() + 1 === currentMonth && deviceDate.getFullYear() === currentYear;
    });
    
    // Count devices by status for current month
    const stockCount = currentMonthDevices.filter(d => d.status === 'stock').length;
    const soldCount = currentMonthDevices.filter(d => d.status === 'sold').length;
    const removedCount = currentMonthDevices.filter(d => d.status === 'removed').length;
    
    // Update tab counts
    const stockCountElement = document.getElementById('newStockCount');
    const soldCountElement = document.getElementById('newSoldCount');
    const removedCountElement = document.getElementById('newRemovedCount');
    
    if (stockCountElement) stockCountElement.textContent = stockCount;
    if (soldCountElement) soldCountElement.textContent = soldCount;
    if (removedCountElement) removedCountElement.textContent = removedCount;
}

// Update used devices tab counts
function updateUsedDevicesTabCounts() {
    const storeDevices = usedDevices.filter(d => d.store === currentStore);
    
    // Get current month and year
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth() + 1;
    const currentYear = currentDate.getFullYear();
    
    // Filter devices for current month
    const currentMonthDevices = storeDevices.filter(device => {
        const deviceDate = new Date(device.purchaseDate);
        return deviceDate.getMonth() + 1 === currentMonth && deviceDate.getFullYear() === currentYear;
    });
    
    // Count devices by status for current month
    const stockCount = currentMonthDevices.filter(d => d.status === 'stock').length;
    const soldCount = currentMonthDevices.filter(d => d.status === 'sold').length;
    const removedCount = currentMonthDevices.filter(d => d.status === 'removed').length;
    
    // Update tab counts
    const stockCountElement = document.getElementById('usedStockCount');
    const soldCountElement = document.getElementById('usedSoldCount');
    const removedCountElement = document.getElementById('usedRemovedCount');
    
    if (stockCountElement) stockCountElement.textContent = stockCount;
    if (soldCountElement) soldCountElement.textContent = soldCount;
    if (removedCountElement) removedCountElement.textContent = removedCount;
}

// Display used devices in table
function displayUsedDevices(devices, tableBodyId, type) {
    const tbody = document.getElementById(tableBodyId);

    if (!tbody) return;

    if (devices.length === 0) {
        const colspan = type === 'stock' ? '10' : type === 'sold' ? '11' : '12';
        tbody.innerHTML = `<tr><td colspan="${colspan}" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>`;
        return;
    }

    // Condition labels in Thai
    const conditionLabels = {
        excellent: '‡∏î‡∏µ‡∏°‡∏≤‡∏Å',
        good: '‡∏î‡∏µ',
        fair: '‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ',
        poor: '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á'
    };

    tbody.innerHTML = devices.map(device => {
        // Handle both snake_case and camelCase field names
        const purchasePrice = device.purchase_price || device.purchasePrice;
        const salePrice = device.sale_price || device.salePrice;
        const purchaseDate = device.purchase_date || device.purchaseDate || device.import_date;
        const saleDate = device.sale_date || device.saleDate;
        const condition = device.device_condition || device.condition;

        if (type === 'stock') {
            return `
                <tr>
                    <td style="width: 7%;">${device.brand}</td>
                    <td style="width: 10%;">${device.model}</td>
                    <td style="width: 5%;">${device.color}</td>
                    <td style="width: 9%;">${device.imei}</td>
                    <td style="width: 8%;">${device.ram}/${device.rom} GB</td>
                    <td style="width: 8%;">${conditionLabels[condition] || condition}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(purchasePrice)}</td>
                    <td style="width: 10%; text-align: center;">${formatDate(purchaseDate)}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 27%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="device-action-select" id="used-action-${device.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="sell">‡∏Ç‡∏≤‡∏¢</option>
                                <option value="installment">‡∏ú‡πà‡∏≠‡∏ô</option>
                                <option value="remove">‡∏ï‡∏±‡∏î</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeUsedDeviceAction('${device.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'sold') {
            const profit = salePrice - purchasePrice;
            const profitColor = profit >= 0 ? '#10b981' : '#ef4444';
            const note = device.note || '-';
            return `
                <tr>
                    <td style="width: 6%;">${device.brand}</td>
                    <td style="width: 8%;">${device.model}</td>
                    <td style="width: 5%;">${device.color}</td>
                    <td style="width: 8%;">${device.imei}</td>
                    <td style="width: 7%;">${device.ram}/${device.rom} GB</td>
                    <td style="width: 8%;">${conditionLabels[condition] || condition}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(purchasePrice)}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 9%; text-align: center;">${formatDate(saleDate)}</td>
                    <td style="width: 8%; text-align: right; color: ${profitColor}; font-weight: 600;">${formatCurrency(profit)}</td>
                    <td style="width: 9%;">${note}</td>
                    <td style="width: 16%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="device-action-select" id="used-action-${device.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="back-stock">‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeUsedDeviceAction('${device.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else {
            // Removed tab
            const profit = salePrice - purchasePrice;
            const profitColor = profit >= 0 ? '#10b981' : '#ef4444';
            return `
                <tr>
                    <td style="width: 6%;">${device.brand}</td>
                    <td style="width: 8%;">${device.model}</td>
                    <td style="width: 5%;">${device.color}</td>
                    <td style="width: 8%;">${device.imei}</td>
                    <td style="width: 7%;">${device.ram}/${device.rom} GB</td>
                    <td style="width: 8%;">${conditionLabels[condition] || condition}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(purchasePrice)}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 9%; text-align: center;">${formatDate(saleDate)}</td>
                    <td style="width: 8%; text-align: right; color: ${profitColor}; font-weight: 600;">${formatCurrency(profit)}</td>
                    <td style="width: 9%;">${device.note || '-'}</td>
                    <td style="width: 16%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="device-action-select" id="used-action-${device.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="back-stock">‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeUsedDeviceAction('${device.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        }
    }).join('');
}

// Execute used device action from dropdown
async function executeUsedDeviceAction(deviceId) {
    const selectElement = document.getElementById(`used-action-${deviceId}`);
    const action = selectElement.value;

    if (!action) {
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'view':
            await viewUsedDeviceDetail(deviceId);
            break;
        case 'sell':
            await markUsedAsSold(deviceId);
            break;
        case 'installment':
            await transferUsedToInstallment(deviceId);
            break;
        case 'remove':
            await markUsedAsRemoved(deviceId);
            break;
        case 'back-stock':
            await moveUsedBackToStock(deviceId);
            break;
        case 'edit':
            await openUsedDeviceModal(deviceId);
            break;
        case 'delete':
            await deleteUsedDevice(deviceId);
            break;
        default:
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å',
                icon: 'error'
            });
    }

    // Reset select after action
    selectElement.value = '';
}

// Mark used device as sold - Open confirmation modal (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà)
async function markUsedAsSold(deviceId) {
    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
        const device = await API.get(`${API_ENDPOINTS.usedDevices}/${deviceId}`);
        if (!device) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
                icon: 'error',
                confirmType: 'danger'
            });
            return;
        }

        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ
        window.currentSaleDevice = device;
        window.currentSaleDeviceType = 'used'; // ‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Modal (‡πÉ‡∏ä‡πâ Modal ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà)
        const deviceInfo = `${device.brand} ${device.model} (${device.color})`;
        const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
        const originalSalePrice = parseFloat(device.sale_price || device.salePrice || 0);

        document.getElementById('saleDeviceInfo').textContent = deviceInfo;
        document.getElementById('salePurchasePrice').textContent = formatCurrency(purchasePrice);
        document.getElementById('saleOriginalPrice').textContent = formatCurrency(originalSalePrice);
        document.getElementById('actualSalePrice').value = originalSalePrice;
        document.getElementById('saleDeviceId').value = deviceId;
        
        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('saleDateInput').value = today;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        updateSaleProfit(originalSalePrice, purchasePrice);

        // ‡πÄ‡∏û‡∏¥‡πà‡∏° event listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏ö‡∏ö real-time
        const priceInput = document.getElementById('actualSalePrice');
        priceInput.oninput = function() {
            const salePrice = parseFloat(this.value) || 0;
            updateSaleProfit(salePrice, purchasePrice);
        };

        // ‡πÄ‡∏õ‡∏¥‡∏î Modal
        document.getElementById('confirmSalePriceModal').style.display = 'block';

        } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
            console.error(error);
    }
}

// Mark used device as removed (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà)
async function markUsedAsRemoved(deviceId) {
    try {
        const device = await API.get(`${API_ENDPOINTS.usedDevices}/${deviceId}`);
        if (!device) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
                icon: 'error',
                confirmType: 'danger'
            });
            return;
        }

        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ
        window.currentRemoveDevice = device;
        window.currentRemoveDeviceType = 'used'; // ‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Modal
        const deviceInfo = `${device.brand} ${device.model} (${device.color})`;
        const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
        const originalSalePrice = parseFloat(device.sale_price || device.salePrice || 0);

        document.getElementById('removeDeviceInfo').textContent = deviceInfo;
        document.getElementById('removePurchasePrice').textContent = formatCurrency(purchasePrice);
        document.getElementById('removeOriginalPrice').textContent = formatCurrency(originalSalePrice);
        document.getElementById('removeDeviceId').value = deviceId;

        // ‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
            const otherStore = device.store === 'salaya' ? 'klongyong' : 'salaya';
            const otherStoreName = stores[otherStore];
        document.getElementById('transferStoreName').textContent = `‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ: ${otherStoreName}`;

        // ‡πÅ‡∏™‡∏î‡∏á Modal
        document.getElementById('confirmRemoveModal').style.display = 'block';

    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Delete used device
async function deleteUsedDevice(deviceId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'warning',
        confirmText: '‡∏•‡∏ö',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
        confirmType: 'danger',
        list: [
            { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ' },
            { icon: 'info', iconSymbol: '‚ÑπÔ∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏ñ‡∏≤‡∏ß‡∏£' }
        ]
    });

    if (confirmed) {
        try {
            await API.delete(`${API_ENDPOINTS.usedDevices}/${deviceId}`);
            
            await customAlert({
                title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                message: '‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                icon: 'success',
                confirmType: 'success'
            });
            
            await applyUsedDevicesFilter();
        } catch (error) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: error.message,
                icon: 'error',
                confirmType: 'danger'
            });
            console.error(error);
        }
    }
}

// Initialize used devices search
function initializeUsedSearch() {
    const searchInput = document.getElementById('searchUsedDevices');
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            applyUsedDevicesFilter();
        });
    }
}

// Filter used devices based on search term
function filterUsedDevices(searchTerm) {
    applyUsedDevicesFilter();
}

// Close used device modal when clicking outside
window.addEventListener('click', function(event) {
    const usedModal = document.getElementById('usedDeviceModal');
    if (event.target === usedModal) {
        closeUsedDeviceModal();
    }
});

// ===== USED DEVICES DATABASE MANAGEMENT FUNCTIONS =====

// Note: Reset function removed - now using MySQL API instead of localStorage mock data

// Clear all used devices data
function clearUsedDevicesDatabase() {
    if (confirm('‚ö†Ô∏è ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n\n‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ')) {
        usedDevices = [];
        localStorage.setItem('usedDevices', JSON.stringify(usedDevices));
        loadUsedDevicesData();
        showNotification('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        console.log('üóëÔ∏è ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß');
    }
}

// Export used devices database to JSON file
function exportUsedDevicesDatabase() {
    const dataStr = JSON.stringify(usedDevices, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `used-devices-backup-${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    URL.revokeObjectURL(url);
    showNotification('‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
}

// Import used devices database from JSON file
function importUsedDevicesDatabase(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedData = JSON.parse(e.target.result);
            if (confirm(`‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ${importedData.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`)) {
                usedDevices = importedData;
                localStorage.setItem('usedDevices', JSON.stringify(usedDevices));
                loadUsedDevicesData();
                showNotification('‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
                console.log('‚úÖ ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
                console.log(`üìä ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${usedDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
            }
        } catch (error) {
            alert('‚ùå ‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå JSON ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
            console.error('Import error:', error);
        }
    };
    reader.readAsText(file);
}

// ========================================
// EXCEL EXPORT FUNCTIONS
// ========================================

/**
 * Export stock data to Excel file
 * @param {string} type - Type of data: 'new-devices', 'used-devices', 'accessories', 'equipment'
 * @param {Array} stockData - Array of stock items
 * @param {string} storeName - Store name for filename
 */
async function exportStockToExcel(type, stockData, storeName = '') {
    try {
        if (!stockData || stockData.length === 0) {
            showNotification('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡πÉ‡∏´‡πâ export', 'warning');
            return;
        }

        // Prepare data based on type
        let worksheetData = [];
        let fileName = '';
        let sheetName = '';

        const today = new Date().toLocaleDateString('th-TH', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });

        switch (type) {
            case 'new-devices':
                fileName = `‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà_${storeName}_${new Date().toISOString().split('T')[0]}.xlsx`;
                sheetName = '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà';

                // Header row
                worksheetData.push([
                    `‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà - ${storeName}`,
                    '', '', '', '', '', '', '', ''
                ]);
                worksheetData.push([`‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${today}`, '', '', '', '', '', '', '', '']);
                worksheetData.push([]); // Empty row

                // Column headers
                worksheetData.push([
                    '‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠', '‡∏£‡∏∏‡πà‡∏ô', '‡∏™‡∏µ', 'IMEI', 'RAM', 'ROM',
                    '‡∏ã‡∏∑‡πâ‡∏≠‡∏à‡∏≤‡∏Å', '‡∏´‡∏°‡∏ß‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á', '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡∏∑‡πâ‡∏≠', '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢',
                    '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤', '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏'
                ]);

                // Data rows
                stockData.forEach(item => {
                    worksheetData.push([
                        item.brand || '',
                        item.model || '',
                        item.color || '',
                        item.imei || '',
                        item.ram || '',
                        item.rom || '',
                        item.purchased_from || '',
                        item.device_category || '',
                        parseFloat(item.purchase_price) || 0,
                        parseFloat(item.sale_price) || 0,
                        item.import_date || '',
                        item.note || ''
                    ]);
                });

                // Summary rows
                worksheetData.push([]); // Empty row
                const totalPurchase = stockData.reduce((sum, item) => sum + (parseFloat(item.purchase_price) || 0), 0);
                const totalSale = stockData.reduce((sum, item) => sum + (parseFloat(item.sale_price) || 0), 0);

                worksheetData.push(['‡∏™‡∏£‡∏∏‡∏õ‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°', '', '', '', '', '', '', '', '', '', '', '']);
                worksheetData.push(['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:', stockData.length, '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á', '', '', '', '', '', '', '', '', '']);
                worksheetData.push(['‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏ã‡∏∑‡πâ‡∏≠‡∏£‡∏ß‡∏°:', totalPurchase.toLocaleString(), '‡∏ö‡∏≤‡∏ó', '', '', '', '', '', '', '', '', '']);
                worksheetData.push(['‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≤‡∏¢‡∏£‡∏ß‡∏°:', totalSale.toLocaleString(), '‡∏ö‡∏≤‡∏ó', '', '', '', '', '', '', '', '', '']);
                break;

            case 'used-devices':
                fileName = `‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á_${storeName}_${new Date().toISOString().split('T')[0]}.xlsx`;
                sheetName = '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á';

                worksheetData.push([
                    `‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á - ${storeName}`,
                    '', '', '', '', '', '', '', '', ''
                ]);
                worksheetData.push([`‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${today}`, '', '', '', '', '', '', '', '', '']);
                worksheetData.push([]);

                worksheetData.push([
                    '‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠', '‡∏£‡∏∏‡πà‡∏ô', '‡∏™‡∏µ', 'IMEI', 'RAM', 'ROM',
                    '‡∏™‡∏†‡∏≤‡∏û‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á', '‡∏ã‡∏∑‡πâ‡∏≠‡∏à‡∏≤‡∏Å', '‡∏´‡∏°‡∏ß‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á', '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡∏∑‡πâ‡∏≠',
                    '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢', '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤', '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏'
                ]);

                stockData.forEach(item => {
                    worksheetData.push([
                        item.brand || '',
                        item.model || '',
                        item.color || '',
                        item.imei || '',
                        item.ram || '',
                        item.rom || '',
                        item.device_condition || item.condition || '',
                        item.purchased_from || '',
                        item.device_category || '',
                        parseFloat(item.purchase_price) || 0,
                        parseFloat(item.sale_price) || 0,
                        item.import_date || '',
                        item.note || ''
                    ]);
                });

                worksheetData.push([]);
                const totalPurchaseUsed = stockData.reduce((sum, item) => sum + (parseFloat(item.purchase_price) || 0), 0);
                const totalSaleUsed = stockData.reduce((sum, item) => sum + (parseFloat(item.sale_price) || 0), 0);

                worksheetData.push(['‡∏™‡∏£‡∏∏‡∏õ‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°', '', '', '', '', '', '', '', '', '', '', '', '']);
                worksheetData.push(['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:', stockData.length, '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á', '', '', '', '', '', '', '', '', '', '']);
                worksheetData.push(['‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏ã‡∏∑‡πâ‡∏≠‡∏£‡∏ß‡∏°:', totalPurchaseUsed.toLocaleString(), '‡∏ö‡∏≤‡∏ó', '', '', '', '', '', '', '', '', '', '']);
                worksheetData.push(['‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≤‡∏¢‡∏£‡∏ß‡∏°:', totalSaleUsed.toLocaleString(), '‡∏ö‡∏≤‡∏ó', '', '', '', '', '', '', '', '', '', '']);
                break;

            case 'accessories':
                fileName = `‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà_${storeName}_${new Date().toISOString().split('T')[0]}.xlsx`;
                sheetName = '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà';

                worksheetData.push([
                    `‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà - ${storeName}`,
                    '', '', '', '', ''
                ]);
                worksheetData.push([`‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${today}`, '', '', '', '', '']);
                worksheetData.push([]);

                worksheetData.push([
                    '‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤', '‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà', '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô',
                    '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡∏∑‡πâ‡∏≠', '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢', '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏'
                ]);

                stockData.forEach(item => {
                    worksheetData.push([
                        item.id || item.code || '',
                        item.name || '',
                        item.category || item.type || '',
                        item.quantity || 0,
                        parseFloat(item.cost_price || item.costPrice) || 0,
                        parseFloat(item.sale_price || item.salePrice) || 0,
                        item.note || ''
                    ]);
                });

                worksheetData.push([]);
                const totalQty = stockData.reduce((sum, item) => sum + (parseInt(item.quantity) || 0), 0);
                const totalValue = stockData.reduce((sum, item) =>
                    sum + ((parseInt(item.quantity) || 0) * (parseFloat(item.cost_price || item.costPrice) || 0)), 0
                );

                worksheetData.push(['‡∏™‡∏£‡∏∏‡∏õ‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°', '', '', '', '', '', '']);
                worksheetData.push(['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£:', stockData.length, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£', '', '', '', '']);
                worksheetData.push(['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:', totalQty, '‡∏ä‡∏¥‡πâ‡∏ô', '', '', '', '']);
                worksheetData.push(['‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏£‡∏ß‡∏°:', totalValue.toLocaleString(), '‡∏ö‡∏≤‡∏ó', '', '', '', '']);
                break;

            case 'equipment':
                fileName = `‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå_${storeName}_${new Date().toISOString().split('T')[0]}.xlsx`;
                sheetName = '‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';

                worksheetData.push([
                    `‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå - ${storeName}`,
                    '', '', '', '', ''
                ]);
                worksheetData.push([`‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${today}`, '', '', '', '', '']);
                worksheetData.push([]);

                worksheetData.push([
                    '‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤', '‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå', '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô',
                    '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡∏∑‡πâ‡∏≠', '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢', '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏'
                ]);

                stockData.forEach(item => {
                    worksheetData.push([
                        item.id || item.code || '',
                        item.name || '',
                        item.category || item.type || '',
                        item.quantity || 0,
                        parseFloat(item.cost_price || item.costPrice) || 0,
                        parseFloat(item.sale_price || item.salePrice) || 0,
                        item.note || ''
                    ]);
                });

                worksheetData.push([]);
                const totalQtyEq = stockData.reduce((sum, item) => sum + (parseInt(item.quantity) || 0), 0);
                const totalValueEq = stockData.reduce((sum, item) =>
                    sum + ((parseInt(item.quantity) || 0) * (parseFloat(item.cost_price || item.costPrice) || 0)), 0
                );

                worksheetData.push(['‡∏™‡∏£‡∏∏‡∏õ‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°', '', '', '', '', '', '']);
                worksheetData.push(['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£:', stockData.length, '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£', '', '', '', '']);
                worksheetData.push(['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:', totalQtyEq, '‡∏ä‡∏¥‡πâ‡∏ô', '', '', '', '']);
                worksheetData.push(['‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏£‡∏ß‡∏°:', totalValueEq.toLocaleString(), '‡∏ö‡∏≤‡∏ó', '', '', '', '']);
                break;

            default:
                showNotification('‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', 'error');
                return;
        }

        // Create workbook and worksheet
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(worksheetData);

        // Set column widths
        const colWidths = [];
        for (let i = 0; i < 13; i++) {
            colWidths.push({ wch: 15 });
        }
        ws['!cols'] = colWidths;

        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(wb, ws, sheetName);

        // Generate and download file
        XLSX.writeFile(wb, fileName);

        showNotification(`Export Excel ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${fileName}`, 'success');
    } catch (error) {
        console.error('Error exporting to Excel:', error);
        showNotification('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export Excel', 'error');
    }
}

// ===== EXPORT WRAPPER FUNCTIONS FOR EACH PAGE =====

// Export New Devices Stock
async function exportNewDevicesStock() {
    try {
        const storeName = currentStore === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';

        // Fetch stock data from API
        const allDevices = await API.get(API_ENDPOINTS.newDevices, { store: currentStore });
        const stockData = allDevices.filter(device => device.status === 'stock');

        if (stockData.length === 0) {
            showNotification('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô' + storeName, 'warning');
            return;
        }

        await exportStockToExcel('new-devices', stockData, storeName);
    } catch (error) {
        console.error('Error exporting new devices:', error);
        showNotification('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà', 'error');
    }
}

// Export Used Devices Stock
async function exportUsedDevicesStock() {
    try {
        const storeName = currentStore === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';

        // Fetch stock data from API
        const allDevices = await API.get(API_ENDPOINTS.usedDevices, { store: currentStore });
        const stockData = allDevices.filter(device => device.status === 'stock');

        if (stockData.length === 0) {
            showNotification('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô' + storeName, 'warning');
            return;
        }

        await exportStockToExcel('used-devices', stockData, storeName);
    } catch (error) {
        console.error('Error exporting used devices:', error);
        showNotification('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á', 'error');
    }
}

// Export Accessories Stock
async function exportAccessoriesStock() {
    try {
        const storeName = currentStore === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
        
        // Get current active tab
        const activeTab = currentAccessoryTab || 'battery';
        const tabNames = {
            'battery': '‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà',
            'screen': '‡∏à‡∏≠',
            'charging': '‡πÅ‡∏û‡∏ä‡∏≤‡∏£‡πå‡∏ï',
            'switch': '‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå',
            'flex': '‡∏™‡∏≤‡∏¢‡πÅ‡∏û',
            'speaker': '‡∏•‡∏≥‡πÇ‡∏û‡∏á',
            'outofstock': '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏´‡∏°‡∏î',
            'claim': '‡∏™‡πà‡∏á‡πÄ‡∏Ñ‡∏•‡∏°'
        };

        // Fetch all accessories data
        const allAccessories = await API.get(API_ENDPOINTS.accessories, { store: currentStore });

        // Filter stock data based on active tab
        let stockData = [];
        if (activeTab === 'outofstock') {
            stockData = allAccessories.filter(item => Number(item.quantity) === 0);
        } else if (activeTab === 'claim') {
            stockData = allAccessories.filter(item => (Number(item.claim_quantity) || 0) > 0);
        } else {
            stockData = allAccessories.filter(item => 
                item.type === activeTab && Number(item.quantity) > 0
            );
        }

        if (stockData.length === 0) {
            showNotification(`‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà${tabNames[activeTab] || '‡πÉ‡∏ô‡∏´‡∏°‡∏ß‡∏î‡∏ô‡∏µ‡πâ'}`, 'warning');
            return;
        }

        // Prepare export data
        const exportData = stockData.map((acc, index) => ({
            '‡∏•‡∏≥‡∏î‡∏±‡∏ö': index + 1,
            '‡∏£‡∏´‡∏±‡∏™': acc.code,
            '‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠': acc.brand,
            '‡∏£‡∏∏‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ': acc.models || '-',
            '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô': acc.quantity,
            '‡πÄ‡∏Ñ‡∏•‡∏°': acc.claim_quantity || 0,
            '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô': acc.cost_price || 0,
            '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡πà‡∏≠‡∏°': acc.repair_price || 0,
            '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤': formatDate(acc.import_date),
            '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏': acc.note || '-',
            '‡∏£‡πâ‡∏≤‡∏ô': storeName
        }));

        // Create workbook
        const ws = XLSX.utils.json_to_sheet(exportData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, `‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà${tabNames[activeTab] || ''}`);

        // Set column widths
        ws['!cols'] = [
            { wch: 8 },  // ‡∏•‡∏≥‡∏î‡∏±‡∏ö
            { wch: 15 }, // ‡∏£‡∏´‡∏±‡∏™
            { wch: 15 }, // ‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠
            { wch: 25 }, // ‡∏£‡∏∏‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
            { wch: 10 }, // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô
            { wch: 10 }, // ‡πÄ‡∏Ñ‡∏•‡∏°
            { wch: 12 }, // ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô
            { wch: 12 }, // ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡πà‡∏≠‡∏°
            { wch: 15 }, // ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤
            { wch: 25 }, // ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
            { wch: 10 }  // ‡∏£‡πâ‡∏≤‡∏ô
        ];

        // Generate filename with timestamp
        const timestamp = new Date().toLocaleString('th-TH', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        }).replace(/\//g, '-').replace(',', '');
        
        const filename = `‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà${tabNames[activeTab] || ''}_${storeName}_${timestamp}.xlsx`;

        // Export file
        XLSX.writeFile(wb, filename);
        
        showNotification(`Export ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${stockData.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`, 'success');
    } catch (error) {
        console.error('Error exporting accessories:', error);
        showNotification('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà', 'error');
    }
}

// Export Equipment Stock
async function exportEquipmentStock() {
    try {
        // Fetch all equipment data
        const allEquipment = await API.get(API_ENDPOINTS.equipment);

        // Filter stock data (exclude outofstock)
        const stockData = allEquipment.filter(item =>
            item.quantity > 0 &&
            (item.status || item.category?.toLowerCase()) !== 'outofstock'
        );

        if (stockData.length === 0) {
            showNotification('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Ñ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå', 'warning');
            return;
        }

        await exportStockToExcel('equipment', stockData, '‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå');
    } catch (error) {
        console.error('Error exporting equipment:', error);
        showNotification('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå', 'error');
    }
}

// Export Pawn Stock
async function exportPawnStock() {
    try {
        const storeName = currentStore === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';

        // Fetch all pawn data for current store
        const allPawns = await API.get(API_ENDPOINTS.pawn, { store: currentStore });

        // Filter only active pawns (‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏≠‡∏¢‡∏π‡πà)
        const activePawns = allPawns.filter(pawn => pawn.status === 'active');

        if (activePawns.length === 0) {
            showNotification('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô' + storeName, 'warning');
            return;
        }

        // Prepare data for export
        const exportData = activePawns.map((pawn, index) => ({
            '‡∏•‡∏≥‡∏î‡∏±‡∏ö': index + 1,
            '‡∏ä‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤': pawn.customer_name || pawn.customerName || '-',
            '‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠': pawn.brand || '-',
            '‡∏£‡∏∏‡πà‡∏ô': pawn.model || '-',
            '‡∏™‡∏µ': pawn.color || '-',
            'IMEI': pawn.imei || '-',
            'RAM/ROM': `${pawn.ram || 0}/${pawn.rom || 0} GB`,
            '‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å': pawn.pawn_amount || pawn.pawnAmount || 0,
            '‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢ (%)': pawn.interest || 0,
            '‡∏ß‡∏¥‡∏ò‡∏µ‡∏Ñ‡∏¥‡∏î‡∏î‡∏≠‡∏Å': pawn.interest_collection_method === 'deduct' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å' : '‡πÄ‡∏Å‡πá‡∏ö‡∏î‡∏≠‡∏Å',
            '‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô': pawn.redemption_amount || pawn.redemptionAmount || 0,
            '‡∏ß‡∏±‡∏ô‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á': formatDate(pawn.receive_date || pawn.receiveDate),
            '‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î': formatDate(pawn.due_date || pawn.dueDate),
            '‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏': pawn.note || '-',
            '‡∏£‡πâ‡∏≤‡∏ô': storeName
        }));

        // Create workbook
        const ws = XLSX.utils.json_to_sheet(exportData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, '‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏≠‡∏¢‡∏π‡πà');

        // Set column widths
        ws['!cols'] = [
            { wch: 8 },  // ‡∏•‡∏≥‡∏î‡∏±‡∏ö
            { wch: 20 }, // ‡∏ä‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
            { wch: 12 }, // ‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠
            { wch: 20 }, // ‡∏£‡∏∏‡πà‡∏ô
            { wch: 12 }, // ‡∏™‡∏µ
            { wch: 18 }, // IMEI
            { wch: 12 }, // RAM/ROM
            { wch: 12 }, // ‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å
            { wch: 10 }, // ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢
            { wch: 12 }, // ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Ñ‡∏¥‡∏î‡∏î‡∏≠‡∏Å
            { wch: 12 }, // ‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô
            { wch: 15 }, // ‡∏ß‡∏±‡∏ô‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
            { wch: 15 }, // ‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î
            { wch: 25 }, // ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
            { wch: 10 }  // ‡∏£‡πâ‡∏≤‡∏ô
        ];

        // Generate filename with timestamp
        const timestamp = new Date().toLocaleString('th-TH', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        }).replace(/\//g, '-').replace(',', '');
        
        const filename = `‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å_${storeName}_${timestamp}.xlsx`;

        // Export file
        XLSX.writeFile(wb, filename);
        
        showNotification(`Export ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${activePawns.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`, 'success');
    } catch (error) {
        console.error('Error exporting pawn data:', error);
        showNotification('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ export ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å', 'error');
    }
}

// Show used devices database statistics in console
function showUsedDatabaseStats() {
    console.log('üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á');
    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

    const salayaDevices = usedDevices.filter(d => d.store === 'salaya');
    const klongyongDevices = usedDevices.filter(d => d.store === 'klongyong');

    console.log(`üìç ‡∏£‡πâ‡∏≤‡∏ô‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤: ${salayaDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
    console.log(`   - ‡∏™‡∏ï‡πä‡∏≠‡∏Ñ: ${salayaDevices.filter(d => d.status === 'stock').length}`);
    console.log(`   - ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß: ${salayaDevices.filter(d => d.status === 'sold').length}`);
    console.log(`   - ‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å: ${salayaDevices.filter(d => d.status === 'removed').length}`);

    console.log(`üìç ‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á: ${klongyongDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
    console.log(`   - ‡∏™‡∏ï‡πä‡∏≠‡∏Ñ: ${klongyongDevices.filter(d => d.status === 'stock').length}`);
    console.log(`   - ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß: ${klongyongDevices.filter(d => d.status === 'sold').length}`);
    console.log(`   - ‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å: ${klongyongDevices.filter(d => d.status === 'removed').length}`);

    console.log(`\nüí∞ ‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏™‡∏ï‡πä‡∏≠‡∏Ñ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${formatCurrency(
        usedDevices.filter(d => d.status === 'stock')
            .reduce((sum, d) => sum + d.purchasePrice, 0)
    )}`);

    console.log(`üíµ ‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${formatCurrency(
        usedDevices.filter(d => d.status === 'sold')
            .reduce((sum, d) => sum + d.salePrice, 0)
    )}`);

    console.log(`üìà ‡∏Å‡∏≥‡πÑ‡∏£‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢: ${formatCurrency(
        usedDevices.filter(d => d.status === 'sold')
            .reduce((sum, d) => sum + (d.salePrice - d.purchasePrice), 0)
    )}`);

    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
}

// Add to window for console access
window.resetUsedDevicesDB = resetUsedDevicesDatabase;
window.clearUsedDevicesDB = clearUsedDevicesDatabase;
window.exportUsedDevicesDB = exportUsedDevicesDatabase;
window.showUsedDevicesStats = showUsedDatabaseStats;

// ===== CARD DETAILS DISPLAY (ALL CATEGORIES) =====

let currentCardDetailsPage = 1;
const CARD_ITEMS_PER_PAGE = 20;
let currentCardType = null;

// Show card details based on card type
async function showCardDetails(cardType) {
    currentCardDetailsPage = 1;
    currentCardType = cardType;

    const section = document.getElementById('cardDetailsSection');
    const content = document.getElementById('cardDetailsContent');
    const titleEl = document.getElementById('cardDetailsTitle');

    if (!section || !content) return;

    // Set title
    const titles = {
        'new-devices': 'üì± ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å',
        'used-devices': '‚ôªÔ∏è ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å',
        'repair': 'üîß ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô',
        'installment': 'üí≥ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô',
        'pawn': 'üè¶ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏≠‡∏¢‡∏π‡πà'
    };
    if (titleEl) titleEl.textContent = titles[cardType] || '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î';

    // Show loading
    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    section.style.display = 'block';

    // Scroll to section
    section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    try {
        const items = await getCardDetailsByType(cardType);
        displayCardDetailsItems(items);
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message + '</div>';
        console.error('Error loading card details:', error);
    }
}

// Get card details based on type
async function getCardDetailsByType(cardType) {
    const currentMonth = document.getElementById('monthSelect').value;
    const [currentYear, currentMonthNum] = currentMonth.split('-');

    console.log('Getting card details:', {
        cardType,
        store: currentStore,
        month: currentMonth,
        year: currentYear,
        monthNum: currentMonthNum
    });

    let items = [];

    if (cardType === 'new-devices') {
        // New devices in stock
        const devices = await API.get(API_ENDPOINTS.newDevices, { store: currentStore });
        console.log('New devices from API:', devices.length, 'devices');
        const stockDevices = devices.filter(d => d.status === 'stock');
        console.log('Filtered (stock only):', stockDevices.length, 'devices');
        items = stockDevices.map(d => ({
                id: d.id,
                date: d.import_date || d.importDate,
                name: `${d.brand} ${d.model}`,
                color: d.color,
                specs: `${d.ram}/${d.rom} GB`,
                price: d.purchase_price || d.purchasePrice || 0,
                salePrice: d.sale_price || d.salePrice || 0,
                condition: d.device_condition || d.deviceCondition || '-',
                note: d.note || '-'
            }));
    } else if (cardType === 'used-devices') {
        // Used devices in stock
        const devices = await API.get(API_ENDPOINTS.usedDevices, { store: currentStore });
        items = devices
            .filter(d => d.status === 'stock')
            .map(d => ({
                id: d.id,
                date: d.import_date || d.importDate,
                name: `${d.brand} ${d.model}`,
                color: d.color,
                specs: `${d.ram}/${d.rom} GB`,
                price: d.purchase_price || d.purchasePrice || 0,
                salePrice: d.sale_price || d.salePrice || 0,
                condition: d.device_condition || d.deviceCondition || '-',
                note: d.note || '-'
            }));
    } else if (cardType === 'repair') {
        // Completed repairs in current month
        const repairs = repairDevices || [];
        items = repairs
            .filter(r => r.store === currentStore && r.status === 'completed' && r.completedDate)
            .filter(r => {
                const completedDate = new Date(r.completedDate);
                return completedDate.getFullYear().toString() === currentYear &&
                       (completedDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .map(r => ({
                id: r.id,
                date: r.completedDate,
                name: r.deviceName || `${r.brand || ''} ${r.model || ''}`,
                customer: r.customerName || '-',
                problem: r.problemDescription || '-',
                price: r.repairCost || 0,
                note: r.note || '-'
            }));
    } else if (cardType === 'installment') {
        // Completed installments in current month
        const installments = installmentDevices || [];
        items = installments
            .filter(i => i.store === currentStore && i.status === 'completed' && i.completedDate)
            .filter(i => {
                const completedDate = new Date(i.completedDate);
                return completedDate.getFullYear().toString() === currentYear &&
                       (completedDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .map(i => ({
                id: i.id,
                date: i.completedDate,
                name: `${i.brand} ${i.model}`,
                customer: i.customerName || '-',
                color: i.color,
                specs: `${i.ram}/${i.rom} GB`,
                totalPrice: i.salePrice || 0,
                downPayment: i.downPayment || 0,
                installments: i.installmentCount || 0,
                note: i.note || '-'
            }));
    } else if (cardType === 'pawn') {
        // Active pawn devices
        const pawns = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        console.log('==================== PAWN CARD DETAILS ====================');
        console.log('Current Store:', currentStore);
        console.log('Pawn devices from API:', pawns.length, 'items');
        console.log('All pawn data:', pawns);
        
        // Show status breakdown
        const statusCount = {
            active: pawns.filter(p => p.status === 'active').length,
            returned: pawns.filter(p => p.status === 'returned').length,
            seized: pawns.filter(p => p.status === 'seized').length
        };
        console.log('Status breakdown:', statusCount);
        
        const activePawns = pawns.filter(p => p.status === 'active');
        console.log('Filtered (active only):', activePawns.length, 'items');
        
        if (activePawns.length > 0) {
            console.log('Active pawn details:', activePawns);
        }
        console.log('=========================================================');
        
        items = activePawns.map(p => ({
                id: p.id,
                date: p.receive_date || p.receiveDate,
                customer: p.customer_name || p.customerName || '-',
                name: `${p.brand} ${p.model}`,
                color: p.color,
                specs: `${p.ram}/${p.rom} GB`,
                pawnAmount: p.pawn_amount || p.pawnAmount || 0,
                interest: p.interest || 0,
                dueDate: p.due_date || p.dueDate,
                interestMethod: p.interest_collection_method || p.interestCollectionMethod || 'not_deducted',
                redemptionAmount: p.redemption_amount || p.redemptionAmount || 0,
                note: p.note || '-'
            }));
    }

    // Sort by date (newest first)
    items.sort((a, b) => new Date(b.date) - new Date(a.date));

    return items;
}

// Display card details with pagination
function displayCardDetailsItems(items) {
    const content = document.getElementById('cardDetailsContent');
    const pagination = document.getElementById('cardDetailsPagination');

    if (!content || !pagination) return;

    console.log(`Card details (${currentCardType}):`, {
        totalItems: items.length,
        currentStore: currentStore,
        currentMonth: document.getElementById('monthSelect').value
    });

    if (items.length === 0) {
        let message = '<div class="no-data">';
        message += '<p style="font-size: 1.2rem; margin-bottom: 1rem;">üì≠ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ</p>';
        message += '<p style="color: #9ca3af; font-size: 0.9rem;">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö:</p>';
        message += '<ul style="list-style: none; padding: 0; color: #9ca3af; font-size: 0.9rem;">';
        message += '<li>‚úì ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á</li>';
        
        if (currentCardType === 'repair' || currentCardType === 'installment') {
            message += '<li>‚úì ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô</li>';
        } else if (currentCardType === 'new-devices' || currentCardType === 'used-devices') {
            message += '<li>‚úì ‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà</li>';
        } else if (currentCardType === 'pawn') {
            message += '<li>‚úì ‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà</li>';
        }
        
        message += '</ul></div>';
        content.innerHTML = message;
        pagination.innerHTML = '';
        return;
    }

    // Calculate pagination
    const totalPages = Math.ceil(items.length / CARD_ITEMS_PER_PAGE);
    const startIndex = (currentCardDetailsPage - 1) * CARD_ITEMS_PER_PAGE;
    const endIndex = startIndex + CARD_ITEMS_PER_PAGE;
    const currentItems = items.slice(startIndex, endIndex);

    // Display items
    let html = '<div class="card-details-table">';
    html += '<table>';
    html += '<thead><tr>';

    // Headers based on card type
    if (currentCardType === 'new-devices' || currentCardType === 'used-devices') {
        html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤</th><th>‡∏£‡∏∏‡πà‡∏ô</th><th>‡∏™‡∏µ</th><th>RAM/ROM</th><th>‡∏™‡∏†‡∏≤‡∏û</th><th>‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô</th><th>‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢</th><th>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏</th>';
    } else if (currentCardType === 'repair') {
        html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à</th><th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th><th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th><th>‡∏õ‡∏±‡∏ç‡∏´‡∏≤</th><th>‡∏Ñ‡πà‡∏≤‡∏ã‡πà‡∏≠‡∏°</th><th>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏</th>';
    } else if (currentCardType === 'installment') {
        html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à</th><th>‡∏£‡∏∏‡πà‡∏ô</th><th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th><th>‡∏™‡∏µ</th><th>RAM/ROM</th><th>‡∏£‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ß‡∏°</th><th>‡πÄ‡∏á‡∏¥‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå</th><th>‡∏á‡∏ß‡∏î</th>';
    } else if (currentCardType === 'pawn') {
        html += '<th>‡∏ß‡∏±‡∏ô‡∏£‡∏±‡∏ö</th><th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th><th>‡∏£‡∏∏‡πà‡∏ô</th><th>‡∏™‡∏µ</th><th>RAM/ROM</th><th>‡∏¢‡∏≠‡∏î‡∏ù‡∏≤‡∏Å</th><th>‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</th><th>‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î</th><th>‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô</th>';
    }

    html += '</tr></thead><tbody>';

    currentItems.forEach(item => {
        html += '<tr>';

        if (currentCardType === 'new-devices' || currentCardType === 'used-devices') {
            html += `<td>${formatDate(item.date)}</td>`;
            html += `<td>${item.name}</td>`;
            html += `<td>${item.color}</td>`;
            html += `<td>${item.specs}</td>`;
            html += `<td>${item.condition}</td>`;
            html += `<td>${formatCurrency(item.price)}</td>`;
            html += `<td>${formatCurrency(item.salePrice)}</td>`;
            html += `<td>${item.note}</td>`;
        } else if (currentCardType === 'repair') {
            html += `<td>${formatDate(item.date)}</td>`;
            html += `<td>${item.name}</td>`;
            html += `<td>${item.customer}</td>`;
            html += `<td>${item.problem}</td>`;
            html += `<td class="income">${formatCurrency(item.price)}</td>`;
            html += `<td>${item.note}</td>`;
        } else if (currentCardType === 'installment') {
            html += `<td>${formatDate(item.date)}</td>`;
            html += `<td>${item.name}</td>`;
            html += `<td>${item.customer}</td>`;
            html += `<td>${item.color}</td>`;
            html += `<td>${item.specs}</td>`;
            html += `<td>${formatCurrency(item.totalPrice)}</td>`;
            html += `<td>${formatCurrency(item.downPayment)}</td>`;
            html += `<td>${item.installments} ‡∏á‡∏ß‡∏î</td>`;
        } else if (currentCardType === 'pawn') {
            html += `<td>${formatDate(item.date)}</td>`;
            html += `<td>${item.customer}</td>`;
            html += `<td>${item.name}</td>`;
            html += `<td>${item.color}</td>`;
            html += `<td>${item.specs}</td>`;
            html += `<td>${formatCurrency(item.pawnAmount)}</td>`;
            html += `<td>${formatCurrency(item.interest)}</td>`;
            html += `<td>${formatDate(item.dueDate)}</td>`;
            html += `<td class="income">${formatCurrency(item.redemptionAmount)}</td>`;
        }

        html += '</tr>';
    });

    html += '</tbody></table></div>';
    content.innerHTML = html;

    // Display pagination
    if (totalPages > 1) {
        let paginationHtml = '<div class="pagination-controls">';
        paginationHtml += `<span>‡πÅ‡∏™‡∏î‡∏á ${startIndex + 1}-${Math.min(endIndex, items.length)} ‡∏à‡∏≤‡∏Å ${items.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</span>`;
        paginationHtml += '<div class="pagination-buttons">';

        if (currentCardDetailsPage > 1) {
            paginationHtml += `<button class="btn btn-secondary" onclick="changeCardDetailsPage(${currentCardDetailsPage - 1})">‚Üê ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤</button>`;
        }

        for (let i = 1; i <= totalPages; i++) {
            if (i === currentCardDetailsPage) {
                paginationHtml += `<button class="btn btn-primary">${i}</button>`;
            } else if (i === 1 || i === totalPages || (i >= currentCardDetailsPage - 1 && i <= currentCardDetailsPage + 1)) {
                paginationHtml += `<button class="btn btn-secondary" onclick="changeCardDetailsPage(${i})">${i}</button>`;
            } else if (i === currentCardDetailsPage - 2 || i === currentCardDetailsPage + 2) {
                paginationHtml += `<span>...</span>`;
            }
        }

        if (currentCardDetailsPage < totalPages) {
            paginationHtml += `<button class="btn btn-secondary" onclick="changeCardDetailsPage(${currentCardDetailsPage + 1})">‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‚Üí</button>`;
        }

        paginationHtml += '</div></div>';
        pagination.innerHTML = paginationHtml;
    } else {
        pagination.innerHTML = '';
    }
}

// Change card details page
async function changeCardDetailsPage(page) {
    currentCardDetailsPage = page;
    await showCardDetails(currentCardType);
}

// Close card details
function closeCardDetails() {
    const section = document.getElementById('cardDetailsSection');
    if (section) section.style.display = 'none';
}

// ===== PAWN DETAILS DISPLAY =====

let currentPawnDetailsPage = 1;
const ITEMS_PER_PAGE = 20;

// Show pawn details based on type (income/expense/profit)
async function showPawnDetails(type) {
    currentPawnDetailsPage = 1;

    if (type === 'income') {
        // For income, show both interest and returned sections
        await showPawnInterestDetails();
        await showPawnReturnDetails();
    } else if (type === 'expense') {
        // For expense, show both active and returned sections
        await showPawnExpenseActiveDetails();
        await showPawnExpenseReturnedDetails();
    } else {
        // For profit, use original logic
        const sectionId = 'pawnProfitDetailsSection';
        const contentId = 'pawnProfitDetailsContent';
        const paginationId = 'pawnProfitDetailsPagination';

        const section = document.getElementById(sectionId);
        const content = document.getElementById(contentId);

        if (!section || !content) return;

        content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
        section.style.display = 'block';
        section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

        try {
            const items = await getPawnDetailsByType(type);
            displayPawnDetailsItems(items, contentId, paginationId, type);
        } catch (error) {
            content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>';
            console.error('Error loading pawn details:', error);
        }
    }
}

// Show pawn interest details (‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢)
async function showPawnInterestDetails() {
    const section = document.getElementById('pawnDetailsSection');
    const content = document.getElementById('pawnDetailsContent');
    const pagination = document.getElementById('pawnDetailsPagination');

    if (!section || !content) return;

    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    section.style.display = 'block';
    section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    try {
        const items = await getPawnInterestItems();
        displayPawnDetailsItems(items, 'pawnDetailsContent', 'pawnDetailsPagination', 'income');
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</div>';
        console.error('Error loading interest details:', error);
    }
}

// Show pawn return details (‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô)
async function showPawnReturnDetails() {
    const section = document.getElementById('pawnReturnDetailsSection');
    const content = document.getElementById('pawnReturnDetailsContent');
    const pagination = document.getElementById('pawnReturnDetailsPagination');

    if (!section || !content) return;

    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    section.style.display = 'block';

    try {
        const items = await getPawnReturnItems();
        displayPawnReturnItems(items);
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô</div>';
        console.error('Error loading return details:', error);
    }
}

// Get pawn interest items only
async function getPawnInterestItems() {
    // Use global currentStore and currentMonth variables
    const [year, month] = currentMonth.split('-');
    
    let items = [];
    
    try {
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        const transactions = await API.get('http://localhost:5001/api/pawn-interest', {
            store: currentStore,
            year: year,
            month: month
        });

        if (Array.isArray(transactions)) {
            items = transactions.map(t => {
                const pawn = pawnDevices.find(p => p.id === t.pawn_id);
                return {
                    id: t.pawn_id,
                    date: t.transaction_date,
                    customer: pawn ? (pawn.customer_name || pawn.customerName || '-') : '-',
                    device: pawn ? `${pawn.brand} ${pawn.model}` : '-',
                    amount: parseFloat(t.interest_amount) || 0,
                    type: 'interest',
                    description: t.transaction_type === 'initial_deduction' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢' : '‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢'
                };
            });
        }
    } catch (error) {
        console.error('Error loading interest items:', error);
    }

    items.sort((a, b) => new Date(b.date) - new Date(a.date));
    return items;
}

// Get pawn return items only
async function getPawnReturnItems() {
    // Use global currentStore and currentMonth variables
    console.log('==================== GET PAWN RETURN ITEMS ====================');
    console.log('Current Store:', currentStore);
    console.log('Current Month (raw):', currentMonth);
    
    const [currentYear, currentMonthNum] = currentMonth.split('-');
    console.log('Current Year:', currentYear);
    console.log('Current Month Num:', currentMonthNum);
    
    let items = [];
    
    try {
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        console.log('Total pawn devices from API:', pawnDevices.length);
        
        const returnedAll = pawnDevices.filter(p => p.status === 'returned' && (p.return_date || p.returnDate));
        console.log('Returned items (all):', returnedAll.length);
        
        if (returnedAll.length > 0) {
            console.log('All returned items details:');
            returnedAll.forEach(p => {
                console.log(`  - ID: ${p.id}, Customer: ${p.customer_name || p.customerName}, Return Date: ${p.return_date || p.returnDate}, Redemption: ${p.redemption_amount || p.redemptionAmount}`);
            });
        }
        
        items = pawnDevices
            .filter(p => p.status === 'returned' && (p.return_date || p.returnDate))
            .filter(p => {
                const returnDate = new Date(p.return_date || p.returnDate);
                const matchYear = returnDate.getFullYear().toString() === currentYear;
                const matchMonth = (returnDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
                console.log(`  Checking: ${p.id}, Return Date: ${p.return_date || p.returnDate}, Year Match: ${matchYear}, Month Match: ${matchMonth}`);
                return matchYear && matchMonth;
            })
            .map(p => ({
                id: p.id,
                date: p.return_date || p.returnDate,
                customer: p.customer_name || p.customerName || '-',
                device: `${p.brand} ${p.model}`,
                pawnAmount: parseFloat(p.pawn_amount || p.pawnAmount) || 0,
                interest: parseFloat(p.interest) || 0,
                redemptionAmount: parseFloat(p.redemption_amount || p.redemptionAmount) || 0,
                interestMethod: p.interest_collection_method || p.interestCollectionMethod || 'not_deducted',
                type: 'returned',
                description: '‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô'
            }));
        
        console.log('Filtered returned items in current month:', items.length);
        if (items.length > 0) {
            console.log('Returned items details:');
            items.forEach(item => {
                console.log(`  - ${item.customer}: ${item.device}, Redemption: ${item.redemptionAmount}`);
            });
        }
    } catch (error) {
        console.error('Error loading return items:', error);
    }
    
    console.log('============================================================');

    items.sort((a, b) => new Date(b.date) - new Date(a.date));
    return items;
}

// Display pawn return items
function displayPawnReturnItems(items) {
    const content = document.getElementById('pawnReturnDetailsContent');
    const pagination = document.getElementById('pawnReturnDetailsPagination');

    if (!content) return;

    if (items.length === 0) {
        content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
        if (pagination) pagination.innerHTML = '';
        return;
    }

    // Display items
    let html = '<div class="pawn-details-table">';
    html += '<table>';
    html += '<thead>';
    html += '<tr>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà</th>';
    html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
    html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
    html += '<th>‡∏¢‡∏≠‡∏î‡∏ù‡∏≤‡∏Å</th>';
    html += '<th>‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</th>';
    html += '<th>‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏Å‡πá‡∏ö‡∏î‡∏≠‡∏Å</th>';
    html += '<th>‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô</th>';
    html += '</tr>';
    html += '</thead>';
    html += '<tbody>';

    items.forEach(item => {
        const interestMethodText = item.interestMethod === 'deducted' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å' : '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å';
        
        html += '<tr>';
        html += `<td>${formatDate(item.date)}</td>`;
        html += `<td>${item.customer}</td>`;
        html += `<td>${item.device}</td>`;
        html += `<td>${formatCurrency(item.pawnAmount)}</td>`;
        html += `<td>${formatCurrency(item.interest)}</td>`;
        html += `<td>${interestMethodText}</td>`;
        html += `<td class="income"><strong>${formatCurrency(item.redemptionAmount)}</strong></td>`;
        html += '</tr>';
    });

    html += '</tbody>';
    html += '<tfoot>';
    html += '<tr style="background: #f0fdf4; font-weight: bold;">';
    html += '<td colspan="6" style="text-align: right;">‡∏£‡∏ß‡∏°‡∏¢‡∏≠‡∏î‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô:</td>';
    const totalRedemption = items.reduce((sum, item) => sum + item.redemptionAmount, 0);
    html += `<td class="income"><strong>${formatCurrency(totalRedemption)}</strong></td>`;
    html += '</tr>';
    html += '</tfoot>';
    html += '</table>';
    html += '</div>';

    content.innerHTML = html;
    if (pagination) pagination.innerHTML = '';
}

// Show pawn expense active details (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà)
async function showPawnExpenseActiveDetails() {
    const section = document.getElementById('pawnExpenseActiveDetailsSection');
    const content = document.getElementById('pawnExpenseActiveDetailsContent');
    const pagination = document.getElementById('pawnExpenseActiveDetailsPagination');

    if (!section || !content) return;

    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    section.style.display = 'block';
    section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    try {
        const items = await getPawnExpenseActiveItems();
        displayPawnExpenseActiveItems(items);
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å</div>';
        console.error('Error loading expense active details:', error);
    }
}

// Show pawn expense returned details (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß)
async function showPawnExpenseReturnedDetails() {
    const section = document.getElementById('pawnExpenseReturnedDetailsSection');
    const content = document.getElementById('pawnExpenseReturnedDetailsContent');
    const pagination = document.getElementById('pawnExpenseReturnedDetailsPagination');

    if (!section || !content) return;

    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    section.style.display = 'block';

    try {
        const items = await getPawnExpenseReturnedItems();
        displayPawnExpenseReturnedItems(items);
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô</div>';
        console.error('Error loading expense returned details:', error);
    }
}

// Get pawn expense active items (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà)
async function getPawnExpenseActiveItems() {
    // Use global currentStore and currentMonth variables
    const [currentYear, currentMonthNum] = currentMonth.split('-');
    
    let items = [];
    
    try {
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        
        items = pawnDevices
            .filter(p => p.status === 'active' && (p.receive_date || p.receiveDate))
            .filter(p => {
                const receiveDate = new Date(p.receive_date || p.receiveDate);
                return receiveDate.getFullYear().toString() === currentYear &&
                       (receiveDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .map(p => ({
                id: p.id,
                date: p.receive_date || p.receiveDate,
                customer: p.customer_name || p.customerName || '-',
                device: `${p.brand} ${p.model}`,
                color: p.color,
                specs: `${p.ram}/${p.rom} GB`,
                pawnAmount: parseFloat(p.pawn_amount || p.pawnAmount) || 0,
                interest: parseFloat(p.interest) || 0,
                dueDate: p.due_date || p.dueDate,
                interestMethod: p.interest_collection_method || p.interestCollectionMethod || 'not_deducted',
                redemptionAmount: parseFloat(p.redemption_amount || p.redemptionAmount) || 0,
                note: p.note || '-'
            }));
    } catch (error) {
        console.error('Error loading expense active items:', error);
    }

    items.sort((a, b) => new Date(b.date) - new Date(a.date));
    return items;
}

// Get pawn expense returned items (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß)
async function getPawnExpenseReturnedItems() {
    // Use global currentStore and currentMonth variables
    const [currentYear, currentMonthNum] = currentMonth.split('-');
    
    let items = [];
    
    try {
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        
        items = pawnDevices
            .filter(p => p.status === 'returned' && (p.receive_date || p.receiveDate))
            .filter(p => {
                const receiveDate = new Date(p.receive_date || p.receiveDate);
                return receiveDate.getFullYear().toString() === currentYear &&
                       (receiveDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .map(p => ({
                id: p.id,
                dateReceived: p.receive_date || p.receiveDate,
                dateReturned: p.return_date || p.returnDate,
                customer: p.customer_name || p.customerName || '-',
                device: `${p.brand} ${p.model}`,
                color: p.color,
                specs: `${p.ram}/${p.rom} GB`,
                pawnAmount: parseFloat(p.pawn_amount || p.pawnAmount) || 0,
                interest: parseFloat(p.interest) || 0,
                interestMethod: p.interest_collection_method || p.interestCollectionMethod || 'not_deducted',
                redemptionAmount: parseFloat(p.redemption_amount || p.redemptionAmount) || 0,
                note: p.note || '-'
            }));
    } catch (error) {
        console.error('Error loading expense returned items:', error);
    }

    items.sort((a, b) => new Date(b.dateReceived) - new Date(a.dateReceived));
    return items;
}

// Display pawn expense active items
function displayPawnExpenseActiveItems(items) {
    const content = document.getElementById('pawnExpenseActiveDetailsContent');
    const pagination = document.getElementById('pawnExpenseActiveDetailsPagination');

    if (!content) return;

    if (items.length === 0) {
        content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
        if (pagination) pagination.innerHTML = '';
        return;
    }

    // Display items
    let html = '<div class="pawn-details-table">';
    html += '<table>';
    html += '<thead>';
    html += '<tr>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö</th>';
    html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
    html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
    html += '<th>‡∏™‡∏µ</th>';
    html += '<th>RAM/ROM</th>';
    html += '<th>‡∏¢‡∏≠‡∏î‡∏ù‡∏≤‡∏Å</th>';
    html += '<th>‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</th>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î</th>';
    html += '<th>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏</th>';
    html += '</tr>';
    html += '</thead>';
    html += '<tbody>';

    items.forEach(item => {
        html += '<tr>';
        html += `<td>${formatDate(item.date)}</td>`;
        html += `<td>${item.customer}</td>`;
        html += `<td>${item.device}</td>`;
        html += `<td>${item.color}</td>`;
        html += `<td>${item.specs}</td>`;
        html += `<td class="expense"><strong>${formatCurrency(item.pawnAmount)}</strong></td>`;
        html += `<td>${formatCurrency(item.interest)}</td>`;
        html += `<td>${formatDate(item.dueDate)}</td>`;
        html += `<td>${item.note}</td>`;
        html += '</tr>';
    });

    html += '</tbody>';
    html += '<tfoot>';
    html += '<tr style="background: #fef2f2; font-weight: bold;">';
    html += '<td colspan="5" style="text-align: right;">‡∏£‡∏ß‡∏°‡∏¢‡∏≠‡∏î‡∏à‡πà‡∏≤‡∏¢:</td>';
    const totalPawnAmount = items.reduce((sum, item) => sum + item.pawnAmount, 0);
    html += `<td class="expense"><strong>${formatCurrency(totalPawnAmount)}</strong></td>`;
    html += '<td colspan="3"></td>';
    html += '</tr>';
    html += '</tfoot>';
    html += '</table>';
    html += '</div>';

    content.innerHTML = html;
    if (pagination) pagination.innerHTML = '';
}

// Display pawn expense returned items
function displayPawnExpenseReturnedItems(items) {
    const content = document.getElementById('pawnExpenseReturnedDetailsContent');
    const pagination = document.getElementById('pawnExpenseReturnedDetailsPagination');

    if (!content) return;

    if (items.length === 0) {
        content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
        if (pagination) pagination.innerHTML = '';
        return;
    }

    // Display items
    let html = '<div class="pawn-details-table">';
    html += '<table>';
    html += '<thead>';
    html += '<tr>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö</th>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏∑‡∏ô</th>';
    html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
    html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
    html += '<th>‡∏™‡∏µ</th>';
    html += '<th>RAM/ROM</th>';
    html += '<th>‡∏¢‡∏≠‡∏î‡∏ù‡∏≤‡∏Å</th>';
    html += '<th>‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</th>';
    html += '<th>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏</th>';
    html += '</tr>';
    html += '</thead>';
    html += '<tbody>';

    items.forEach(item => {
        html += '<tr>';
        html += `<td>${formatDate(item.dateReceived)}</td>`;
        html += `<td><span style="color: #059669; font-weight: 600;">${formatDate(item.dateReturned)}</span></td>`;
        html += `<td>${item.customer}</td>`;
        html += `<td>${item.device}</td>`;
        html += `<td>${item.color}</td>`;
        html += `<td>${item.specs}</td>`;
        html += `<td class="expense"><strong>${formatCurrency(item.pawnAmount)}</strong></td>`;
        html += `<td>${formatCurrency(item.interest)}</td>`;
        html += `<td>${item.note}</td>`;
        html += '</tr>';
    });

    html += '</tbody>';
    html += '<tfoot>';
    html += '<tr style="background: #fef2f2; font-weight: bold;">';
    html += '<td colspan="6" style="text-align: right;">‡∏£‡∏ß‡∏°‡∏¢‡∏≠‡∏î‡∏à‡πà‡∏≤‡∏¢:</td>';
    const totalPawnAmount = items.reduce((sum, item) => sum + item.pawnAmount, 0);
    html += `<td class="expense"><strong>${formatCurrency(totalPawnAmount)}</strong></td>`;
    html += '<td colspan="2"></td>';
    html += '</tr>';
    html += '</tfoot>';
    html += '</table>';
    html += '</div>';

    content.innerHTML = html;
    if (pagination) pagination.innerHTML = '';
}

// ==================== INSTALLMENT DETAILS FUNCTIONS ====================

// Show installment details
async function showInstallmentDetails(type) {
    const section = document.getElementById('installmentDetailsSection');
    const content = document.getElementById('installmentDetailsContent');
    const pagination = document.getElementById('installmentDetailsPagination');

    if (!section || !content) return;

    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    section.style.display = 'block';
    section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

    try {
        const items = await getInstallmentItems();
        displayInstallmentDetailsItems(items);
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô</div>';
        console.error('Error loading installment details:', error);
    }
}

// Get installment items (completed in current month)
async function getInstallmentItems() {
    // Use global currentStore and currentMonth variables
    const [currentYear, currentMonthNum] = currentMonth.split('-');

    let items = [];

    try {
        const installmentDevices = await API.get(API_ENDPOINTS.installment, { store: currentStore });

        items = installmentDevices
            .filter(i => i.status === 'completed' && (i.completed_date || i.completedDate))
            .filter(i => {
                const completedDate = new Date(i.completed_date || i.completedDate);
                return completedDate.getFullYear().toString() === currentYear &&
                       (completedDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .map(i => {
                const salePrice = parseFloat(i.sale_price || i.salePrice) || 0;
                const commission = parseFloat(i.commission) || 0;
                const installmentType = i.installment_type || i.installmentType || 'partner';

                // Calculate total income based on type
                const totalIncome = installmentType === 'partner' ? salePrice + commission : salePrice;

                return {
                    id: i.id,
                    date: i.completed_date || i.completedDate,
                    customer: i.customer_name || i.customerName || '-',
                    device: `${i.brand} ${i.model}`,
                    installmentType: installmentType,
                    salePrice: salePrice,
                    commission: commission,
                    totalIncome: totalIncome
                };
            });
    } catch (error) {
        console.error('Error loading installment items:', error);
    }

    items.sort((a, b) => new Date(b.date) - new Date(a.date));
    return items;
}

// Display installment details items
function displayInstallmentDetailsItems(items) {
    const content = document.getElementById('installmentDetailsContent');
    const pagination = document.getElementById('installmentDetailsPagination');

    if (!content) return;

    if (items.length === 0) {
        content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ä‡∏≥‡∏£‡∏∞‡∏Ñ‡∏£‡∏ö‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
        if (pagination) pagination.innerHTML = '';
        return;
    }

    // Display items
    let html = '<div class="pawn-details-table">';
    html += '<table>';
    html += '<thead>';
    html += '<tr>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà</th>';
    html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
    html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
    html += '<th>‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</th>';
    html += '<th>‡∏¢‡∏≠‡∏î‡∏à‡∏±‡∏î</th>';
    html += '<th>‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°</th>';
    html += '<th>‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏£‡∏ß‡∏°</th>';
    html += '</tr>';
    html += '</thead>';
    html += '<tbody>';

    items.forEach(item => {
        const typeText = item.installmentType === 'store' ? '‡∏£‡πâ‡∏≤‡∏ô' : 'Partner';
        const typeBadge = item.installmentType === 'store' ?
            '<span class="badge badge-success">‡∏£‡πâ‡∏≤‡∏ô</span>' :
            '<span class="badge badge-primary">Partner</span>';

        html += '<tr>';
        html += `<td>${formatDate(item.date)}</td>`;
        html += `<td>${item.customer}</td>`;
        html += `<td>${item.device}</td>`;
        html += `<td>${typeBadge}</td>`;
        html += `<td>${formatCurrency(item.salePrice)}</td>`;
        html += `<td>${item.installmentType === 'partner' ? formatCurrency(item.commission) : '-'}</td>`;
        html += `<td class="income"><strong>${formatCurrency(item.totalIncome)}</strong></td>`;
        html += '</tr>';
    });

    html += '</tbody>';
    html += '<tfoot>';
    html += '<tr style="background: #f0fdf4; font-weight: bold;">';
    html += '<td colspan="6" style="text-align: right;">‡∏£‡∏ß‡∏°‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö:</td>';
    const totalIncome = items.reduce((sum, item) => sum + item.totalIncome, 0);
    html += `<td class="income"><strong>${formatCurrency(totalIncome)}</strong></td>`;
    html += '</tr>';
    html += '</tfoot>';
    html += '</table>';
    html += '</div>';

    content.innerHTML = html;
    if (pagination) pagination.innerHTML = '';
}

// ==================== NEW FULL PAGE DETAIL FUNCTIONS ====================

// Load Installment Income Detail Page
async function loadInstallmentIncomeDetailPage() {
    const content = document.getElementById('installmentIncomeDetailContent');
    
    if (!content) return;
    
    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    
    try {
        const items = await getInstallmentItems();
        displayInstallmentIncomeDetailPageContent(items);
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô</div>';
        console.error('Error loading installment income detail page:', error);
    }
}

// Display Installment Income Detail Page Content
function displayInstallmentIncomeDetailPageContent(items) {
    const content = document.getElementById('installmentIncomeDetailContent');
    
    if (!content) return;
    
    if (items.length === 0) {
        content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ä‡∏≥‡∏£‡∏∞‡∏Ñ‡∏£‡∏ö‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
        return;
    }
    
    // Display items
    let html = '<div class="detail-table-container">';
    html += '<table class="detail-table">';
    html += '<thead>';
    html += '<tr>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà</th>';
    html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
    html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
    html += '<th>‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó</th>';
    html += '<th>‡∏¢‡∏≠‡∏î‡∏à‡∏±‡∏î</th>';
    html += '<th>‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°</th>';
    html += '<th>‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏£‡∏ß‡∏°</th>';
    html += '</tr>';
    html += '</thead>';
    html += '<tbody>';
    
    items.forEach(item => {
        const typeBadge = item.installmentType === 'store' ?
            '<span class="badge badge-success">‡∏£‡πâ‡∏≤‡∏ô</span>' :
            '<span class="badge badge-primary">Partner</span>';
        
        html += '<tr>';
        html += `<td>${formatDate(item.date)}</td>`;
        html += `<td>${item.customer}</td>`;
        html += `<td>${item.device}</td>`;
        html += `<td>${typeBadge}</td>`;
        html += `<td>${formatCurrency(item.salePrice)}</td>`;
        html += `<td>${item.installmentType === 'partner' ? formatCurrency(item.commission) : '-'}</td>`;
        html += `<td class="income"><strong>${formatCurrency(item.totalIncome)}</strong></td>`;
        html += '</tr>';
    });
    
    html += '</tbody>';
    html += '<tfoot>';
    html += '<tr style="background: #f0fdf4; font-weight: bold;">';
    html += '<td colspan="6" style="text-align: right;">‡∏£‡∏ß‡∏°‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö:</td>';
    const totalIncome = items.reduce((sum, item) => sum + item.totalIncome, 0);
    html += `<td class="income"><strong>${formatCurrency(totalIncome)}</strong></td>`;
    html += '</tr>';
    html += '</tfoot>';
    html += '</table>';
    html += '</div>';
    
    content.innerHTML = html;
}

// Load Pawn Income Breakdown Detail Page
async function loadPawnIncomeBreakdownDetailPage() {
    console.log('üîç Loading Pawn Income Breakdown Detail Page');
    
    try {
        // Load both deducted and returned pawn details
        await loadPawnIncomeBreakdownDeducted();
        await loadPawnIncomeBreakdownReturn();
    } catch (error) {
        console.error('Error loading pawn income breakdown detail page:', error);
    }
}

// Load deducted pawn details for breakdown page
async function loadPawnIncomeBreakdownDeducted() {
    const content = document.getElementById('pawnIncomeBreakdownDeductedContent');
    const totalElement = document.getElementById('pawnIncomeBreakdownDeductedTotal');
    
    if (!content) return;
    
    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    
    try {
        const [currentYear, currentMonthNum] = currentMonth.split('-');
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        
        // Filter: received this month and has interest deducted
        const deductedPawns = pawnDevices
            .filter(p => p.receive_date || p.receiveDate)
            .filter(p => {
                const receiveDate = new Date(p.receive_date || p.receiveDate);
                return receiveDate.getFullYear().toString() === currentYear &&
                       (receiveDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .filter(p => (p.interest || 0) > 0)
            .sort((a, b) => new Date(b.receive_date || b.receiveDate) - new Date(a.receive_date || a.receiveDate));
        
        const totalInterest = deductedPawns.reduce((sum, p) => sum + (p.interest || 0), 0);
        
        if (totalElement) {
            totalElement.textContent = formatCurrency(totalInterest);
        }
        
        if (deductedPawns.length === 0) {
            content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>';
            return;
        }
        
        let html = '<div class="detail-table-container">';
        html += '<table class="detail-table">';
        html += '<thead>';
        html += '<tr>';
        html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å</th>';
        html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
        html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
        html += '<th>‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</th>';
        html += '<th>‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞</th>';
        html += '</tr>';
        html += '</thead>';
        html += '<tbody>';
        
        deductedPawns.forEach(pawn => {
            const receiveDate = formatDate(pawn.receive_date || pawn.receiveDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const interest = pawn.interest || 0;
            let statusBadge = '<span class="badge badge-warning">‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô</span>';
            if (pawn.status === 'returned') statusBadge = '<span class="badge badge-success">‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß</span>';
            if (pawn.status === 'seized') statusBadge = '<span class="badge badge-danger">‡∏¢‡∏∂‡∏î‡πÅ‡∏•‡πâ‡∏ß</span>';
            
            html += '<tr>';
            html += `<td>${receiveDate}</td>`;
            html += `<td>${customerName}</td>`;
            html += `<td>${deviceInfo}</td>`;
            html += `<td class="income"><strong>${formatCurrency(interest)}</strong></td>`;
            html += `<td>${statusBadge}</td>`;
            html += '</tr>';
        });
        
        html += '</tbody>';
        html += '</table>';
        html += '</div>';
        
        content.innerHTML = html;
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î</div>';
        console.error('Error loading pawn income deducted:', error);
    }
}

// Load returned pawn details for breakdown page
async function loadPawnIncomeBreakdownReturn() {
    const content = document.getElementById('pawnIncomeBreakdownReturnContent');
    const totalElement = document.getElementById('pawnIncomeBreakdownReturnTotal');
    
    if (!content) return;
    
    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    
    try {
        const [currentYear, currentMonthNum] = currentMonth.split('-');
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        
        // Filter: returned this month
        const returnedPawns = pawnDevices
            .filter(p => p.status === 'returned')
            .filter(p => p.return_date || p.returnDate)
            .filter(p => {
                const returnDate = new Date(p.return_date || p.returnDate);
                return returnDate.getFullYear().toString() === currentYear &&
                       (returnDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .sort((a, b) => new Date(b.return_date || b.returnDate) - new Date(a.return_date || a.returnDate));
        
        const totalReturnIncome = returnedPawns.reduce((sum, p) => {
            const interest = parseFloat(p.interest) || 0;
            const additionalInterest = parseFloat(p.additional_interest || p.additionalInterest) || 0;
            const lateFee = parseFloat(p.late_fee || p.lateFee) || 0;
            return sum + interest + additionalInterest + lateFee;
        }, 0);
        
        if (totalElement) {
            totalElement.textContent = formatCurrency(totalReturnIncome);
        }
        
        if (returnedPawns.length === 0) {
            content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>';
            return;
        }
        
        let html = '<div class="detail-table-container">';
        html += '<table class="detail-table">';
        html += '<thead>';
        html += '<tr>';
        html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô</th>';
        html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
        html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
        html += '<th>‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</th>';
        html += '<th>‡∏î‡∏≠‡∏Å‡∏ï‡πà‡∏≠</th>';
        html += '<th>‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö</th>';
        html += '<th>‡∏£‡∏ß‡∏°</th>';
        html += '</tr>';
        html += '</thead>';
        html += '<tbody>';
        
        returnedPawns.forEach(pawn => {
            const returnDate = formatDate(pawn.return_date || pawn.returnDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const interest = parseFloat(pawn.interest) || 0;
            const additionalInterest = parseFloat(pawn.additional_interest || pawn.additionalInterest) || 0;
            const lateFee = parseFloat(pawn.late_fee || pawn.lateFee) || 0;
            const total = interest + additionalInterest + lateFee;
            
            html += '<tr>';
            html += `<td>${returnDate}</td>`;
            html += `<td>${customerName}</td>`;
            html += `<td>${deviceInfo}</td>`;
            html += `<td>${formatCurrency(interest)}</td>`;
            html += `<td>${formatCurrency(additionalInterest)}</td>`;
            html += `<td>${formatCurrency(lateFee)}</td>`;
            html += `<td class="income"><strong>${formatCurrency(total)}</strong></td>`;
            html += '</tr>';
        });
        
        html += '</tbody>';
        html += '</table>';
        html += '</div>';
        
        content.innerHTML = html;
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î</div>';
        console.error('Error loading pawn income return:', error);
    }
}

// Load Pawn Expense Breakdown Detail Page
async function loadPawnExpenseBreakdownDetailPage() {
    console.log('üîç Loading Pawn Expense Breakdown Detail Page');
    
    try {
        await loadPawnExpenseBreakdownActive();
        await loadPawnExpenseBreakdownReturn();
    } catch (error) {
        console.error('Error loading pawn expense breakdown detail page:', error);
    }
}

// Load active pawn expenses for breakdown page
async function loadPawnExpenseBreakdownActive() {
    const content = document.getElementById('pawnExpenseBreakdownActiveContent');
    const totalElement = document.getElementById('pawnExpenseBreakdownActiveTotal');
    
    if (!content) return;
    
    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    
    try {
        const [currentYear, currentMonthNum] = currentMonth.split('-');
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        
        // Filter: received (pawn_date) this month
        const activePawns = pawnDevices
            .filter(p => p.receive_date || p.receiveDate)
            .filter(p => {
                const receiveDate = new Date(p.receive_date || p.receiveDate);
                return receiveDate.getFullYear().toString() === currentYear &&
                       (receiveDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .sort((a, b) => new Date(b.receive_date || b.receiveDate) - new Date(a.receive_date || a.receiveDate));
        
        const totalExpense = activePawns.reduce((sum, p) => sum + (parseFloat(p.pawn_amount || p.pawnAmount) || 0), 0);
        
        if (totalElement) {
            totalElement.textContent = formatCurrency(totalExpense);
        }
        
        if (activePawns.length === 0) {
            content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>';
            return;
        }
        
        let html = '<div class="detail-table-container">';
        html += '<table class="detail-table">';
        html += '<thead>';
        html += '<tr>';
        html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å</th>';
        html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
        html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
        html += '<th>‡∏¢‡∏≠‡∏î‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å</th>';
        html += '<th>‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞</th>';
        html += '</tr>';
        html += '</thead>';
        html += '<tbody>';
        
        activePawns.forEach(pawn => {
            const receiveDate = formatDate(pawn.receive_date || pawn.receiveDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const pawnAmount = parseFloat(pawn.pawn_amount || pawn.pawnAmount) || 0;
            let statusBadge = '<span class="badge badge-warning">‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô</span>';
            if (pawn.status === 'returned') statusBadge = '<span class="badge badge-success">‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß</span>';
            if (pawn.status === 'seized') statusBadge = '<span class="badge badge-danger">‡∏¢‡∏∂‡∏î‡πÅ‡∏•‡πâ‡∏ß</span>';
            
            html += '<tr>';
            html += `<td>${receiveDate}</td>`;
            html += `<td>${customerName}</td>`;
            html += `<td>${deviceInfo}</td>`;
            html += `<td class="expense"><strong>${formatCurrency(pawnAmount)}</strong></td>`;
            html += `<td>${statusBadge}</td>`;
            html += '</tr>';
        });
        
        html += '</tbody>';
        html += '</table>';
        html += '</div>';
        
        content.innerHTML = html;
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î</div>';
        console.error('Error loading pawn expense active:', error);
    }
}

// Load returned pawn expenses for breakdown page
async function loadPawnExpenseBreakdownReturn() {
    const content = document.getElementById('pawnExpenseBreakdownReturnContent');
    const totalElement = document.getElementById('pawnExpenseBreakdownReturnTotal');
    
    if (!content) return;
    
    content.innerHTML = '<div class="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>';
    
    try {
        const [currentYear, currentMonthNum] = currentMonth.split('-');
        const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        
        // Filter: returned this month
        const returnedPawns = pawnDevices
            .filter(p => p.status === 'returned')
            .filter(p => p.return_date || p.returnDate)
            .filter(p => {
                const returnDate = new Date(p.return_date || p.returnDate);
                return returnDate.getFullYear().toString() === currentYear &&
                       (returnDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .sort((a, b) => new Date(b.return_date || b.returnDate) - new Date(a.return_date || a.returnDate));
        
        const totalExpense = returnedPawns.reduce((sum, p) => sum + (parseFloat(p.pawn_amount || p.pawnAmount) || 0), 0);
        
        if (totalElement) {
            totalElement.textContent = formatCurrency(totalExpense);
        }
        
        if (returnedPawns.length === 0) {
            content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>';
            return;
        }
        
        let html = '<div class="detail-table-container">';
        html += '<table class="detail-table">';
        html += '<thead>';
        html += '<tr>';
        html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô</th>';
        html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
        html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
        html += '<th>‡∏¢‡∏≠‡∏î‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å</th>';
        html += '</tr>';
        html += '</thead>';
        html += '<tbody>';
        
        returnedPawns.forEach(pawn => {
            const returnDate = formatDate(pawn.return_date || pawn.returnDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const pawnAmount = parseFloat(pawn.pawn_amount || pawn.pawnAmount) || 0;
            
            html += '<tr>';
            html += `<td>${returnDate}</td>`;
            html += `<td>${customerName}</td>`;
            html += `<td>${deviceInfo}</td>`;
            html += `<td class="expense"><strong>${formatCurrency(pawnAmount)}</strong></td>`;
            html += '</tr>';
        });
        
        html += '</tbody>';
        html += '</table>';
        html += '</div>';
        
        content.innerHTML = html;
    } catch (error) {
        content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î</div>';
        console.error('Error loading pawn expense return:', error);
    }
}

// Load Pawn Profit Breakdown Detail Page
async function loadPawnProfitBreakdownDetailPage() {
    console.log('üîç Loading Pawn Profit Breakdown Detail Page');
    
    try {
        // Initialize date filters
        initializePawnProfitDateFilters();

        // Get selected month and year
        const monthSelect = document.getElementById('pawnProfitMonth');
        const yearSelect = document.getElementById('pawnProfitYear');
        const selectedMonth = monthSelect ? monthSelect.value : new Date().getMonth() + 1;
        const selectedYear = yearSelect ? yearSelect.value : new Date().getFullYear();

        // Load pawn devices and interest transactions
        const pawnDevices = await API.get(API_ENDPOINTS.pawn);
        const interestTransactions = await API.get('http://localhost:5001/api/pawn-interest');

        console.log('üìä Loaded data:', {
            pawnDevices: pawnDevices.length,
            interestTransactions: interestTransactions.length,
            selectedMonth,
            selectedYear
        });

        // Filter transactions by selected month/year
        const filteredTransactions = interestTransactions.filter(t => {
            const transactionDate = new Date(t.transaction_date || t.transactionDate);
            return transactionDate.getMonth() + 1 === parseInt(selectedMonth) &&
                   transactionDate.getFullYear() === parseInt(selectedYear);
        });

        console.log('üìã Filtered transactions:', filteredTransactions.length);

        // Separate by transaction type
        const deductedTransactions = filteredTransactions.filter(t => t.transaction_type === 'initial_deduction');
        const renewalTransactions = filteredTransactions.filter(t => t.transaction_type === 'renewal');

        // Calculate totals
        const deductedTotal = deductedTransactions.reduce((sum, t) => sum + (parseFloat(t.interest_amount) || 0), 0);
        const renewalTotal = renewalTransactions.reduce((sum, t) => sum + (parseFloat(t.interest_amount) || 0), 0);
        const totalIncome = deductedTotal + renewalTotal;
        const totalProfit = totalIncome; // For pawn, profit = income (no cost)
        
        // Update summary cards
        document.getElementById('pawnProfitBreakdownIncome').textContent = formatCurrency(totalIncome);
        document.getElementById('pawnProfitBreakdownExpense').textContent = formatCurrency(0);
        document.getElementById('pawnProfitBreakdownTotal').textContent = formatCurrency(totalProfit);
        
        // Build detailed content
        const content = document.getElementById('pawnProfitBreakdownContent');
        if (!content) return;

        let html = '';

        // Summary section
        html += '<div class="profit-summary-detail">';
        html += '<h3>‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≥‡πÑ‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å</h3>';
            html += '<div class="summary-grid">';
            html += '<div class="summary-item">';
        html += '<p class="summary-label">üí∞ ‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</p>';
        html += `<p class="summary-value income">${formatCurrency(deductedTotal)}</p>`;
        html += `<p class="summary-count">(${deductedTransactions.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)</p>`;
            html += '</div>';
            html += '<div class="summary-item">';
        html += '<p class="summary-label">üîÑ ‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</p>';
        html += `<p class="summary-value income">${formatCurrency(renewalTotal)}</p>`;
        html += `<p class="summary-count">(${renewalTransactions.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)</p>`;
            html += '</div>';
            html += '</div>';
            html += '</div>';

        // Deducted interest list
        if (deductedTransactions.length > 0) {
            html += '<div class="detail-section" style="margin-top: 30px;">';
            html += '<h4>üí∞ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</h4>';
            html += '<div class="detail-table-container">';
            html += '<table class="detail-table">';
            html += '<thead><tr>';
            html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà</th>';
            html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
            html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
            html += '<th>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô</th>';
            html += '</tr></thead>';
            html += '<tbody>';

            // Sort by date (newest first)
            deductedTransactions.sort((a, b) => new Date(b.transaction_date) - new Date(a.transaction_date));

            deductedTransactions.forEach(t => {
                const pawn = pawnDevices.find(p => p.id === t.pawn_id);
                const customerName = pawn ? (pawn.customer_name || pawn.customerName || '-') : '-';
                const device = pawn ? `${pawn.brand} ${pawn.model}` : '-';
                const amount = parseFloat(t.interest_amount) || 0;

                html += '<tr>';
                html += `<td>${formatDate(t.transaction_date)}</td>`;
                html += `<td>${customerName}</td>`;
                html += `<td>${device}</td>`;
                html += `<td class="income"><strong>${formatCurrency(amount)}</strong></td>`;
                html += '</tr>';
            });

            html += '</tbody>';
            html += `<tfoot><tr><td colspan="3" style="text-align: right;"><strong>‡∏£‡∏ß‡∏°:</strong></td><td class="income"><strong>${formatCurrency(deductedTotal)}</strong></td></tr></tfoot>`;
            html += '</table>';
            html += '</div>';
            html += '</div>';
        }

        // Renewal interest list
        if (renewalTransactions.length > 0) {
            html += '<div class="detail-section" style="margin-top: 30px;">';
            html += '<h4>üîÑ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢</h4>';
            html += '<div class="detail-table-container">';
            html += '<table class="detail-table">';
            html += '<thead><tr>';
            html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà</th>';
            html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
            html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
            html += '<th>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô</th>';
            html += '</tr></thead>';
            html += '<tbody>';

            // Sort by date (newest first)
            renewalTransactions.sort((a, b) => new Date(b.transaction_date) - new Date(a.transaction_date));

            renewalTransactions.forEach(t => {
                const pawn = pawnDevices.find(p => p.id === t.pawn_id);
                const customerName = pawn ? (pawn.customer_name || pawn.customerName || '-') : '-';
                const device = pawn ? `${pawn.brand} ${pawn.model}` : '-';
                const amount = parseFloat(t.interest_amount) || 0;

                html += '<tr>';
                html += `<td>${formatDate(t.transaction_date)}</td>`;
                html += `<td>${customerName}</td>`;
                html += `<td>${device}</td>`;
                html += `<td class="income"><strong>${formatCurrency(amount)}</strong></td>`;
                html += '</tr>';
            });

            html += '</tbody>';
            html += `<tfoot><tr><td colspan="3" style="text-align: right;"><strong>‡∏£‡∏ß‡∏°:</strong></td><td class="income"><strong>${formatCurrency(renewalTotal)}</strong></td></tr></tfoot>`;
            html += '</table>';
            html += '</div>';
            html += '</div>';
        }

        // No data message
        if (deductedTransactions.length === 0 && renewalTransactions.length === 0) {
            html += '<div class="no-data" style="margin-top: 30px;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
        }

        content.innerHTML = html;

    } catch (error) {
        console.error('Error loading pawn profit breakdown detail page:', error);
        const content = document.getElementById('pawnProfitBreakdownContent');
        if (content) {
            content.innerHTML = '<div class="error">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>';
        }
    }
}

// Initialize date filters for pawn profit page
function initializePawnProfitDateFilters() {
    const monthSelect = document.getElementById('pawnProfitMonth');
    const yearSelect = document.getElementById('pawnProfitYear');

    if (!monthSelect || !yearSelect) return;

    // Only initialize if empty
    if (monthSelect.options.length === 0) {
        const thaiMonths = [
            '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
            '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'
        ];

        thaiMonths.forEach((month, index) => {
            const option = document.createElement('option');
            option.value = index + 1;
            option.textContent = month;
            monthSelect.appendChild(option);
        });

        // Set current month
        monthSelect.value = new Date().getMonth() + 1;
    }

    if (yearSelect.options.length === 0) {
        const currentYear = new Date().getFullYear();
        for (let year = currentYear; year >= currentYear - 5; year--) {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = `${year + 543}`; // Thai Buddhist year
            yearSelect.appendChild(option);
        }

        // Set current year
        yearSelect.value = currentYear;
    }
}

// Get pawn details based on type
async function getPawnDetailsByType(type) {
    const currentMonth = document.getElementById('monthSelect').value;
    const [currentYear, currentMonthNum] = currentMonth.split('-');

    let items = [];

    // Get pawn devices
    const pawnDevices = await API.get(API_ENDPOINTS.pawn, { store: currentStore });

    if (type === 'expense') {
        // Expense: pawn_amount when receive_date in current month
        items = pawnDevices
            .filter(p => p.receive_date || p.receiveDate)
            .filter(p => {
                const receiveDate = new Date(p.receive_date || p.receiveDate);
                return receiveDate.getFullYear().toString() === currentYear &&
                       (receiveDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .map(p => ({
                id: p.id,
                date: p.receive_date || p.receiveDate,
                customer: p.customer_name || p.customerName || '-',
                device: `${p.brand} ${p.model}`,
                amount: p.pawn_amount || p.pawnAmount || 0,
                type: 'expense',
                description: '‡∏à‡πà‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤'
            }));
    } else if (type === 'income') {
        // Income: interest + returned amount

        // 1. Get interest transactions
        try {
            const [year, month] = currentMonth.split('-');
            const transactions = await API.get('http://localhost:5001/api/pawn-interest', {
                store: currentStore,
                year: year,
                month: month
            });

            if (Array.isArray(transactions)) {
                const interestItems = transactions.map(t => {
                    const pawn = pawnDevices.find(p => p.id === t.pawn_id);
                    return {
                        id: t.pawn_id,
                        date: t.transaction_date,
                        customer: pawn ? (pawn.customer_name || pawn.customerName || '-') : '-',
                        device: pawn ? `${pawn.brand} ${pawn.model}` : '-',
                        amount: parseFloat(t.interest_amount) || 0,
                        type: 'interest',
                        description: t.transaction_type === 'initial_deduction' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢' : '‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢'
                    };
                });
                items.push(...interestItems);
            }
        } catch (error) {
            console.error('Error loading interest transactions:', error);
        }

        // 2. Get returned devices
        const returnedItems = pawnDevices
            .filter(p => p.status === 'returned' && (p.return_date || p.returnDate))
            .filter(p => {
                const returnDate = new Date(p.return_date || p.returnDate);
                return returnDate.getFullYear().toString() === currentYear &&
                       (returnDate.getMonth() + 1).toString().padStart(2, '0') === currentMonthNum;
            })
            .map(p => ({
                id: p.id,
                date: p.return_date || p.returnDate,
                customer: p.customer_name || p.customerName || '-',
                device: `${p.brand} ${p.model}`,
                amount: p.pawn_amount || p.pawnAmount || 0,
                type: 'returned',
                description: '‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡∏à‡∏≤‡∏Å‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤'
            }));

        items.push(...returnedItems);
    } else if (type === 'profit') {
        // Profit: show both income and expense

        // Get income items first
        const incomeItems = await getPawnDetailsByType('income');
        const expenseItems = await getPawnDetailsByType('expense');

        items = [...incomeItems, ...expenseItems];
    }

    // Sort by date (newest first)
    items.sort((a, b) => new Date(b.date) - new Date(a.date));

    return items;
}

// Display pawn details with pagination
function displayPawnDetailsItems(items, contentId, paginationId, type) {
    const content = document.getElementById(contentId);
    const pagination = document.getElementById(paginationId);

    if (!content || !pagination) return;

    if (items.length === 0) {
        content.innerHTML = '<div class="no-data">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</div>';
        pagination.innerHTML = '';
        return;
    }

    // Calculate pagination
    const totalPages = Math.ceil(items.length / ITEMS_PER_PAGE);
    const startIndex = (currentPawnDetailsPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const currentItems = items.slice(startIndex, endIndex);

    // Display items
    let html = '<div class="pawn-details-table">';
    html += '<table>';
    html += '<thead>';
    html += '<tr>';
    html += '<th>‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà</th>';
    html += '<th>‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤</th>';
    html += '<th>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</th>';
    html += '<th>‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</th>';
    html += '<th>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô</th>';
    html += '</tr>';
    html += '</thead>';
    html += '<tbody>';

    currentItems.forEach(item => {
        const typeClass = item.type === 'expense' ? 'expense' : 'income';
        const typeIcon = item.type === 'expense' ? 'üì§' : 'üì•';

        html += '<tr>';
        html += `<td>${formatDate(item.date)}</td>`;
        html += `<td>${item.customer}</td>`;
        html += `<td>${item.device}</td>`;
        html += `<td>${typeIcon} ${item.description}</td>`;
        html += `<td class="${typeClass}">${formatCurrency(item.amount)}</td>`;
        html += '</tr>';
    });

    html += '</tbody>';
    html += '</table>';
    html += '</div>';

    content.innerHTML = html;

    // Display pagination
    if (totalPages > 1) {
        let paginationHtml = '<div class="pagination-controls">';
        paginationHtml += `<span>‡πÅ‡∏™‡∏î‡∏á ${startIndex + 1}-${Math.min(endIndex, items.length)} ‡∏à‡∏≤‡∏Å ${items.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</span>`;
        paginationHtml += '<div class="pagination-buttons">';

        // Previous button
        if (currentPawnDetailsPage > 1) {
            paginationHtml += `<button class="btn btn-secondary" onclick="changePawnDetailsPage(${currentPawnDetailsPage - 1}, '${type}')">‚Üê ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤</button>`;
        }

        // Page numbers
        for (let i = 1; i <= totalPages; i++) {
            if (i === currentPawnDetailsPage) {
                paginationHtml += `<button class="btn btn-primary">${i}</button>`;
            } else if (i === 1 || i === totalPages || (i >= currentPawnDetailsPage - 1 && i <= currentPawnDetailsPage + 1)) {
                paginationHtml += `<button class="btn btn-secondary" onclick="changePawnDetailsPage(${i}, '${type}')">${i}</button>`;
            } else if (i === currentPawnDetailsPage - 2 || i === currentPawnDetailsPage + 2) {
                paginationHtml += `<span>...</span>`;
            }
        }

        // Next button
        if (currentPawnDetailsPage < totalPages) {
            paginationHtml += `<button class="btn btn-secondary" onclick="changePawnDetailsPage(${currentPawnDetailsPage + 1}, '${type}')">‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‚Üí</button>`;
        }

        paginationHtml += '</div>';
        paginationHtml += '</div>';
        pagination.innerHTML = paginationHtml;
    } else {
        pagination.innerHTML = '';
    }
}

// Change page
async function changePawnDetailsPage(page, type) {
    currentPawnDetailsPage = page;
    await showPawnDetails(type);
}

// ===== REPAIR DEVICES DATABASE =====

// Mock database for repair devices

// Initialize repair devices database
async function initializeRepairDatabase() {
    try {
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API ‡πÅ‡∏ó‡∏ô localStorage - ALL STORES for dashboard
        repairDevices = await API.get(API_ENDPOINTS.repairs);
        console.log('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°‡∏à‡∏≤‡∏Å API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (ALL STORES)');
        console.log(`üìä ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${repairDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        loadRepairData();
    } catch (error) {
        console.error('Error loading repairs from API:', error);
        repairDevices = [];
        // Update dashboard cards with empty data
        updateRepairDashboardCards([]);
    }
}

// ===== REPAIR DEVICES CRUD FUNCTIONS =====

// Initialize repair tabs
function initializeRepairTabs() {
    const tabButtons = document.querySelectorAll('#repair .tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');

            // Remove active class from all repair tabs and contents
            document.querySelectorAll('#repair .tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#repair .tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            this.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        });
    });
}

// Open repair modal
async function openRepairModal(repairId = null) {
    const modal = document.getElementById('repairModal');
    const modalTitle = document.getElementById('repairModalTitle');
    const form = document.getElementById('repairForm');

    // Reset form
    form.reset();
    currentRepairEditId = repairId;

    if (repairId) {
        // Edit mode
        modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°';

        try {
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);

            if (repair) {
                console.log('üîç [openRepairModal] Repair data:', repair);
                console.log('üîç [openRepairModal] Warranty value:', repair.warranty);

                document.getElementById('repairId').value = repair.id;
                document.getElementById('repairCustomerName').value = repair.customer_name || '';
                document.getElementById('repairCustomerPhone').value = repair.customer_phone || '';
                document.getElementById('repairBrand').value = repair.brand;
                document.getElementById('repairModel').value = repair.model;
                document.getElementById('repairColor').value = repair.color;
                document.getElementById('repairImei').value = repair.imei;
                document.getElementById('repairSymptom').value = repair.problem; // ‡πÉ‡∏ä‡πâ problem ‡∏à‡∏≤‡∏Å backend
                document.getElementById('repairPrice').value = repair.repair_cost; // ‡πÉ‡∏ä‡πâ repair_cost ‡∏à‡∏≤‡∏Å backend
                document.getElementById('repairReceiveDate').value = repair.received_date ? repair.received_date.split('T')[0] : ''; // ‡πÉ‡∏ä‡πâ received_date ‡∏à‡∏≤‡∏Å backend
                document.getElementById('repairStatus').value = repair.status;

                const warrantySelect = document.getElementById('repairWarranty');
                if (repair.warranty) {
                    warrantySelect.value = repair.warranty.toString();
                    console.log('‚úÖ [openRepairModal] Warranty set to:', warrantySelect.value);
                } else {
                    warrantySelect.value = '';
                    console.log('‚ö†Ô∏è [openRepairModal] No warranty data');
                }

                document.getElementById('repairNote').value = repair.note || ''; // ‡πÄ‡∏û‡∏¥‡πà‡∏° note field
            }
        } catch (error) {
            console.error('Error loading repair:', error);
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
                icon: 'error',
                confirmType: 'danger'
            });
        }
    } else {
        // Add mode
        modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°';
        // Set default receive date to today
        document.getElementById('repairReceiveDate').value = new Date().toISOString().split('T')[0];
    }

    modal.classList.add('show');
}

// Close repair modal
function closeRepairModal() {
    const modal = document.getElementById('repairModal');
    modal.classList.remove('show');
    currentRepairEditId = null;
}

// Save repair
async function saveRepair(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const warrantyValue = formData.get('warranty');

    const repairData = {
        brand: formData.get('brand'),
        model: formData.get('model'),
        color: formData.get('color'),
        imei: formData.get('imei'),
        customer_name: formData.get('customerName') || null,
        customer_phone: formData.get('customerPhone') || null,
        problem: formData.get('symptom'),
        repair_cost: parseFloat(formData.get('price')),
        received_date: formData.get('receiveDate'),
        appointment_date: null,
        status: formData.get('status'),
        warranty: warrantyValue ? parseInt(warrantyValue) : null,
        note: formData.get('note') || null,
        store: currentStore
    };

    console.log('üíæ [saveRepair] Saving repair:', repairData);
    console.log('üíæ [saveRepair] Warranty value from form:', warrantyValue);
    console.log('üíæ [saveRepair] Warranty parsed:', repairData.warranty);

    try {
        if (currentRepairEditId) {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° completed_date, returned_date ‡πÅ‡∏•‡∏∞ seized_date
            repairData.completed_date = null;
            repairData.returned_date = null;
            repairData.seized_date = null;
            console.log('üìù [saveRepair] PUT - Sending repairData:', repairData);
            await API.put(`${API_ENDPOINTS.repairs}/${currentRepairEditId}`, repairData);
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } else {
            repairData.id = 'R' + Date.now().toString();
            console.log('üìù [saveRepair] POST - Sending repairData:', repairData);
            console.log('üìù [saveRepair] POST - Warranty in payload:', repairData.warranty);
            const result = await API.post(API_ENDPOINTS.repairs, repairData);
            console.log('‚úÖ [saveRepair] POST - Response:', result);
            showNotification('‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }

        loadRepairData();
        closeRepairModal();
    } catch (error) {
        console.error('‚ùå Error saving repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Load and display repair data
function loadRepairData() {
    // Apply current filter using date range
    filterRepairByDateRange();
}

// Display repairs in table
function displayRepairs(repairs, tableBodyId, type) {
    const tbody = document.getElementById(tableBodyId);

    if (!tbody) return;

    if (repairs.length === 0) {
        const colspan = type === 'received' ? '10' : (type === 'returned' || type === 'seized') ? '9' : '8';
        tbody.innerHTML = `<tr><td colspan="${colspan}" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>`;
        return;
    }

    tbody.innerHTML = repairs.map(repair => {
        // Handle both snake_case and camelCase field names
        const receivedDate = repair.received_date || repair.receiveDate;
        const returnedDate = repair.returned_date || repair.returnDate;
        const seizedDate = repair.seized_date || repair.seizedDate;
        const problem = repair.problem || repair.symptom;
        const repairCost = repair.repair_cost || repair.price;

        if (type === 'seized') {
            return `
                <tr>
                    <td style="width: 7%;">${repair.brand}</td>
                    <td style="width: 9%;">${repair.model}</td>
                    <td style="width: 5%;">${repair.color}</td>
                    <td style="width: 9%;">${repair.imei}</td>
                    <td style="width: 10%;">${problem}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(repairCost)}</td>
                    <td style="width: 9%; text-align: center;">${formatDate(receivedDate)}</td>
                    <td style="width: 9%; text-align: center;">${formatDate(seizedDate)}</td>
                    <td style="width: 34%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="repair-action-select" id="action-${repair.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="send-used">‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeRepairAction('${repair.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'received') {
            return `
                <tr>
                    <td style="width: 7%;">${repair.brand}</td>
                    <td style="width: 8%;">${repair.model}</td>
                    <td style="width: 5%;">${repair.color}</td>
                    <td style="width: 8%;">${repair.imei}</td>
                    <td style="width: 10%;">${problem}</td>
                    <td style="width: 7%; text-align: right;">${formatCurrency(repairCost)}</td>
                    <td style="width: 8%; text-align: center;">${formatDate(receivedDate)}</td>
                    <td style="width: 8%; text-align: center;">${formatDate(returnedDate)}</td>
                    <td style="width: 8%; text-align: center;">${formatWarranty(repair.warranty)}</td>
                    <td style="width: 31%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="repair-action-select" id="action-${repair.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeRepairAction('${repair.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'returned') {
            return `
                <tr>
                    <td style="width: 7%;">${repair.brand}</td>
                    <td style="width: 9%;">${repair.model}</td>
                    <td style="width: 5%;">${repair.color}</td>
                    <td style="width: 9%;">${repair.imei}</td>
                    <td style="width: 10%;">${problem}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(repairCost)}</td>
                    <td style="width: 9%; text-align: center;">${formatDate(receivedDate)}</td>
                    <td style="width: 10%;">${repair.note || '-'}</td>
                    <td style="width: 33%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="repair-action-select" id="action-${repair.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="received">‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeRepairAction('${repair.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else {
            // pending (‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°): ‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°‡∏™‡πà‡∏á‡∏ã‡πà‡∏≠‡∏° + ‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à + ‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
            // in-repair (‡∏™‡πà‡∏á‡∏ã‡πà‡∏≠‡∏°): ‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à + ‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á + ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°
            // completed (‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à): ‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á + ‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á + ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°
            let actionOptions = '';
            if (type === 'pending') {
                actionOptions = `
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                    <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                    <option value="send-repair">‡∏™‡πà‡∏á‡∏ã‡πà‡∏≠‡∏°</option>
                    <option value="completed">‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à</option>
                    <option value="return">‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                    <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                    <option value="delete">‡∏•‡∏ö</option>
                `;
            } else if (type === 'in-repair') {
                actionOptions = `
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                    <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                    <option value="completed">‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à</option>
                    <option value="return">‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                    <option value="back-pending">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°</option>
                    <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                    <option value="delete">‡∏•‡∏ö</option>
                `;
            } else if (type === 'completed') {
                actionOptions = `
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                    <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                    <option value="received">‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                    <option value="seize">‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                    <option value="back-pending">‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°</option>
                    <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                    <option value="delete">‡∏•‡∏ö</option>
                `;
            }

            return `
                <tr>
                    <td style="width: 8%;">${repair.brand}</td>
                    <td style="width: 10%;">${repair.model}</td>
                    <td style="width: 6%;">${repair.color}</td>
                    <td style="width: 10%;">${repair.imei}</td>
                    <td style="width: 12%;">${problem}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(repairCost)}</td>
                    <td style="width: 10%; text-align: center;">${formatDate(receivedDate)}</td>
                    <td style="width: 36%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="repair-action-select" id="action-${repair.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                ${actionOptions}
                            </select>
                            <button class="action-btn btn-primary" onclick="executeRepairAction('${repair.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        }
    }).join('');
}

// Execute repair action from dropdown
async function executeRepairAction(repairId) {
    const selectElement = document.getElementById(`action-${repairId}`);
    const action = selectElement.value;

    if (!action) {
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'view':
            await viewRepairDetail(repairId);
            break;
        case 'send-repair':
            await markAsInRepair(repairId);
            break;
        case 'completed':
            await markAsCompleted(repairId);
            break;
        case 'return':
            await markAsReturned(repairId);
            break;
        case 'received':
            await markAsReceived(repairId);
            break;
        case 'seize':
            await seizeRepair(repairId);
            break;
        case 'back-pending':
            await markAsPending(repairId);
            break;
        case 'send-used':
            await sendToUsedDevices(repairId);
            break;
        case 'edit':
            await openRepairModal(repairId);
            break;
        case 'delete':
            await deleteRepair(repairId);
            break;
        default:
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å',
                icon: 'error'
            });
    }

    // Reset select after action
    selectElement.value = '';
}

// Mark repair as in-repair
async function markAsInRepair(repairId) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
            if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
                return;
            }

        // ‡πÄ‡∏õ‡∏¥‡∏î modal ‡∏™‡πà‡∏á‡∏ã‡πà‡∏≠‡∏°
        openSendRepairModal(repair);
    } catch (error) {
        console.error('Error loading repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Open send repair modal
function openSendRepairModal(repair) {
    const modal = document.getElementById('sendRepairModal');
    const form = document.getElementById('sendRepairForm');

    // Reset form
    form.reset();

    // Set repair ID
    document.getElementById('sendRepairId').value = repair.id;

    // Set default values
    document.getElementById('sendRepairSymptom').value = repair.problem || '';
    document.getElementById('sendRepairCost').value = repair.repair_cost || 0;
    
    // Set today's date as default
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('sendRepairDate').value = today;

    // Clear other fields
    document.getElementById('sendRepairTo').value = '';
    document.getElementById('sendRepairNote').value = '';

    // Show modal
    modal.classList.add('show');
}

// Close send repair modal
function closeSendRepairModal() {
    const modal = document.getElementById('sendRepairModal');
    modal.classList.remove('show');
    document.getElementById('sendRepairForm').reset();
}

// Save send repair
async function saveSendRepair(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const repairId = formData.get('repairId');
    const sendTo = formData.get('sendTo');
    const symptom = formData.get('symptom');
    const cost = parseFloat(formData.get('cost'));
    const sendDate = formData.get('sendDate');
    const note = formData.get('note') || '';

    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
        const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
        if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
            return;
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á note ‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• "‡∏™‡πà‡∏á‡πÉ‡∏Ñ‡∏£" ‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
        let updatedNote = '';
        if (sendTo) {
            updatedNote = `‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ó‡∏µ‡πà: ${sendTo}`;
        }
        if (note) {
            updatedNote += (updatedNote ? '\n' : '') + note;
        }
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ note ‡πÄ‡∏î‡∏¥‡∏° ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡πà‡∏≠
        if (repair.note) {
            updatedNote = repair.note + (updatedNote ? '\n\n' : '') + updatedNote;
            }

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó status ‡πÄ‡∏õ‡πá‡∏ô in-repair
        await API.put(`${API_ENDPOINTS.repairs}/${repairId}`, {
            brand: repair.brand,
            model: repair.model,
            color: repair.color,
            imei: repair.imei,
            customer_name: repair.customer_name,
            customer_phone: repair.customer_phone,
            problem: symptom, // ‡πÉ‡∏ä‡πâ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            repair_cost: cost, // ‡πÉ‡∏ä‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            accessory_cost: repair.accessory_cost || repair.accessoryCost || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
            commission: repair.commission || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°
            technician: repair.technician || '', // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏ô‡∏ã‡πà‡∏≠‡∏°
            received_date: repair.received_date ? repair.received_date.split('T')[0] : null,
            appointment_date: sendDate, // ‡πÄ‡∏Å‡πá‡∏ö‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏ã‡πà‡∏≠‡∏°‡πÉ‡∏ô appointment_date
            completed_date: repair.completed_date ? repair.completed_date.split('T')[0] : null,
            returned_date: repair.returned_date ? repair.returned_date.split('T')[0] : null,
            seized_date: repair.seized_date ? repair.seized_date.split('T')[0] : null,
            status: 'in-repair',
            warranty: repair.warranty || null, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô
            note: updatedNote || null,
            store: repair.store
        });

            loadRepairData();
        closeSendRepairModal();
            showNotification('‡∏™‡πà‡∏á‡∏ã‡πà‡∏≠‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
        console.error('Error saving send repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Mark repair as completed
async function markAsCompleted(repairId) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
            if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
                return;
            }

        // ‡πÄ‡∏õ‡∏¥‡∏î modal ‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à
        openCompleteRepairModal(repair);
    } catch (error) {
        console.error('Error loading repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Open complete repair modal
function openCompleteRepairModal(repair) {
    const modal = document.getElementById('completeRepairModal');
    const form = document.getElementById('completeRepairForm');

    // Reset form
    form.reset();

    // Set repair ID
    document.getElementById('completeRepairId').value = repair.id;

    // Set default values from existing repair data
    document.getElementById('completeRepairSymptom').value = repair.problem || '';
    document.getElementById('completeRepairCost').value = repair.repair_cost || 0;
    
    // Set today's date as default
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('completeRepairDate').value = today;

    // Set note if exists
    document.getElementById('completeRepairNote').value = repair.note || '';

    // Clear accessory fields
    document.getElementById('completeRepairAccessoryType').value = '';
    document.getElementById('completeRepairAccessorySearch').value = '';
    document.getElementById('completeRepairAccessoryCode').value = '';
    document.getElementById('completeRepairAccessoryCost').value = '';
    document.getElementById('completeRepairManualCost').value = '';
    document.getElementById('completeRepairAccessoryDropdown').style.display = 'none';
    document.getElementById('completeRepairAccessoryDropdown').innerHTML = '<div class="dropdown-item" data-value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà</div>';
    completeRepairAccessoriesData = [];
    
    // Clear selected accessories list
    selectedAccessories = [];
    renderSelectedAccessories();

    // Show modal
    modal.classList.add('show');
}

// Close complete repair modal
function closeCompleteRepairModal() {
    const modal = document.getElementById('completeRepairModal');
    modal.classList.remove('show');
    document.getElementById('completeRepairForm').reset();
    // Clear accessory fields
    document.getElementById('completeRepairAccessoryType').value = '';
    document.getElementById('completeRepairAccessorySearch').value = '';
    document.getElementById('completeRepairAccessoryCode').value = '';
    document.getElementById('completeRepairAccessoryCost').value = '';
    document.getElementById('completeRepairManualCost').value = '';
    document.getElementById('completeRepairAccessoryDropdown').style.display = 'none';
    document.getElementById('completeRepairAccessoryDropdown').innerHTML = '<div class="dropdown-item" data-value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà</div>';
    completeRepairAccessoriesData = [];
    
    // Clear selected accessories list
    selectedAccessories = [];
}

// Update accessory info when type is selected
async function updateCompleteRepairAccessoryInfo() {
    const accessoryType = document.getElementById('completeRepairAccessoryType').value;
    const searchInput = document.getElementById('completeRepairAccessorySearch');
    const dropdown = document.getElementById('completeRepairAccessoryDropdown');
    const hiddenInput = document.getElementById('completeRepairAccessoryCode');
    const costField = document.getElementById('completeRepairAccessoryCost');

    // Clear fields if no type selected
    if (!accessoryType) {
        completeRepairAccessoriesData = [];
        dropdown.innerHTML = '<div class="dropdown-item" data-value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà</div>';
        searchInput.value = '';
        hiddenInput.value = '';
        costField.value = '';
        dropdown.style.display = 'none';
        return;
    }

    try {
        // Fetch accessories from API filtered by type and store
        const allAccessories = await API.get(API_ENDPOINTS.accessories, { store: currentStore });
        
        // Filter by type and available quantity (quantity > 0)
        const filteredAccessories = allAccessories.filter(acc => {
            return acc.type === accessoryType && 
                   (acc.quantity || 0) > 0 &&
                   acc.status !== 'claim';
        });

        // Store data globally
        completeRepairAccessoriesData = filteredAccessories;
        
        if (filteredAccessories.length === 0) {
            dropdown.innerHTML = '<div class="dropdown-item no-results">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Ñ</div>';
            searchInput.value = '';
            hiddenInput.value = '';
            costField.value = '';
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: `‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó ${getAccessoryTypeName(accessoryType)} ‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Ñ`,
                icon: 'warning'
            });
            return;
        }

        // Populate dropdown
        renderCompleteRepairAccessoryDropdown(filteredAccessories);
        
        // Clear fields
        searchInput.value = '';
        hiddenInput.value = '';
        costField.value = '';
    } catch (error) {
        console.error('Error loading accessories:', error);
        completeRepairAccessoriesData = [];
        dropdown.innerHTML = '<div class="dropdown-item no-results">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î</div>';
        searchInput.value = '';
        hiddenInput.value = '';
        costField.value = '';
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Render dropdown items
function renderCompleteRepairAccessoryDropdown(accessories) {
    const dropdown = document.getElementById('completeRepairAccessoryDropdown');
    dropdown.innerHTML = '<div class="dropdown-item" data-value="" data-cost="0" onclick="selectCompleteRepairAccessory(this)">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà</div>';
    
    accessories.forEach(acc => {
        const item = document.createElement('div');
        item.className = 'dropdown-item';
        item.setAttribute('data-value', acc.id);
        item.setAttribute('data-cost', acc.cost_price || 0);
        item.setAttribute('data-text', `${acc.code} - ${acc.brand} ${acc.models || ''}`.trim());
        item.textContent = `${acc.code} - ${acc.brand} ${acc.models || ''}`.trim();
        item.onclick = function() { selectCompleteRepairAccessory(this); };
        dropdown.appendChild(item);
    });
}

// Toggle dropdown visibility
function toggleCompleteRepairAccessoryDropdown() {
    const dropdown = document.getElementById('completeRepairAccessoryDropdown');
    const isVisible = dropdown.style.display === 'block';
    dropdown.style.display = isVisible ? 'none' : 'block';
}

// Filter accessories based on search input
function filterCompleteRepairAccessories(searchTerm) {
    const dropdown = document.getElementById('completeRepairAccessoryDropdown');
    dropdown.style.display = 'block';
    
    if (!searchTerm.trim()) {
        renderCompleteRepairAccessoryDropdown(completeRepairAccessoriesData);
        return;
    }
    
    const searchLower = searchTerm.toLowerCase();
    const filtered = completeRepairAccessoriesData.filter(acc => {
        const text = `${acc.code} ${acc.brand} ${acc.models || ''}`.toLowerCase();
        return text.includes(searchLower);
    });
    
    if (filtered.length === 0) {
        dropdown.innerHTML = '<div class="dropdown-item no-results">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</div>';
    } else {
        renderCompleteRepairAccessoryDropdown(filtered);
    }
}

// Select an accessory from dropdown
function selectCompleteRepairAccessory(element) {
    const searchInput = document.getElementById('completeRepairAccessorySearch');
    const hiddenInput = document.getElementById('completeRepairAccessoryCode');
    const dropdown = document.getElementById('completeRepairAccessoryDropdown');
    const costField = document.getElementById('completeRepairAccessoryCost');
    
    const value = element.getAttribute('data-value');
    const text = element.getAttribute('data-text') || element.textContent;
    const cost = element.getAttribute('data-cost') || 0;
    
    // Update fields
    searchInput.value = text;
    hiddenInput.value = value;
    costField.value = value ? cost : '';
    
    // Close dropdown
    dropdown.style.display = 'none';
    
    // Remove selected class from all items
    dropdown.querySelectorAll('.dropdown-item').forEach(item => {
        item.classList.remove('selected');
    });
    
    // Add selected class to current item
    element.classList.add('selected');
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const searchInput = document.getElementById('completeRepairAccessorySearch');
    const dropdown = document.getElementById('completeRepairAccessoryDropdown');
    
    if (searchInput && dropdown) {
        const isClickInside = searchInput.contains(event.target) || dropdown.contains(event.target);
        if (!isClickInside) {
            dropdown.style.display = 'none';
        }
    }
});

// Update cost when accessory is selected (legacy function - now handled by selectCompleteRepairAccessory)
function updateCompleteRepairAccessoryCost() {
    const codeSelect = document.getElementById('completeRepairAccessoryCode');
    const costField = document.getElementById('completeRepairAccessoryCost');
    
    const selectedOption = codeSelect.options[codeSelect.selectedIndex];
    if (selectedOption && selectedOption.value) {
        // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà -> ‡πÉ‡∏™‡πà‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏à‡∏≤‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
        const cost = selectedOption.getAttribute('data-cost') || 0;
        costField.value = cost;
    }
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà -> ‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏≠‡∏á (‡πÑ‡∏°‡πà clear ‡∏Ñ‡πà‡∏≤)
}

// Get accessory type name in Thai
function getAccessoryTypeName(type) {
    const typeNames = {
        'battery': '‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà',
        'screen': '‡∏à‡∏≠',
        'charging': '‡πÅ‡∏û‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        'switch': '‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå',
        'flex': '‡∏™‡∏≤‡∏¢‡πÅ‡∏û',
        'speaker': '‡∏≠‡∏∑‡πà‡∏ô‡πÜ'
    };
    return typeNames[type] || type;
}

// ============================================
// Multiple Accessories Management Functions
// ============================================

// Add accessory to list
function addAccessoryToList() {
    const typeSelect = document.getElementById('completeRepairAccessoryType');
    const codeInput = document.getElementById('completeRepairAccessoryCode');
    const searchInput = document.getElementById('completeRepairAccessorySearch');
    const costInput = document.getElementById('completeRepairAccessoryCost');
    
    const type = typeSelect.value;
    const code = codeInput.value;
    const name = searchInput.value;
    const cost = parseFloat(costInput.value) || 0;
    
    // Validate
    if (!type) {
        customAlert({
            title: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà',
            icon: 'warning'
        });
        return;
    }
    
    if (!code) {
        customAlert({
            title: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà',
            icon: 'warning'
        });
        return;
    }
    
    // Check duplicate
    const exists = selectedAccessories.find(a => a.code === code);
    if (exists) {
        customAlert({
            title: '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß',
            icon: 'warning'
        });
        return;
    }
    
    // Add to array
    selectedAccessories.push({
        type: type,
        code: code,
        name: name,
        cost: cost
    });
    
    // Clear form
    typeSelect.value = '';
    codeInput.value = '';
    searchInput.value = '';
    costInput.value = '';
    document.getElementById('completeRepairAccessoryDropdown').style.display = 'none';
    
    // Render list
    renderSelectedAccessories();
    calculateTotalAccessoryCost();
}

// Remove accessory from list
function removeAccessoryFromList(index) {
    selectedAccessories.splice(index, 1);
    renderSelectedAccessories();
    calculateTotalAccessoryCost();
}

// Render selected accessories list
function renderSelectedAccessories() {
    const container = document.getElementById('selectedAccessoriesList');
    
    if (selectedAccessories.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px; border: 2px dashed #ddd; border-radius: 8px;">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà</div>';
        document.getElementById('totalCostDisplay').style.display = 'none';
        return;
    }
    
    container.innerHTML = selectedAccessories.map((accessory, index) => `
        <div style="background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
            <div style="flex: 1;">
                <div style="font-weight: 600; color: #2c3e50; margin-bottom: 4px;">
                    ${getAccessoryTypeName(accessory.type)} - ${accessory.name}
                </div>
                <div style="font-size: 14px; color: #666;">
                    ‡∏£‡∏´‡∏±‡∏™: ${accessory.code} | ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô: ${formatCurrency(accessory.cost)}
                </div>
            </div>
            <button type="button" onclick="removeAccessoryFromList(${index})" 
                    style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                ‡∏•‡∏ö
            </button>
        </div>
    `).join('');
    
    document.getElementById('totalCostDisplay').style.display = 'block';
}

// Calculate total accessory cost
function calculateTotalAccessoryCost() {
    const total = selectedAccessories.reduce((sum, accessory) => sum + accessory.cost, 0);
    document.getElementById('totalAccessoryCost').textContent = formatCurrency(total);
}

// Save complete repair
async function saveCompleteRepair(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const repairId = formData.get('repairId');
    const symptom = formData.get('symptom');
    const cost = parseFloat(formData.get('cost'));
    const completeDate = formData.get('completeDate');
    const commission = parseFloat(formData.get('commission')) || 0;
    const technician = formData.get('technician') || '';
    const note = formData.get('note') || '';
    const manualCost = parseFloat(formData.get('manualCost')) || 0;
    
    // Calculate total accessory cost from selected accessories
    const accessoriesCost = selectedAccessories.reduce((sum, acc) => sum + acc.cost, 0);

    // Total accessory cost = accessories from list + manual cost
    const totalAccessoryCost = accessoriesCost + manualCost;

    console.log('üîß Complete Repair Form Data:', {
        repairId,
        symptom,
        cost,
        selectedAccessories,
        accessoriesCost,
        manualCost,
        totalAccessoryCost,
        commission,
        technician
    });

    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
        const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
        if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
            return;
        }

        // Process each selected accessory - ‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
        const accessoryErrors = [];
        for (const selectedAcc of selectedAccessories) {
            try {
                // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
                const accessory = await API.get(`${API_ENDPOINTS.accessories}/${selectedAcc.code}`);
                
                if (accessory) {
                    const totalQuantity = parseInt(accessory.quantity) || 0;
                    const claimQuantity = parseInt(accessory.claim_quantity) || 0;

                    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á
                    const availableQuantity = totalQuantity - claimQuantity;
                    
                    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    if (availableQuantity <= 0) {
                        accessoryErrors.push(`${selectedAcc.name} ‡∏´‡∏°‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å`);
                        continue;
                    }
                    
                    // ‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏•‡∏á 1
                    const newTotalQuantity = totalQuantity - 1;
                    
                    await API.put(`${API_ENDPOINTS.accessories}/${selectedAcc.code}`, {
                        type: accessory.type,
                        code: accessory.code,
                        brand: accessory.brand,
                        models: accessory.models,
                        quantity: newTotalQuantity,
                        cost_price: accessory.cost_price,
                        repair_price: accessory.repair_price,
                        import_date: accessory.import_date,
                        note: accessory.note,
                        store: accessory.store
                    });
                    
                    const newAvailable = availableQuantity - 1;
                    console.log(`‚úÖ ‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà ${accessory.code}: ‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ${newAvailable} (‡∏à‡∏≤‡∏Å ${totalQuantity} ‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ${newTotalQuantity})`);
                }
            } catch (accessoryError) {
                console.error(`Error updating accessory ${selectedAcc.code}:`, accessoryError);
                accessoryErrors.push(`${selectedAcc.name}: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ`);
            }
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á warning ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ error ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
        if (accessoryErrors.length > 0) {
                await customAlert({
                    title: '‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
                message: '‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ö‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£:\n' + accessoryErrors.join('\n'),
                    icon: 'warning'
                });
            }
        
        // Reload accessories data
        if (typeof loadAccessoriesData === 'function') {
            loadAccessoriesData();
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á note ‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ
        let updatedNote = '';
        if (selectedAccessories.length > 0) {
            const accessoryList = selectedAccessories.map(acc => 
                `${getAccessoryTypeName(acc.type)} ${acc.name} (${formatCurrency(acc.cost)})`
            ).join(', ');
            updatedNote = `‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà: ${accessoryList}`;
        }

        // Add manual cost to note if exists
        if (manualCost > 0) {
            const manualCostNote = `‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°: ${formatCurrency(manualCost)}`;
            updatedNote = updatedNote ? `${updatedNote}\n${manualCostNote}` : manualCostNote;
        }
        
        if (note) {
            updatedNote = updatedNote ? `${updatedNote}\n${note}` : note;
        }
        
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ note ‡πÄ‡∏î‡∏¥‡∏° ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡πà‡∏≠
        if (repair.note) {
            updatedNote = updatedNote ? `${repair.note}\n\n${updatedNote}` : repair.note;
            }

            // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó status ‡πÅ‡∏•‡∏∞ completed_date
            await API.put(`${API_ENDPOINTS.repairs}/${repairId}`, {
                brand: repair.brand,
                model: repair.model,
                color: repair.color,
                imei: repair.imei,
                customer_name: repair.customer_name,
                customer_phone: repair.customer_phone,
            problem: symptom, // ‡πÉ‡∏ä‡πâ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            repair_cost: cost, // ‡πÉ‡∏ä‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            accessory_cost: totalAccessoryCost, // ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏£‡∏ß‡∏°
                commission: commission, // ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°
                technician: technician, // ‡∏Ñ‡∏ô‡∏ã‡πà‡∏≠‡∏°
                received_date: repair.received_date ? repair.received_date.split('T')[0] : null,
                appointment_date: repair.appointment_date ? repair.appointment_date.split('T')[0] : null,
            completed_date: completeDate, // ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
                returned_date: repair.returned_date ? repair.returned_date.split('T')[0] : null,
                seized_date: repair.seized_date ? repair.seized_date.split('T')[0] : null,
                status: 'completed',
                warranty: repair.warranty || null, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô
            note: updatedNote || null,
                store: repair.store
            });

            loadRepairData();
        closeCompleteRepairModal();
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
        console.error('Error saving complete repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Mark repair as received
async function markAsReceived(repairId) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
            if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
            return;
        }

        // ‡πÄ‡∏õ‡∏¥‡∏î modal ‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
        openReceiveRepairModal(repair);
    } catch (error) {
        console.error('Error loading repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Open receive repair modal
function openReceiveRepairModal(repair) {
    const modal = document.getElementById('receiveRepairModal');
    const form = document.getElementById('receiveRepairForm');

    // Reset form
    form.reset();

    // Set repair ID
    document.getElementById('receiveRepairId').value = repair.id;

    // Set default values from existing repair data
    document.getElementById('receiveRepairCost').value = repair.repair_cost || 0;
    
    // Set default date to completed_date if exists, otherwise today
    let defaultDate = new Date().toISOString().split('T')[0];
    if (repair.completed_date) {
        defaultDate = repair.completed_date.split('T')[0];
    }
    document.getElementById('receiveRepairDate').value = defaultDate;

    // Show modal
    modal.classList.add('show');
}

// Close receive repair modal
function closeReceiveRepairModal() {
    const modal = document.getElementById('receiveRepairModal');
    modal.classList.remove('show');
    document.getElementById('receiveRepairForm').reset();
}

// Show repair expense detail modal
async function showRepairExpenseDetail() {
    try {
        const modal = document.getElementById('repair-expense-detail');
        const tableBody = document.getElementById('repairExpenseDetailTableBody');
        
        // Get all repairs to calculate totals
        const allRepairs = await API.get(API_ENDPOINTS.repairs, { store: currentStore });
        
        // Filter completed repairs (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß - ‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢)
        const now = new Date();
        const selectedMonth = now.getMonth() + 1;
        const selectedYearInt = now.getFullYear();
        
        console.log('üîç Filtering repair expenses for:', { 
            currentMonth: `${selectedYearInt}-${String(selectedMonth).padStart(2, '0')}`,
            selectedYear: selectedYearInt, 
            selectedMonth,
            store: currentStore,
            totalRepairs: allRepairs.length
        });
        
        const completedRepairs = allRepairs.filter(r => {
            // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ completed ‡∏´‡∏£‡∏∑‡∏≠ received (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß - ‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢)
            if (r.status !== 'completed' && r.status !== 'received') return false;
            
            // ‡πÉ‡∏ä‡πâ completed_date (‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à - ‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢)
            const completedDate = r.completed_date || r.completedDate;
            if (!completedDate) return false;
            
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à ‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            const date = new Date(completedDate);
            const dateMonth = date.getMonth() + 1;
            const dateYear = date.getFullYear();
            
            return dateMonth === selectedMonth && dateYear === selectedYearInt;
        });
        
        console.log('üìä Found completed repairs:', completedRepairs.length, completedRepairs.map(r => ({
            brand: r.brand,
            model: r.model,
            completed_date: r.completed_date,
            accessory_cost: r.accessory_cost,
            commission: r.commission
        })));
        
        // Calculate totals from repairs (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô + ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏° ‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ)
        let totalAccessoryCost = 0;
        let totalCommission = 0;
        
        completedRepairs.forEach(repair => {
            const accCost = parseFloat(repair.accessory_cost || repair.accessoryCost || 0);
            const comm = parseFloat(repair.commission || 0);
            totalAccessoryCost += accCost;
            totalCommission += comm;
            console.log(`  - ${repair.brand} ${repair.model}: accessory_cost=${accCost}, commission=${comm}`);
        });
        
        const totalExpense = totalAccessoryCost + totalCommission;
        
        console.log('üí∞ Totals:', {
            totalAccessoryCost,
            totalCommission,
            totalExpense
        });
        
        // Build table rows - ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°
        const rows = completedRepairs
            .sort((a, b) => {
                const dateA = new Date(a.completed_date || a.completedDate);
                const dateB = new Date(b.completed_date || b.completedDate);
                return dateB - dateA; // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤
            })
            .map(repair => {
                const brand = repair.brand || '';
                const model = repair.model || '';
                const completedDate = formatDate(repair.completed_date || repair.completedDate);
                const accessoryCost = parseFloat(repair.accessory_cost || repair.accessoryCost || 0);
                const commission = parseFloat(repair.commission || 0);
                const total = accessoryCost + commission;
                const technician = repair.technician ? ` (${repair.technician})` : '';
                
                // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏à‡∏≤‡∏Å note (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ)
                let accessoriesUsed = '-';
                const note = repair.note || '';
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢ "‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà:"
                const accessoryMatch = note.match(/‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà:\s*([^\n]+)/);
                if (accessoryMatch) {
                    accessoriesUsed = accessoryMatch[1].trim();
                } else if (accessoryCost > 0) {
                    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÉ‡∏ô note
                    accessoriesUsed = '‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà';
                }
                
                return `
                    <tr>
                        <td style="text-align: left; padding-left: 15px; white-space: nowrap;">
                            <strong>${brand} ${model}</strong>
                        </td>
                        <td style="text-align: left; font-size: 14px; color: #666; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            ${accessoriesUsed}
                        </td>
                        <td style="text-align: center; white-space: nowrap;">${completedDate}</td>
                        <td style="text-align: right; font-weight: 600; color: ${accessoryCost > 0 ? '#dc3545' : '#999'}; white-space: nowrap;">
                            ${formatCurrency(accessoryCost)}
                        </td>
                        <td style="text-align: right; color: ${commission > 0 ? '#f39c12' : '#999'}; white-space: nowrap;">
                            ${formatCurrency(commission)}${technician}
                        </td>
                        <td style="text-align: right; padding-right: 15px; font-weight: 700; color: ${total > 0 ? '#dc3545' : '#999'}; font-size: 16px; white-space: nowrap;">
                            ${formatCurrency(total)}
                        </td>
                    </tr>
                `;
            }).join('');
        
        if (rows) {
            tableBody.innerHTML = rows;
        } else {
            tableBody.innerHTML = '<tr><td colspan="6" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏£‡πá‡∏à‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        }
        
        // Calculate technician summary (‡∏™‡∏£‡∏∏‡∏õ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏ï‡∏≤‡∏°‡∏ä‡πà‡∏≤‡∏á)
        const technicianSummary = {};
        completedRepairs.forEach(repair => {
            const techName = repair.technician || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡πà‡∏≤‡∏á';
            const commission = parseFloat(repair.commission || 0);
            const accessoryCost = parseFloat(repair.accessory_cost || repair.accessoryCost || 0);

            if (!technicianSummary[techName]) {
                technicianSummary[techName] = {
                    totalCommission: 0,
                    totalAccessoryCost: 0,
                    count: 0
                };
            }

            technicianSummary[techName].totalCommission += commission;
            technicianSummary[techName].totalAccessoryCost += accessoryCost;
            technicianSummary[techName].count += 1;
        });

        // Build technician summary HTML
        let techSummaryHtml = '';
        const sortedTechnicians = Object.entries(technicianSummary)
            .sort((a, b) => b[1].totalCommission - a[1].totalCommission); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏à‡∏≤‡∏Å‡∏°‡∏≤‡∏Å‡πÑ‡∏õ‡∏ô‡πâ‡∏≠‡∏¢
        
        sortedTechnicians.forEach(([techName, data]) => {
            if (data.totalCommission > 0 || data.totalAccessoryCost > 0) { // ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ä‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢
                techSummaryHtml += `
                    <span style="display: inline-block; margin-right: 10px; font-size: 11.2px; font-weight: 600; color: #333;">
                        üë®‚Äçüîß ${techName}:‡∏ó‡∏∏‡∏ô ${formatCurrency(data.totalAccessoryCost)} ‡∏Ñ‡∏≠‡∏° ${formatCurrency(data.totalCommission)} <span style="color: #6c757d;">(${data.count})</span>
                    </span>
                `;
            }
        });

        // Update filter-info
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        const filterText = `${monthNames[selectedMonth - 1]} ${selectedYearInt + 543}`;
        document.getElementById('repairExpenseMonth').textContent = filterText;
        document.getElementById('repairTotalExpense').textContent = formatCurrency(totalExpense);
        document.getElementById('repairExpenseDetailCount').textContent = completedRepairs.length;

        // Update technician summary
        const techSummaryElement = document.getElementById('repairTechnicianSummary');
        if (techSummaryElement) {
            techSummaryElement.innerHTML = techSummaryHtml || '<span style="color: #6c757d;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°</span>';
        }
        
        // Update summary cards
        document.getElementById('repairTotalAccessoryCost').textContent = formatCurrency(totalAccessoryCost);
        document.getElementById('repairTotalCommission').textContent = formatCurrency(totalCommission);
        document.getElementById('repairTotalExpenseCard').textContent = formatCurrency(totalExpense);

        // Hide main page and show detail page
        document.getElementById('repair').classList.remove('active');
        document.getElementById('repair-expense-detail').classList.add('active');
        
    } catch (error) {
        console.error('Error loading repair expense detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close repair expense detail modal (no longer needed)
// function closeRepairExpenseDetailModal() {
//     const modal = document.getElementById('repairExpenseDetailModal');
//     modal.classList.remove('show');
// }

// Show repair commission detail
async function showRepairCommissionDetail() {
    try {
        const modal = document.getElementById('repair-commission-detail');
        const tableBody = document.getElementById('commissionDetailTableBody');
        const technicianCardsContainer = document.getElementById('technicianCommissionCards');
        
        // Get all repairs to calculate totals
        const allRepairs = await API.get(API_ENDPOINTS.repairs, { store: currentStore });

        // Filter completed repairs (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß)
        const now = new Date();
        const selectedMonth = now.getMonth() + 1;
        const selectedYearInt = now.getFullYear();

        console.log('üîç Filtering repair commission for:', {
            currentMonth: `${selectedYearInt}-${String(selectedMonth).padStart(2, '0')}`,
            selectedYear: selectedYearInt,
            selectedMonth,
            store: currentStore,
            totalRepairs: allRepairs.length
        });

        const completedRepairs = allRepairs.filter(r => {
            // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ completed ‡∏´‡∏£‡∏∑‡∏≠ received (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß)
            if (r.status !== 'completed' && r.status !== 'received') return false;

            // ‡πÉ‡∏ä‡πâ completed_date (‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à)
            const completedDate = r.completed_date || r.completedDate;
            if (!completedDate) return false;

            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à ‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            const date = new Date(completedDate);
            const dateMonth = date.getMonth() + 1;
            const dateYear = date.getFullYear();

            return dateMonth === selectedMonth && dateYear === selectedYearInt;
        });
        
        console.log('üìä Found completed repairs with commission:', completedRepairs.length);
        
        // Group by technician
        const technicianData = {};
        let totalCommission = 0;
        let totalRepairs = 0;
        
        completedRepairs.forEach(repair => {
            const commission = parseFloat(repair.commission || 0);
            const technician = repair.technician || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡πà‡∏≤‡∏á';
            
            if (!technicianData[technician]) {
                technicianData[technician] = {
                    name: technician,
                    totalCommission: 0,
                    repairCount: 0,
                    repairs: []
                };
            }
            
            technicianData[technician].totalCommission += commission;
            technicianData[technician].repairCount++;
            technicianData[technician].repairs.push(repair);
            
            totalCommission += commission;
            totalRepairs++;
        });
        
        console.log('üë®‚Äçüîß Technician data:', technicianData);
        
        // Update summary
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        const filterText = `${monthNames[selectedMonth - 1]} ${selectedYearInt + 543}`;
        document.getElementById('commissionMonth').textContent = filterText;
        document.getElementById('commissionTotal').textContent = formatCurrency(totalCommission);
        document.getElementById('commissionRepairCount').textContent = totalRepairs;

        // Build technician cards
        const technicians = Object.values(technicianData).sort((a, b) => b.totalCommission - a.totalCommission);
        
        if (technicians.length > 0) {
            technicianCardsContainer.innerHTML = technicians.map(tech => {
                const avgCommission = tech.repairCount > 0 ? tech.totalCommission / tech.repairCount : 0;
                return `
                    <div class="summary-card" style="padding: 20px; background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; font-size: 18px; color: white;">üë®‚Äçüîß ${tech.name}</h3>
                            <span style="background: rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 15px; font-size: 14px;">${tech.repairCount} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</span>
                        </div>
                        <p style="font-size: 28px; font-weight: bold; margin: 10px 0; color: white;">${formatCurrency(tech.totalCommission)}</p>
                        <p style="font-size: 14px; margin: 0; opacity: 0.9; color: white;">‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ ${formatCurrency(avgCommission)}/‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</p>
                    </div>
                `;
            }).join('');
        } else {
            technicianCardsContainer.innerHTML = '<p class="text-center" style="grid-column: 1/-1; color: #999;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</p>';
        }

        // Build table rows - ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°
        const rows = completedRepairs
            .sort((a, b) => {
                const dateA = new Date(a.completed_date || a.completedDate);
                const dateB = new Date(b.completed_date || b.completedDate);
                return dateB - dateA; // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤
            })
            .map(repair => {
                const brand = repair.brand || '';
                const model = repair.model || '';
                const problem = repair.problem || '-';
                const completedDate = formatDate(repair.completed_date || repair.completedDate);
                const cost = parseFloat(repair.cost || 0);
                const commission = parseFloat(repair.commission || 0);
                const technician = repair.technician || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏';
                
                return `
                    <tr>
                        <td style="text-align: left; padding-left: 15px; white-space: nowrap;">
                            <strong>${brand}</strong>
                        </td>
                        <td style="text-align: left; white-space: nowrap;">
                            ${model}
                        </td>
                        <td style="text-align: left; max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            ${problem}
                        </td>
                        <td style="text-align: center; white-space: nowrap;">
                            <span style="background: #f39c12; color: white; padding: 4px 10px; border-radius: 12px; font-size: 13px; font-weight: 500;">
                                ${technician}
                            </span>
                        </td>
                        <td style="text-align: center; white-space: nowrap;">${completedDate}</td>
                        <td style="text-align: right; white-space: nowrap; color: #28a745; font-weight: 600;">
                            ${formatCurrency(cost)}
                        </td>
                        <td style="text-align: right; padding-right: 15px; font-weight: 700; color: ${commission > 0 ? '#f39c12' : '#999'}; font-size: 16px; white-space: nowrap;">
                            ${formatCurrency(commission)}
                        </td>
                    </tr>
                `;
            }).join('');
        
        if (rows) {
            tableBody.innerHTML = rows;
        } else {
            tableBody.innerHTML = '<tr><td colspan="7" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        }

        // Hide main page and show detail page
        document.getElementById('repair').classList.remove('active');
        document.getElementById('repair-commission-detail').classList.add('active');
        
    } catch (error) {
        console.error('Error loading repair commission detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Show repair income detail modal
async function showRepairIncomeDetail() {
    try {
        const modal = document.getElementById('repair-income-detail');
        const tableBody = document.getElementById('repairIncomeDetailTableBody');
        
        // Get all repairs
        const allRepairs = await API.get(API_ENDPOINTS.repairs, { store: currentStore });
        
        // Filter received repairs
        const now = new Date();
        const currentMonth = now.getMonth() + 1;
        const currentYear = now.getFullYear();
        
        const receivedRepairs = allRepairs.filter(r => {
            if (r.status !== 'received') return false;
            
            const returnedDate = r.returned_date || r.returnedDate;
            if (!returnedDate) return false;
            
            const date = new Date(returnedDate);
            return date.getMonth() + 1 === currentMonth && 
                   date.getFullYear() === currentYear;
        });
        
        // Calculate total
        let totalIncome = 0;

        // Sort by returned_date (newest first)
        receivedRepairs.sort((a, b) => {
            const dateA = new Date(a.returned_date || a.returnedDate || 0);
            const dateB = new Date(b.returned_date || b.returnedDate || 0);
            return dateB - dateA; // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤
        });
        
        // Build table rows
        if (receivedRepairs.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="6" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            tableBody.innerHTML = receivedRepairs.map(repair => {
                const repairCost = parseFloat(repair.repair_cost || 0);
                totalIncome += repairCost;
                
                const returnedDate = repair.returned_date || repair.returnedDate;
                const formattedDate = returnedDate ? new Date(returnedDate).toLocaleDateString('th-TH') : '-';
                
                return `
                    <tr>
                        <td style="width: 12%;">${repair.brand || '-'}</td>
                        <td style="width: 18%;">${repair.model || '-'}</td>
                        <td style="width: 25%;">${repair.problem || '-'}</td>
                        <td style="width: 15%; text-align: right;"><strong>${formatCurrency(repairCost)}</strong></td>
                        <td style="width: 15%; text-align: center;">${repair.technician || '-'}</td>
                        <td style="width: 15%; text-align: center;">${formattedDate}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Set filter text
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        const filterText = `${monthNames[now.getMonth()]} ${now.getFullYear() + 543}`;
        
        // Update summary card
        document.getElementById('totalIncomeDetail').textContent = formatCurrency(totalIncome);
        document.getElementById('repairIncomeDetailCount').textContent = receivedRepairs.length;
        document.getElementById('repairIncomeMonth').textContent = filterText;
        
        // Hide main page and show detail page
        document.getElementById('repair').classList.remove('active');
        document.getElementById('repair-income-detail').classList.add('active');
        
    } catch (error) {
        console.error('Error loading repair income detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close repair income detail modal (no longer needed)
// function closeRepairIncomeDetailModal() {
//     const modal = document.getElementById('repairIncomeDetailModal');
//     modal.classList.remove('show');
// }

// Show repair profit detail modal
async function showRepairProfitDetail() {
    try {
        const modal = document.getElementById('repair-profit-detail');
        const tableBody = document.getElementById('repairProfitDetailTableBody');
        
        // Get all repairs
        const allRepairs = await API.get(API_ENDPOINTS.repairs, { store: currentStore });
        
        const now = new Date();
        const currentMonth = now.getMonth() + 1;
        const currentYear = now.getFullYear();
        
        // Get received repairs only (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡∏°‡∏µ‡∏ó‡∏±‡πâ‡∏á income ‡πÅ‡∏•‡∏∞ expense)
        const receivedRepairs = allRepairs.filter(r => {
            if (r.status !== 'received') return false;
            const returnedDate = r.returned_date || r.returnedDate;
            if (!returnedDate) return false;
            const date = new Date(returnedDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
        
        let totalIncome = 0;
        let totalExpense = 0;
        
        // Build table rows from received repairs
        const allTransactions = receivedRepairs.map(repair => {
            const repairCost = parseFloat(repair.repair_cost || 0);
            const accessoryCost = parseFloat(repair.accessory_cost || repair.accessoryCost || 0);
            const commission = parseFloat(repair.commission || 0);
            const expense = accessoryCost + commission;
            const profit = repairCost - expense;
            const returnedDate = repair.returned_date || repair.returnedDate;
            
            totalIncome += repairCost;
            totalExpense += expense;
            
            return {
                ...repair,
                income: repairCost,
                accessoryCost: accessoryCost,
                commission: commission,
                expense: expense,
                profit: profit,
                date: returnedDate,
                type: 'complete'
            };
        });

        // Sort by date (newest first)
        allTransactions.sort((a, b) => {
            const dateA = new Date(a.date || 0);
            const dateB = new Date(b.date || 0);
            return dateB - dateA; // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤
        });
        
        // Build table
        if (allTransactions.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="9" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≥‡πÑ‡∏£‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            tableBody.innerHTML = allTransactions.map(repair => {
                // Use returned_date from the repair data
                const returnedDate = repair.returned_date || repair.returnedDate || repair.date;
                const formattedDate = returnedDate ? formatDate(returnedDate) : '-';
                const profitClass = repair.profit >= 0 ? 'income-text' : 'expense-text';
                
                return `
                    <tr>
                        <td style="text-align: left;">${repair.brand || '-'}</td>
                        <td style="text-align: left;">${repair.model || '-'}</td>
                        <td style="text-align: left;">${repair.problem || '-'}</td>
                        <td style="text-align: right;">${formatCurrency(repair.income)}</td>
                        <td style="text-align: right;">${formatCurrency(repair.accessoryCost || 0)}</td>
                        <td style="text-align: right;">${formatCurrency(repair.commission || 0)}</td>
                        <td style="text-align: right;">${formatCurrency(repair.expense)}</td>
                        <td style="text-align: right;" class="${profitClass}"><strong>${formatCurrency(repair.profit)}</strong></td>
                        <td style="text-align: center;">${formattedDate}</td>
                    </tr>
                `;
            }).join('');
        }
        
        const totalProfit = totalIncome - totalExpense;

        // Update filter-info
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        const filterText = `${monthNames[currentMonth - 1]} ${currentYear + 543}`;
        document.getElementById('repairProfitMonth').textContent = filterText;
        document.getElementById('totalProfitDetail').textContent = formatCurrency(totalProfit);
        document.getElementById('repairProfitDetailCount').textContent = allTransactions.length;
        
        // Update summary cards
        document.getElementById('totalIncomeSummary').textContent = formatCurrency(totalIncome);
        document.getElementById('totalExpenseSummary').textContent = formatCurrency(totalExpense);
        document.getElementById('totalProfitDetailCard').textContent = formatCurrency(totalProfit);
        
        // Hide main page and show detail page
        document.getElementById('repair').classList.remove('active');
        document.getElementById('repair-profit-detail').classList.add('active');
        
    } catch (error) {
        console.error('Error loading repair profit detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≥‡πÑ‡∏£‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close repair profit detail modal (no longer needed)
// function closeRepairProfitDetailModal() {
//     const modal = document.getElementById('repairProfitDetailModal');
//     modal.classList.remove('show');
// }

// Save receive repair
async function saveReceiveRepair(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const repairId = formData.get('repairId');
    const cost = parseFloat(formData.get('cost'));
    const receiveDate = formData.get('receiveDate');

    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
        const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
        if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
                return;
            }

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó status ‡πÅ‡∏•‡∏∞ returned_date
        await API.put(`${API_ENDPOINTS.repairs}/${repairId}`, {
            brand: repair.brand,
            model: repair.model,
            color: repair.color,
            imei: repair.imei,
            customer_name: repair.customer_name,
            customer_phone: repair.customer_phone,
            problem: repair.problem,
            repair_cost: cost, // ‡πÉ‡∏ä‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            accessory_cost: repair.accessory_cost || repair.accessoryCost || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
            commission: repair.commission || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°
            technician: repair.technician || '', // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏ô‡∏ã‡πà‡∏≠‡∏°
            received_date: repair.received_date ? repair.received_date.split('T')[0] : null,
            appointment_date: repair.appointment_date ? repair.appointment_date.split('T')[0] : null,
            completed_date: repair.completed_date ? repair.completed_date.split('T')[0] : null,
            returned_date: receiveDate, // ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            seized_date: repair.seized_date ? repair.seized_date.split('T')[0] : null,
            status: 'received',
            warranty: repair.warranty || null, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô
            note: repair.note,
            store: repair.store
        });

            loadRepairData();
        closeReceiveRepairModal();
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
        console.error('Error saving receive repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Mark repair as returned
async function markAsReturned(repairId) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
            if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
                return;
            }

        // ‡πÄ‡∏õ‡∏¥‡∏î modal ‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
        openReturnRepairModal(repair);
    } catch (error) {
        console.error('Error loading repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Open return repair modal
function openReturnRepairModal(repair) {
    const modal = document.getElementById('returnRepairModal');
    const form = document.getElementById('returnRepairForm');

    // Reset form
    form.reset();

    // Set repair ID
    document.getElementById('returnRepairId').value = repair.id;

    // Set default values from existing repair data
    document.getElementById('returnRepairSymptom').value = repair.problem || '';
    document.getElementById('returnRepairCost').value = 0; // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô 0
    
    // Set today's date as default
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('returnRepairDate').value = today;

    // Clear note field
    document.getElementById('returnRepairNote').value = '';

    // Show modal
    modal.classList.add('show');
}

// Close return repair modal
function closeReturnRepairModal() {
    const modal = document.getElementById('returnRepairModal');
    modal.classList.remove('show');
    document.getElementById('returnRepairForm').reset();
}

// Save return repair
async function saveReturnRepair(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const repairId = formData.get('repairId');
    const symptom = formData.get('symptom');
    const cost = parseFloat(formData.get('cost'));
    const returnDate = formData.get('returnDate');
    const note = formData.get('note') || '';

    if (!note.trim()) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏ó‡∏µ‡πà‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
            icon: 'warning'
        });
        return;
    }

    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
        const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
        if (!repair) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                icon: 'error'
            });
            return;
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á note ‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡πÉ‡∏´‡∏°‡πà
        let updatedNote = note.trim();
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ note ‡πÄ‡∏î‡∏¥‡∏° ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡πà‡∏≠
        if (repair.note) {
            updatedNote = repair.note + '\n\n‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏ó‡∏µ‡πà‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á: ' + updatedNote;
        } else {
            updatedNote = '‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏ó‡∏µ‡πà‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á: ' + updatedNote;
            }

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó status, note ‡πÅ‡∏•‡∏∞ returned_date
        await API.put(`${API_ENDPOINTS.repairs}/${repairId}`, {
            brand: repair.brand,
            model: repair.model,
            color: repair.color,
            imei: repair.imei,
            customer_name: repair.customer_name,
            customer_phone: repair.customer_phone,
            problem: symptom, // ‡πÉ‡∏ä‡πâ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            repair_cost: cost, // ‡πÉ‡∏ä‡πâ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            accessory_cost: repair.accessory_cost || repair.accessoryCost || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
            commission: repair.commission || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°
            technician: repair.technician || '', // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏ô‡∏ã‡πà‡∏≠‡∏°
            received_date: repair.received_date ? repair.received_date.split('T')[0] : null,
            appointment_date: repair.appointment_date ? repair.appointment_date.split('T')[0] : null,
            completed_date: repair.completed_date ? repair.completed_date.split('T')[0] : null,
            returned_date: returnDate, // ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            seized_date: repair.seized_date ? repair.seized_date.split('T')[0] : null,
            status: 'returned',
            warranty: repair.warranty || null, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô
            note: updatedNote,
            store: repair.store
        });

            loadRepairData();
        closeReturnRepairModal();
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
        console.error('Error saving return repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Mark repair as pending (back to waiting)
async function markAsPending(repairId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
            if (!repair) {
                await customAlert({
                    title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                    message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°',
                    icon: 'error'
                });
                return;
            }

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó status ‡πÄ‡∏õ‡πá‡∏ô pending
        await API.put(`${API_ENDPOINTS.repairs}/${repairId}`, {
            brand: repair.brand,
            model: repair.model,
            color: repair.color,
            imei: repair.imei,
            customer_name: repair.customer_name,
            customer_phone: repair.customer_phone,
            problem: repair.problem,
            repair_cost: repair.repair_cost,
            accessory_cost: 0, // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°
            commission: 0, // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°
            technician: '', // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏Ñ‡∏ô‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°
            received_date: repair.received_date ? repair.received_date.split('T')[0] : null,
            appointment_date: null, // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå appointment_date ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°
            completed_date: null, // ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå completed_date ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°
            returned_date: repair.returned_date ? repair.returned_date.split('T')[0] : null,
            seized_date: repair.seized_date ? repair.seized_date.split('T')[0] : null,
            status: 'pending',
            warranty: repair.warranty || null, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô
            note: repair.note,
            store: repair.store
        });
            loadRepairData();
            showNotification('‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            console.error('Error marking as pending:', error);
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÑ‡∏î‡πâ',
                icon: 'error',
                confirmType: 'danger'
            });
        }
    }
}

// Delete repair
async function deleteRepair(repairId) {
    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
        const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
        if (!repair) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
                icon: 'error'
            });
            return;
        }

        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
            message: '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? ‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ',
            icon: 'warning',
            confirmText: '‡∏•‡∏ö',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType: 'danger',
            list: [
                { icon: 'info', iconSymbol: 'üì±', text: `${repair.brand} ${repair.model} (${repair.color})` },
                { icon: 'info', iconSymbol: 'üîß', text: `‡∏≠‡∏≤‡∏Å‡∏≤‡∏£: ${repair.problem || '-'}` },
                { icon: 'info', iconSymbol: 'üí∞', text: `‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡πà‡∏≠‡∏°: ${formatCurrency(repair.repair_cost)}` },
                { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏ñ‡∏≤‡∏ß‡∏£‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö' }
            ]
        });

        if (confirmed) {
            await API.delete(`${API_ENDPOINTS.repairs}/${repairId}`);
            loadRepairData();
            showNotification('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
            console.log(`‚úÖ ‡∏•‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏° ID: ${repairId}`);
        }
        } catch (error) {
        console.error('Error deleting repair:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Seize repair device
async function seizeRepair(repairId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
            if (!repair) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°');
                return;
            }

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó status ‡πÅ‡∏•‡∏∞ seized_date
        await API.put(`${API_ENDPOINTS.repairs}/${repairId}`, {
            brand: repair.brand,
            model: repair.model,
            color: repair.color,
            imei: repair.imei,
            customer_name: repair.customer_name,
            customer_phone: repair.customer_phone,
            problem: repair.problem,
            repair_cost: repair.repair_cost,
            accessory_cost: repair.accessory_cost || repair.accessoryCost || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
            commission: repair.commission || 0, // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°
            technician: repair.technician || '', // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏ô‡∏ã‡πà‡∏≠‡∏°
            received_date: repair.received_date ? repair.received_date.split('T')[0] : null,
            appointment_date: repair.appointment_date ? repair.appointment_date.split('T')[0] : null,
            completed_date: repair.completed_date ? repair.completed_date.split('T')[0] : null,
            returned_date: repair.returned_date ? repair.returned_date.split('T')[0] : null,
            status: 'seized',
            seized_date: new Date().toISOString().split('T')[0],
            warranty: repair.warranty || null, // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô
            note: repair.note,
            store: repair.store
        });
            loadRepairData();
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
            console.error(error);
        }
    }
}

// Send seized repair to used devices
async function sendToUsedDevices(repairId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏∂‡∏î
            const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
            if (!repair) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°');
                return;
            }

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á - ‡∏•‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°
            const usedDeviceData = {
                id: 'U' + Date.now().toString(),
                brand: repair.brand,
                model: repair.model,
                color: repair.color,
                imei: repair.imei,
                ram: '-', // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏° ‡πÉ‡∏´‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
                rom: '-', // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏° ‡πÉ‡∏´‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
                device_condition: '-', // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏° ‡πÉ‡∏´‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
                purchase_price: 0, // ‡πÉ‡∏´‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
                import_date: new Date().toISOString().split('T')[0],
                sale_price: null,
                sale_date: null,
                status: 'stock',
                note: `‡∏¢‡∏∂‡∏î‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏° - ‡∏≠‡∏≤‡∏Å‡∏≤‡∏£: ${repair.problem || '-'}`,
                store: repair.store
            };

            // ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á
            await API.post(API_ENDPOINTS.usedDevices, usedDeviceData);

            // ‡∏•‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°
            await API.delete(`${API_ENDPOINTS.repairs}/${repairId}`);

            loadRepairData();
            showNotification('‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç RAM, ROM, ‡∏™‡∏†‡∏≤‡∏û‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á ‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏Ñ‡∏≤‡∏£‡∏±‡∏ö‡∏ã‡∏∑‡πâ‡∏≠');
        } catch (error) {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
            console.error(error);
        }
    }
}

// Update repair tab counts
function updateRepairTabCounts() {
    const storeRepairs = repairDevices.filter(r => r.store === currentStore);

    // Count repairs by status
    const pendingCount = storeRepairs.filter(r => r.status === 'pending').length;
    const inRepairCount = storeRepairs.filter(r => r.status === 'in-repair').length;
    const completedCount = storeRepairs.filter(r => r.status === 'completed').length;
    const returnedCount = storeRepairs.filter(r => r.status === 'returned').length;
    const receivedCount = storeRepairs.filter(r => r.status === 'received').length;

    // Update tab counts
    const pendingCountElement = document.getElementById('repairPendingCount');
    const inRepairCountElement = document.getElementById('repairInRepairCount');
    const completedCountElement = document.getElementById('repairCompletedCount');
    const returnedCountElement = document.getElementById('repairReturnedCount');
    const receivedCountElement = document.getElementById('repairReceivedCount');

    if (pendingCountElement) pendingCountElement.textContent = pendingCount;
    if (inRepairCountElement) inRepairCountElement.textContent = inRepairCount;
    if (completedCountElement) completedCountElement.textContent = completedCount;
    if (returnedCountElement) returnedCountElement.textContent = returnedCount;
    if (receivedCountElement) receivedCountElement.textContent = receivedCount;
}

// Initialize repair search
function initializeRepairSearch() {
    const searchInput = document.getElementById('searchRepair');
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            filterRepairs(searchTerm);
        });
    }
}

// Filter repairs based on search term
function filterRepairs(searchTerm) {
    // Pending, In-repair, Completed: Show current data always (no date filter)
    let pendingRepairs = repairDevices.filter(r => r.store === currentStore && r.status === 'pending');

    // Apply search filter
    if (searchTerm) {
        pendingRepairs = pendingRepairs.filter(repair => {
            const problem = repair.problem || repair.symptom || '';
            return repair.brand.toLowerCase().includes(searchTerm) ||
                   repair.model.toLowerCase().includes(searchTerm) ||
                   repair.color.toLowerCase().includes(searchTerm) ||
                   (repair.imei && repair.imei.toLowerCase().includes(searchTerm)) ||
                   problem.toLowerCase().includes(searchTerm);
        });
    }

    displayRepairs(pendingRepairs, 'repairPendingTableBody', 'pending');

    let inRepairRepairs = repairDevices.filter(r => r.store === currentStore && r.status === 'in-repair');

    // Apply search filter
    if (searchTerm) {
        inRepairRepairs = inRepairRepairs.filter(repair => {
            const problem = repair.problem || repair.symptom || '';
            return repair.brand.toLowerCase().includes(searchTerm) ||
                   repair.model.toLowerCase().includes(searchTerm) ||
                   repair.color.toLowerCase().includes(searchTerm) ||
                   (repair.imei && repair.imei.toLowerCase().includes(searchTerm)) ||
                   problem.toLowerCase().includes(searchTerm);
        });
    }

    displayRepairs(inRepairRepairs, 'repairInRepairTableBody', 'in-repair');

    let completedRepairs = repairDevices.filter(r => r.store === currentStore && r.status === 'completed');

    // Apply search filter
    if (searchTerm) {
        completedRepairs = completedRepairs.filter(repair => {
            const problem = repair.problem || repair.symptom || '';
            return repair.brand.toLowerCase().includes(searchTerm) ||
                   repair.model.toLowerCase().includes(searchTerm) ||
                   repair.color.toLowerCase().includes(searchTerm) ||
                   (repair.imei && repair.imei.toLowerCase().includes(searchTerm)) ||
                   problem.toLowerCase().includes(searchTerm);
        });
    }

    displayRepairs(completedRepairs, 'repairCompletedTableBody', 'completed');

    // Returned: Filter by date and search
    let returnedRepairs = repairDevices.filter(r => r.store === currentStore && r.status === 'returned');

    // Apply date filter
    if (currentRepairFilter.month || currentRepairFilter.year) {
        returnedRepairs = returnedRepairs.filter(repair => {
            const returnDate = repair.returned_date || repair.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            const repairMonth = date.getMonth() + 1;
            const repairYear = date.getFullYear();

            const monthMatch = !currentRepairFilter.month || repairMonth == currentRepairFilter.month;
            const yearMatch = !currentRepairFilter.year || repairYear == currentRepairFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        returnedRepairs = returnedRepairs.filter(repair => {
            const returnDate = repair.returned_date || repair.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter
    if (searchTerm) {
        returnedRepairs = returnedRepairs.filter(repair => {
            const problem = repair.problem || repair.symptom || '';
            return repair.brand.toLowerCase().includes(searchTerm) ||
                   repair.model.toLowerCase().includes(searchTerm) ||
                   repair.color.toLowerCase().includes(searchTerm) ||
                   (repair.imei && repair.imei.toLowerCase().includes(searchTerm)) ||
                   problem.toLowerCase().includes(searchTerm);
        });
    }

    displayRepairs(returnedRepairs, 'repairReturnedTableBody', 'returned');

    // Received: Filter by date and search
    let receivedRepairs = repairDevices.filter(r => r.store === currentStore && r.status === 'received');

    // Apply date filter
    if (currentRepairFilter.month || currentRepairFilter.year) {
        receivedRepairs = receivedRepairs.filter(repair => {
            const returnDate = repair.returned_date || repair.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            const repairMonth = date.getMonth() + 1;
            const repairYear = date.getFullYear();

            const monthMatch = !currentRepairFilter.month || repairMonth == currentRepairFilter.month;
            const yearMatch = !currentRepairFilter.year || repairYear == currentRepairFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        receivedRepairs = receivedRepairs.filter(repair => {
            const returnDate = repair.returned_date || repair.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter
    if (searchTerm) {
        receivedRepairs = receivedRepairs.filter(repair => {
            const problem = repair.problem || repair.symptom || '';
            return repair.brand.toLowerCase().includes(searchTerm) ||
                   repair.model.toLowerCase().includes(searchTerm) ||
                   repair.color.toLowerCase().includes(searchTerm) ||
                   (repair.imei && repair.imei.toLowerCase().includes(searchTerm)) ||
                   problem.toLowerCase().includes(searchTerm);
        });
    }

    // Sort by returned_date (newest first)
    receivedRepairs.sort((a, b) => {
        const dateA = new Date(a.returned_date || a.returnedDate || 0);
        const dateB = new Date(b.returned_date || b.returnedDate || 0);
        return dateB - dateA; // descending order (newest first)
    });

    displayRepairs(receivedRepairs, 'repairReceivedTableBody', 'received');
}

// Initialize date filter for repair
function initializeRepairDateFilter() {
    const monthSelect = document.getElementById('filterRepairMonth');
    const yearSelect = document.getElementById('filterRepairYear');

    if (!monthSelect || !yearSelect) return;

    // Clear existing options except the first one
    while (monthSelect.options.length > 1) {
        monthSelect.remove(1);
    }
    while (yearSelect.options.length > 1) {
        yearSelect.remove(1);
    }

    // Populate months
    const thaiMonthsShort = ['‡∏°.‡∏Ñ.', '‡∏Å.‡∏û.', '‡∏°‡∏µ.‡∏Ñ.', '‡πÄ‡∏°.‡∏¢.', '‡∏û.‡∏Ñ.', '‡∏°‡∏¥.‡∏¢.', '‡∏Å.‡∏Ñ.', '‡∏™.‡∏Ñ.', '‡∏Å.‡∏¢.', '‡∏ï.‡∏Ñ.', '‡∏û.‡∏¢.', '‡∏ò.‡∏Ñ.'];
    for (let i = 0; i < 12; i++) {
        const option = document.createElement('option');
        option.value = i + 1;
        option.textContent = thaiMonthsShort[i];
        monthSelect.appendChild(option);
    }

    // Populate years - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏õ‡∏µ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    const currentYear = new Date().getFullYear(); // ‡∏Ñ.‡∏®.
    const currentYearBE = currentYear + 543; // ‡∏û.‡∏®.
    for (let yearBE = currentYearBE; yearBE >= currentYearBE - 3; yearBE--) {
        const yearCE = yearBE - 543;
        const option = document.createElement('option');
        option.value = yearCE;
        option.textContent = yearBE;
        yearSelect.appendChild(option);
    }
}

// Filter repair by date range
async function filterRepairByDateRange() {
    // Use filter from currentRepairFilter (set by header filter)
    console.log('üîç Filtering Repair:', currentRepairFilter);

    try {
        // Get all repairs from API
        const allRepairs = await API.get(API_ENDPOINTS.repairs, { store: currentStore });

        // Update global repairDevices for use in search and other functions
        repairDevices = allRepairs;

        // Pending, In-repair, Completed: Show ALL data always (no date filter)
        const pendingRepairs = allRepairs.filter(r => r.status === 'pending');
        displayRepairs(pendingRepairs, 'repairPendingTableBody', 'pending');

        const inRepairRepairs = allRepairs.filter(r => r.status === 'in-repair');
        displayRepairs(inRepairRepairs, 'repairInRepairTableBody', 'in-repair');

        const completedRepairs = allRepairs.filter(r => r.status === 'completed');
        displayRepairs(completedRepairs, 'repairCompletedTableBody', 'completed');

        // Returned, Received, Seized: Filter by date range (default to current month if no filter)
        let returnedRepairs = allRepairs.filter(r => r.status === 'returned');
        let receivedRepairs = allRepairs.filter(r => r.status === 'received');
        let seizedRepairs = allRepairs.filter(r => r.status === 'seized');

        if (currentRepairFilter.startDate || currentRepairFilter.endDate) {
            // Use date range filter
            returnedRepairs = returnedRepairs.filter(repair => {
                const returnedDate = repair.returned_date || repair.returnedDate;
                if (!returnedDate) return false;
                const date = new Date(returnedDate);
                const startMatch = !currentRepairFilter.startDate || 
                                  date >= new Date(currentRepairFilter.startDate);
                const endMatch = !currentRepairFilter.endDate || 
                                date <= new Date(currentRepairFilter.endDate);
                return startMatch && endMatch;
            });

            receivedRepairs = receivedRepairs.filter(repair => {
                const returnedDate = repair.returned_date || repair.returnedDate;
                if (!returnedDate) return false;
                const date = new Date(returnedDate);
                const startMatch = !currentRepairFilter.startDate || 
                                  date >= new Date(currentRepairFilter.startDate);
                const endMatch = !currentRepairFilter.endDate || 
                                date <= new Date(currentRepairFilter.endDate);
                return startMatch && endMatch;
            });

            seizedRepairs = seizedRepairs.filter(repair => {
                const seizedDate = repair.seized_date || repair.seizedDate;
                if (!seizedDate) return false;
                const date = new Date(seizedDate);
                const startMatch = !currentRepairFilter.startDate || 
                                  date >= new Date(currentRepairFilter.startDate);
                const endMatch = !currentRepairFilter.endDate || 
                                date <= new Date(currentRepairFilter.endDate);
                return startMatch && endMatch;
            });
        } else {
            // No filter: show current month only
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();

            returnedRepairs = returnedRepairs.filter(repair => {
                const returnedDate = repair.returned_date || repair.returnedDate;
                if (!returnedDate) return false;
                const date = new Date(returnedDate);
                return date.getMonth() + 1 === currentMonth && 
                       date.getFullYear() === currentYear;
            });

            receivedRepairs = receivedRepairs.filter(repair => {
                const returnedDate = repair.returned_date || repair.returnedDate;
                if (!returnedDate) return false;
                const date = new Date(returnedDate);
                return date.getMonth() + 1 === currentMonth && 
                       date.getFullYear() === currentYear;
            });

            seizedRepairs = seizedRepairs.filter(repair => {
                const seizedDate = repair.seized_date || repair.seizedDate;
                if (!seizedDate) return false;
                const date = new Date(seizedDate);
                return date.getMonth() + 1 === currentMonth && 
                       date.getFullYear() === currentYear;
            });
        }

        // Sort by returned_date (newest first)
        receivedRepairs.sort((a, b) => {
            const dateA = new Date(a.returned_date || a.returnedDate || 0);
            const dateB = new Date(b.returned_date || b.returnedDate || 0);
            return dateB - dateA; // descending order (newest first)
        });

        displayRepairs(returnedRepairs, 'repairReturnedTableBody', 'returned');
        displayRepairs(receivedRepairs, 'repairReceivedTableBody', 'received');
        displayRepairs(seizedRepairs, 'repairSeizedTableBody', 'seized');

        // Update tab counts
        const pendingCountElement = document.getElementById('repairPendingCount');
        const inRepairCountElement = document.getElementById('repairInRepairCount');
        const completedCountElement = document.getElementById('repairCompletedCount');
        const returnedCountElement = document.getElementById('repairReturnedCount');
        const receivedCountElement = document.getElementById('repairReceivedCount');
        const seizedCountElement = document.getElementById('repairSeizedCount');

        if (pendingCountElement) pendingCountElement.textContent = pendingRepairs.length;
        if (inRepairCountElement) inRepairCountElement.textContent = inRepairRepairs.length;
        if (completedCountElement) completedCountElement.textContent = completedRepairs.length;
        if (returnedCountElement) returnedCountElement.textContent = returnedRepairs.length;
        if (receivedCountElement) receivedCountElement.textContent = receivedRepairs.length;
        if (seizedCountElement) seizedCountElement.textContent = seizedRepairs.length;

        // Update dashboard cards
        updateRepairDashboardCards(allRepairs);
    } catch (error) {
        console.error('Error loading repairs:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
    }
}

// Update repair dashboard cards
function updateRepairDashboardCards(allRepairs) {
    // Filter by current store
    const storeRepairs = allRepairs.filter(r => r.store === currentStore);

    // ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏à‡∏≤‡∏Å currentRepairFilter ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ ‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô‡πÉ‡∏ä‡πâ currentMonth
    let selectedYear, selectedMonth;
    
    if (currentRepairFilter.startDate) {
        // ‡πÉ‡∏ä‡πâ startDate ‡∏à‡∏≤‡∏Å filter (format: YYYY-MM-DD)
        const [year, month] = currentRepairFilter.startDate.split('-').map(Number);
        selectedYear = year;
        selectedMonth = month;
        console.log('üîß [DEBUG] Using filter startDate:', currentRepairFilter.startDate);
    } else {
        // ‡πÉ‡∏ä‡πâ currentMonth (format: YYYY-MM)
        [selectedYear, selectedMonth] = currentMonth.split('-').map(Number);
        console.log('üîß [DEBUG] Using currentMonth:', currentMonth);
    }
    
    console.log('üîß [DEBUG] Parsed - selectedYear:', selectedYear, 'selectedMonth:', selectedMonth);
    console.log('üîß [Repair Dashboard] Store:', currentStore);
    console.log('üîß [Repair Dashboard] Total repairs in store:', storeRepairs.length);
    console.log('üîß [Repair Dashboard] Selected Month/Year:', selectedMonth, '/', selectedYear);
    
    // Debug: ‡πÅ‡∏™‡∏î‡∏á field names ‡∏Ç‡∏≠‡∏á repair ‡πÅ‡∏£‡∏Å
    if (storeRepairs.length > 0) {
        console.log('üîç Sample repair fields:', Object.keys(storeRepairs[0]));
        console.log('üîç Sample repair data:', {
            id: storeRepairs[0].id,
            status: storeRepairs[0].status,
            receive_date: storeRepairs[0].receive_date,
            receiveDate: storeRepairs[0].receiveDate,
            received_date: storeRepairs[0].received_date,
            receivedDate: storeRepairs[0].receivedDate
        });
    }
    
    // 1. ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°: ‡∏ô‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏≤‡∏ã‡πà‡∏≠‡∏° (received_date)
    let activeCountItems;
    
    if (currentRepairFilter.startDate || currentRepairFilter.endDate) {
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        console.log(`\nüîç [Card 1: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°] Filtering by date range: ${currentRepairFilter.startDate} to ${currentRepairFilter.endDate}`);
        activeCountItems = storeRepairs.filter(r => {
            const receivedDate = r.received_date || r.receivedDate || r.receive_date || r.receiveDate;
            
            if (!receivedDate) {
        return false;
            }
            
            const date = new Date(receivedDate);
            const startMatch = !currentRepairFilter.startDate || 
                              date >= new Date(currentRepairFilter.startDate);
            const endMatch = !currentRepairFilter.endDate || 
                            date <= new Date(currentRepairFilter.endDate);
            
            const isMatch = startMatch && endMatch;
            console.log(`  ${isMatch ? '‚úÖ' : '‚ùå'} Repair ID ${r.id}: ${receivedDate}`);
            
            return isMatch;
        });
    } else {
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        console.log(`\nüîç [Card 1: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°] Filtering by current month: ${selectedMonth}/${selectedYear}`);
        activeCountItems = storeRepairs.filter(r => {
            const receivedDate = r.received_date || r.receivedDate || r.receive_date || r.receiveDate;
            
            if (!receivedDate) {
                return false;
            }
            
            const date = new Date(receivedDate);
            const repairMonth = date.getMonth() + 1;
            const repairYear = date.getFullYear();
            const isMatch = repairMonth === selectedMonth && repairYear === selectedYear;
            
            console.log(`  ${isMatch ? '‚úÖ' : '‚ùå'} Repair ID ${r.id}: ${receivedDate} => ${repairMonth}/${repairYear}`);
            
            return isMatch;
        });
    }
    
    const activeCount = activeCountItems.length;
    console.log(`‚úÖ [Card 1] Result: ${activeCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n`);

    // 2. ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô + ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏° ‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à (completed_date)
    let expense = 0;
    let completedRepairsForExpense;
    
    if (currentRepairFilter.startDate || currentRepairFilter.endDate) {
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        console.log(`üîç [Card 2: ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢] Filtering by date range: ${currentRepairFilter.startDate} to ${currentRepairFilter.endDate}`);
        completedRepairsForExpense = storeRepairs.filter(r => {
            if (r.status !== 'completed' && r.status !== 'received') {
                return false;
            }
        
        const completedDate = r.completed_date || r.completedDate;
            if (!completedDate) {
                return false;
            }
        
            const date = new Date(completedDate);
            const startMatch = !currentRepairFilter.startDate || 
                              date >= new Date(currentRepairFilter.startDate);
            const endMatch = !currentRepairFilter.endDate || 
                            date <= new Date(currentRepairFilter.endDate);
            
            const isMatch = startMatch && endMatch;
            console.log(`  ${isMatch ? '‚úÖ' : '‚ùå'} Repair ID ${r.id}: ${completedDate}`);
            
            return isMatch;
        });
        } else {
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        console.log(`üîç [Card 2: ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢] Filtering by current month: ${selectedMonth}/${selectedYear}`);
        completedRepairsForExpense = storeRepairs.filter(r => {
            if (r.status !== 'completed' && r.status !== 'received') {
                return false;
            }
            
            const completedDate = r.completed_date || r.completedDate;
            if (!completedDate) {
                return false;
            }
            
            const date = new Date(completedDate);
            const month = date.getMonth() + 1;
            const year = date.getFullYear();
            const isMatch = month === selectedMonth && year === selectedYear;
            
            console.log(`  ${isMatch ? '‚úÖ' : '‚ùå'} Repair ID ${r.id}: ${completedDate} => ${month}/${year}`);
            
            return isMatch;
        });
    }

    // ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ = accessory_cost + commission (‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ‡∏ï‡∏≠‡∏ô‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à)
    // ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏£‡∏ß‡∏°‡∏î‡πâ‡∏ß‡∏¢
    let totalCommission = 0;
    expense = completedRepairsForExpense.reduce((sum, r) => {
        const accessoryCost = parseFloat(r.accessory_cost || r.accessoryCost || 0);
        const commission = parseFloat(r.commission || 0);
        totalCommission += commission;
        return sum + accessoryCost + commission;
    }, 0);
    console.log(`‚úÖ [Card 2] Result: ${completedRepairsForExpense.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£, ‡∏ø${expense.toLocaleString()}, Commission: ‡∏ø${totalCommission.toLocaleString()}\n`);

    // 3. ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: ‡∏Ñ‡πà‡∏≤‡∏ã‡πà‡∏≠‡∏°‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (received) ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (returned_date)
    let income = 0;
    let receivedRepairsForIncome;
    
    if (currentRepairFilter.startDate || currentRepairFilter.endDate) {
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° date range ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        console.log(`üîç [Card 3: ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö] Filtering by date range: ${currentRepairFilter.startDate} to ${currentRepairFilter.endDate}`);
        receivedRepairsForIncome = storeRepairs.filter(r => {
            if (r.status !== 'received') {
                return false;
            }
        
        const returnedDate = r.returned_date || r.returnedDate;
            if (!returnedDate) {
                return false;
            }
        
            const date = new Date(returnedDate);
            const startMatch = !currentRepairFilter.startDate || 
                              date >= new Date(currentRepairFilter.startDate);
            const endMatch = !currentRepairFilter.endDate || 
                            date <= new Date(currentRepairFilter.endDate);
            
            const isMatch = startMatch && endMatch;
            console.log(`  ${isMatch ? '‚úÖ' : '‚ùå'} Repair ID ${r.id}: ${returnedDate}`);
            
            return isMatch;
        });
        } else {
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        console.log(`üîç [Card 3: ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö] Filtering by current month: ${selectedMonth}/${selectedYear}`);
        receivedRepairsForIncome = storeRepairs.filter(r => {
            if (r.status !== 'received') {
                return false;
            }
            
            const returnedDate = r.returned_date || r.returnedDate;
            if (!returnedDate) {
                return false;
            }
            
            const date = new Date(returnedDate);
            const month = date.getMonth() + 1;
            const year = date.getFullYear();
            const isMatch = month === selectedMonth && year === selectedYear;
            
            console.log(`  ${isMatch ? '‚úÖ' : '‚ùå'} Repair ID ${r.id}: ${returnedDate} => ${month}/${year}`);
            
            return isMatch;
        });
    }

    // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö = repair_cost (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡πà‡∏≠‡∏°) ‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß
    income = receivedRepairsForIncome.reduce((sum, r) => {
        const cost = parseFloat(r.repair_cost || r.price || 0);
        return sum + cost;
    }, 0);
    console.log(`‚úÖ [Card 3] Result: ${receivedRepairsForIncome.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£, ‡∏ø${income.toLocaleString()}\n`);

    // 4. ‡∏Å‡∏≥‡πÑ‡∏£: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á (returned_date) ‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
    // ‡∏Å‡∏≥‡πÑ‡∏£ = repair_cost - (accessory_cost + commission)
    console.log(`üîç [Card 4: ‡∏Å‡∏≥‡πÑ‡∏£] Calculating from same ${receivedRepairsForIncome.length} items`);
    const profitFromReceived = receivedRepairsForIncome.reduce((sum, r) => {
        const repairCost = parseFloat(r.repair_cost || r.price || 0);
        const accessoryCost = parseFloat(r.accessory_cost || r.accessoryCost || 0);
        const commission = parseFloat(r.commission || 0);
        return sum + (repairCost - accessoryCost - commission);
    }, 0);
    
    const profit = profitFromReceived;
    console.log(`‚úÖ [Card 4] Result: ‡∏ø${profit.toLocaleString()}\n`);

    console.log(`üìä [SUMMARY] For ${selectedMonth}/${selectedYear}:`);
    console.log(`   ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°: ${activeCount} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
    console.log(`   ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: ‡∏ø${expense.toLocaleString()}`);
    console.log(`   ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: ‡∏ø${income.toLocaleString()}`);
    console.log(`   ‡∏Å‡∏≥‡πÑ‡∏£: ‡∏ø${profit.toLocaleString()}\n`);

    // Update UI
    const activeCountElement = document.getElementById('repairActiveCount');
    const commissionElement = document.getElementById('repairCommission');
    const expenseElement = document.getElementById('repairExpense');
    const incomeElement = document.getElementById('repairIncome');
    const profitElement = document.getElementById('repairProfit');

    if (activeCountElement) {
        activeCountElement.textContent = activeCount;
    }

    if (commissionElement) {
        commissionElement.textContent = formatCurrency(totalCommission);
    }

    if (expenseElement) {
        expenseElement.textContent = formatCurrency(expense);
    }

    if (incomeElement) {
        incomeElement.textContent = formatCurrency(income);
    }

    if (profitElement) {
        profitElement.textContent = formatCurrency(profit);
        // Change color based on profit/loss
        const profitCard = profitElement.closest('.page-stat-card');
        if (profitCard) {
            profitCard.classList.remove('negative');
            if (profit < 0) {
                profitCard.classList.add('negative');
            }
        }
    }

    console.log('üìä Repair Dashboard Cards Updated:', {
        activeCount,
        breakdown: {
            currentMonth: activeCountItems.length
        },
        completedCount: completedRepairsForExpense.length,
        receivedCount: receivedRepairsForIncome.length,
        expense: formatCurrency(expense) + ' (‡∏ß‡∏±‡∏ô‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô + ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°)',
        income: formatCurrency(income) + ' (‡∏ß‡∏±‡∏ô‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á: ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡πà‡∏≠‡∏°)',
        profit: formatCurrency(profit) + ' (‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö - ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢)'
    });
}

// Close repair modal when clicking outside
window.addEventListener('click', function(event) {
    const repairModal = document.getElementById('repairModal');
    if (event.target === repairModal) {
        closeRepairModal();
    }
});

// ===== INSTALLMENT DEVICES (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ú‡πà‡∏≠‡∏ô) =====

// Mock data for installment devices

// Initialize installment devices database
async function initializeInstallmentDatabase() {
    try {
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API ‡πÅ‡∏ó‡∏ô localStorage
        installmentDevices = await API.get(API_ENDPOINTS.installments);
        console.log('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ú‡πà‡∏≠‡∏ô‡∏à‡∏≤‡∏Å API ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        console.log(`üìä ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${installmentDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        loadInstallmentData();
    } catch (error) {
        console.error('Error loading installments from API:', error);
        installmentDevices = [];
    }
}

// ===== INSTALLMENT DEVICES CRUD FUNCTIONS =====

// Initialize installment tabs
function initializeInstallmentTabs() {
    const tabButtons = document.querySelectorAll('#installment .tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');

            // Remove active class from all installment tabs and contents
            document.querySelectorAll('#installment .tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#installment .tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            this.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        });
    });
}

// Calculate installment amount (optional helper - user can override)
function calculateInstallment() {
    // This function is no longer called automatically
    // User can manually input the installment amount
    // Keep this function for future use if needed
}

// Calculate next due date from down payment date (next month, same day)
function calculateNextDueDate() {
    const downPaymentDateInput = document.getElementById('downPaymentDate');
    const nextDueDateInput = document.getElementById('nextDueDate');

    if (downPaymentDateInput && downPaymentDateInput.value) {
        const downPaymentDate = new Date(downPaymentDateInput.value);
        // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
        downPaymentDate.setMonth(downPaymentDate.getMonth() + 1);
        const nextDueDate = downPaymentDate.toISOString().split('T')[0];

        if (nextDueDateInput) {
            nextDueDateInput.value = nextDueDate;
            console.log('üìÖ Next due date calculated:', {
                downPayment: downPaymentDateInput.value,
                nextDue: nextDueDate,
                method: 'Next month, same day'
            });
        }
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏ß‡∏î‡∏ú‡πà‡∏≠‡∏ô
        updateInstallmentSchedule();
    }
}

// Update installment schedule table
function updateInstallmentSchedule() {
    const downPaymentDate = document.getElementById('downPaymentDate')?.value;
    const scheduleContainer = document.getElementById('installmentSchedule');

    // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡∏≤‡∏° installment type
    let totalInstallments, installmentAmount;
    if (currentInstallmentType === 'store') {
        totalInstallments = parseInt(document.getElementById('totalInstallmentsStore')?.value) || 0;
        installmentAmount = parseFloat(document.getElementById('installmentAmountStore')?.value) || 0;
    } else {
        totalInstallments = parseInt(document.getElementById('totalInstallments')?.value) || 0;
        installmentAmount = parseFloat(document.getElementById('installmentAmount')?.value) || 0;
    }

    if (!scheduleContainer || !downPaymentDate || totalInstallments === 0) {
        if (scheduleContainer) scheduleContainer.innerHTML = '';
        return;
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏ß‡∏î‡∏ú‡πà‡∏≠‡∏ô
    let scheduleHTML = '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">';
    scheduleHTML += '<h4 style="margin: 0 0 15px 0; color: #6366f1;">üìÖ ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏ä‡∏≥‡∏£‡∏∞</h4>';
    scheduleHTML += '<table style="width: 100%; border-collapse: collapse;">';
    scheduleHTML += '<thead><tr>';
    scheduleHTML += '<th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background: white;">‡∏á‡∏ß‡∏î‡∏ó‡∏µ‡πà</th>';
    scheduleHTML += '<th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background: white;">‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î</th>';
    scheduleHTML += '<th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd; background: white;">‡∏¢‡∏≠‡∏î‡∏ä‡∏≥‡∏£‡∏∞</th>';
    scheduleHTML += '</tr></thead><tbody>';
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏á‡∏ß‡∏î
    const baseDate = new Date(downPaymentDate);
    for (let i = 1; i <= totalInstallments; i++) {
        const dueDate = new Date(baseDate);
        dueDate.setMonth(baseDate.getMonth() + i); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏µ‡∏•‡∏∞ 1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
        
        const dueDateStr = dueDate.toLocaleDateString('th-TH', {
            day: 'numeric',
            month: 'numeric',
            year: 'numeric'
        });
        
        scheduleHTML += '<tr style="border-bottom: 1px solid #eee;">';
        scheduleHTML += `<td style="padding: 10px; background: white;">‡∏á‡∏ß‡∏î‡∏ó‡∏µ‡πà ${i}</td>`;
        scheduleHTML += `<td style="padding: 10px; background: white;">${dueDateStr}</td>`;
        scheduleHTML += `<td style="padding: 10px; text-align: right; background: white; font-weight: 600; color: #10b981;">‡∏ø${installmentAmount.toLocaleString('th-TH', {minimumFractionDigits: 2})}</td>`;
        scheduleHTML += '</tr>';
    }
    
    scheduleHTML += '</tbody></table>';
    scheduleHTML += `<div style="margin-top: 15px; padding: 10px; background: white; border-radius: 6px; display: flex; justify-content: space-between; font-weight: 600;">`;
    scheduleHTML += `<span>‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${totalInstallments} ‡∏á‡∏ß‡∏î</span>`;
    scheduleHTML += `<span style="color: #6366f1;">‡∏ø${(installmentAmount * totalInstallments).toLocaleString('th-TH', {minimumFractionDigits: 2})}</span>`;
    scheduleHTML += '</div></div>';
    
    scheduleContainer.innerHTML = scheduleHTML;
}

// Calculate commission (10% of sale price - down payment) - ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏≠‡∏á
function calculateCommission() {
    // ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÄ‡∏≠‡∏á
    /*
    const salePriceInput = document.getElementById('installmentSalePrice');
    const downPaymentInput = document.getElementById('downPayment');
    const commissionInput = document.getElementById('commission');

    if (salePriceInput && downPaymentInput && commissionInput && currentInstallmentType === 'partner') {
        const salePrice = parseFloat(salePriceInput.value) || 0;
        const downPayment = parseFloat(downPaymentInput.value) || 0;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°: 10% ‡∏Ç‡∏≠‡∏á (‡∏¢‡∏≠‡∏î‡∏à‡∏±‡∏î - ‡πÄ‡∏á‡∏¥‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå)
        const commission = (salePrice - downPayment) * 0.10;

        commissionInput.value = commission.toFixed(2);

        console.log('üí∞ Commission calculated:', {
            salePrice,
            downPayment,
            commission: commission.toFixed(2)
        });
    }
    */
}

// Handle installment type change
function handleInstallmentTypeChange() {
    const installmentTypeSelect = document.getElementById('installmentType');
    const selectedType = installmentTypeSelect.value;

    // Update current type
    currentInstallmentType = selectedType;

    // Show/hide rows based on type
    const partnerDownPaymentRow = document.getElementById('partnerDownPaymentRow');
    const partnerInstallmentRow = document.getElementById('partnerInstallmentRow');
    const storeDownPaymentRow = document.getElementById('storeDownPaymentRow');
    const storeLockSystemRow = document.getElementById('storeLockSystemRow');

    if (selectedType === 'partner') {
        // ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ñ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Partner
        if (partnerDownPaymentRow) partnerDownPaymentRow.style.display = '';
        if (partnerInstallmentRow) partnerInstallmentRow.style.display = '';
        // ‡∏ã‡πà‡∏≠‡∏ô‡πÅ‡∏ñ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Store
        if (storeDownPaymentRow) storeDownPaymentRow.style.display = 'none';
        if (storeLockSystemRow) storeLockSystemRow.style.display = 'none';

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ required attribute
        document.getElementById('downPayment').required = true;
        document.getElementById('totalInstallments').required = true;
        document.getElementById('installmentAmount').required = true;
        if (document.getElementById('downPaymentStore')) document.getElementById('downPaymentStore').required = false;
        if (document.getElementById('totalInstallmentsStore')) document.getElementById('totalInstallmentsStore').required = false;
        if (document.getElementById('installmentAmountStore')) document.getElementById('installmentAmountStore').required = false;
    } else if (selectedType === 'store') {
        // ‡∏ã‡πà‡∏≠‡∏ô‡πÅ‡∏ñ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Partner
        if (partnerDownPaymentRow) partnerDownPaymentRow.style.display = 'none';
        if (partnerInstallmentRow) partnerInstallmentRow.style.display = 'none';
        // ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ñ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Store
        if (storeDownPaymentRow) storeDownPaymentRow.style.display = '';
        if (storeLockSystemRow) storeLockSystemRow.style.display = '';

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ required attribute
        document.getElementById('downPayment').required = false;
        document.getElementById('totalInstallments').required = false;
        document.getElementById('installmentAmount').required = false;
        if (document.getElementById('downPaymentStore')) document.getElementById('downPaymentStore').required = true;
        if (document.getElementById('totalInstallmentsStore')) document.getElementById('totalInstallmentsStore').required = true;
        if (document.getElementById('installmentAmountStore')) document.getElementById('installmentAmountStore').required = true;
    }

    // Show/hide commission field based on type (Partner)
    const commissionGroup = document.getElementById('commissionGroup');
    if (commissionGroup) {
        commissionGroup.style.display = selectedType === 'partner' ? 'block' : 'none';
    }

    // Show/hide lock system fee field based on type (Store)
    const lockSystemFeeGroup = document.getElementById('lockSystemFeeGroup');
    if (lockSystemFeeGroup) {
        lockSystemFeeGroup.style.display = selectedType === 'store' ? 'block' : 'none';
    }

    // Update installment schedule when type changes
    updateInstallmentSchedule();

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô partner - ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÄ‡∏≠‡∏á
    /*
    if (selectedType === 'partner') {
        setTimeout(() => {
            calculateCommission();
        }, 50);
    }
    */

    // Update modal title based on type
    const modalTitle = document.getElementById('installmentModalTitle');
    if (currentInstallmentEditId) {
        // Edit mode
        if (selectedType === 'store') {
            modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô';
        } else {
            modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô partner';
        }
    } else {
        // Add mode
        if (selectedType === 'store') {
            modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô';
        } else {
            modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô partner';
        }
    }

    console.log('üìù Installment type changed to:', selectedType);
}

// Open installment modal for adding/editing
function openInstallmentModal(installmentId = null, type = 'partner') {
    const modal = document.getElementById('installmentModal');
    const modalTitle = document.getElementById('installmentModalTitle');
    const form = document.getElementById('installmentForm');

    form.reset();
    currentInstallmentEditId = installmentId;
    currentInstallmentType = type;

    // Set installment type dropdown
    const installmentTypeSelect = document.getElementById('installmentType');
    if (installmentTypeSelect) {
        installmentTypeSelect.value = type;
    }

    // Show/hide rows based on type
    handleInstallmentTypeChange();

    // Add event listener for down payment date change
    const downPaymentDateInput = document.getElementById('downPaymentDate');
    if (downPaymentDateInput) {
        downPaymentDateInput.removeEventListener('change', calculateNextDueDate); // Remove old listener
        downPaymentDateInput.addEventListener('change', calculateNextDueDate); // Add new listener
    }

    // Add event listeners for commission calculation - ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÄ‡∏≠‡∏á
    /*
    const salePriceInput = document.getElementById('installmentSalePrice');
    const downPaymentInput = document.getElementById('downPayment');

    if (salePriceInput) {
        salePriceInput.removeEventListener('input', calculateCommission);
        salePriceInput.addEventListener('input', calculateCommission);
    }

    if (downPaymentInput) {
        downPaymentInput.removeEventListener('input', calculateCommission);
        downPaymentInput.addEventListener('input', calculateCommission);
    }
    */

    // Add event listeners for installment schedule update (Partner)
    const totalInstallmentsInput = document.getElementById('totalInstallments');
    const installmentAmountInput = document.getElementById('installmentAmount');

    if (totalInstallmentsInput) {
        totalInstallmentsInput.removeEventListener('input', updateInstallmentSchedule);
        totalInstallmentsInput.addEventListener('input', updateInstallmentSchedule);
    }

    if (installmentAmountInput) {
        installmentAmountInput.removeEventListener('input', updateInstallmentSchedule);
        installmentAmountInput.addEventListener('input', updateInstallmentSchedule);
    }

    // Add event listeners for installment schedule update (Store)
    const totalInstallmentsStoreInput = document.getElementById('totalInstallmentsStore');
    const installmentAmountStoreInput = document.getElementById('installmentAmountStore');

    if (totalInstallmentsStoreInput) {
        totalInstallmentsStoreInput.removeEventListener('input', updateInstallmentSchedule);
        totalInstallmentsStoreInput.addEventListener('input', updateInstallmentSchedule);
    }

    if (installmentAmountStoreInput) {
        installmentAmountStoreInput.removeEventListener('input', updateInstallmentSchedule);
        installmentAmountStoreInput.addEventListener('input', updateInstallmentSchedule);
    }

    if (installmentId) {
        // Edit mode
        const installment = installmentDevices.find(i => i.id === installmentId);
        if (installment) {
            console.log('üìù Editing installment:', installment);

            // Set type from installment data
            currentInstallmentType = installment.installment_type || installment.installmentType || 'partner';

            // Set installment type dropdown
            if (installmentTypeSelect) {
                installmentTypeSelect.value = currentInstallmentType;
            }

            // Set modal title based on type
            if (currentInstallmentType === 'store') {
                modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô';
            } else {
                modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô partner';
            }

            // Update commission field visibility
            if (commissionGroup) {
                commissionGroup.style.display = currentInstallmentType === 'partner' ? 'block' : 'none';
            }

            // Support both snake_case (from API) and camelCase (legacy)
            document.getElementById('installmentBrand').value = installment.brand || '';
            document.getElementById('installmentModel').value = installment.model || '';
            document.getElementById('installmentColor').value = installment.color || '';
            document.getElementById('installmentImei').value = installment.imei || '';
            document.getElementById('installmentRam').value = installment.ram || '';
            document.getElementById('installmentRom').value = installment.rom || '';
            document.getElementById('customerName').value = installment.customer_name || installment.customerName || '';
            document.getElementById('customerPhone').value = installment.customer_phone || installment.customerPhone || '';
            
            // ‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç - ‡πÅ‡∏õ‡∏•‡∏á string ‡πÄ‡∏õ‡πá‡∏ô number ‡∏Å‡πà‡∏≠‡∏ô set
            const costPrice = parseFloat(installment.cost_price || installment.costPrice || 0);
            const salePrice = parseFloat(installment.sale_price || installment.salePrice || 0);
            const downPayment = parseFloat(installment.down_payment || installment.downPayment || 0);
            const totalInstallments = parseInt(installment.total_installments || installment.totalInstallments || 0);
            const installmentAmount = parseFloat(installment.installment_amount || installment.installmentAmount || 0);
            
            console.log('üìù Setting form values:', {
                costPrice,
                salePrice,
                downPayment,
                totalInstallments,
                installmentAmount
            });
            
            document.getElementById('costPrice').value = costPrice;
            document.getElementById('installmentSalePrice').value = salePrice;

            // Set values for both partner and store fields
            document.getElementById('downPayment').value = downPayment;
            document.getElementById('totalInstallments').value = totalInstallments;
            document.getElementById('installmentAmount').value = installmentAmount;

            if (document.getElementById('downPaymentStore')) {
                document.getElementById('downPaymentStore').value = downPayment;
            }
            if (document.getElementById('totalInstallmentsStore')) {
                document.getElementById('totalInstallmentsStore').value = totalInstallments;
            }
            if (document.getElementById('installmentAmountStore')) {
                document.getElementById('installmentAmountStore').value = installmentAmount;
            }

            // Set commission if exists (for partner)
            const commissionValue = parseFloat(installment.commission || 0);
            document.getElementById('commission').value = commissionValue;

            // Set lock system fee if exists (for store)
            const lockSystemFeeValue = parseFloat(installment.lock_system_fee || installment.lockSystemFee || 0);
            if (document.getElementById('lockSystemFeeStore')) {
                document.getElementById('lockSystemFeeStore').value = lockSystemFeeValue;
            }

            document.getElementById('downPaymentDate').value = installment.down_payment_date || installment.downPaymentDate || '';

            // Get next due date
            const nextDueDate = installment.next_payment_due_date || installment.nextPaymentDueDate || getNextDueDate(installment);
            document.getElementById('nextDueDate').value = nextDueDate;
            document.getElementById('installmentNote').value = installment.note || '';
            
            // Set finance if exists
            const financeValue = installment.finance || '';
            document.getElementById('installmentFinance').value = financeValue;
            
            console.log('üìù Finance value set:', financeValue);
            
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö partner) - ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÄ‡∏≠‡∏á
            /*
            if ((installment.installment_type || installment.installmentType) === 'partner') {
                setTimeout(() => {
                    calculateCommission();
                }, 100);
            }
            */
        }
    } else {
        // Add mode - set title based on type
        if (type === 'store') {
            modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô';
        } else {
            modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô partner';
        }

        const today = new Date().toISOString().split('T')[0];
        document.getElementById('downPaymentDate').value = today;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ñ‡∏±‡∏î‡πÑ‡∏õ (‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô)
        const nextDue = new Date(today);
        nextDue.setMonth(nextDue.getMonth() + 1);
        document.getElementById('nextDueDate').value = nextDue.toISOString().split('T')[0];
    }

    modal.classList.add('show');
    
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏ß‡∏î‡∏ú‡πà‡∏≠‡∏ô
    updateInstallmentSchedule();
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö partner (‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà) - ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°‡πÄ‡∏≠‡∏á
    /*
    if (!installmentId && type === 'partner') {
        setTimeout(() => {
            calculateCommission();
        }, 100);
    }
    */
}

// Close installment modal
function closeInstallmentModal() {
    const modal = document.getElementById('installmentModal');
    modal.classList.remove('show');
    currentInstallmentEditId = null;
    transferSourceDeviceId = null;
    transferSourceDeviceType = null;
    transferTargetStore = null;
}

// Transfer new device to installment
async function transferToInstallment(deviceId) {
    try {
        // Fetch device data from API
        const device = await API.get(`${API_ENDPOINTS.newDevices}/${deviceId}`);

    if (!device) {
        showNotification('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á', 'error');
        return;
    }

        console.log('üì± Device data:', device);

        // ‡πÉ‡∏ä‡πâ‡∏£‡πâ‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        const selectedStore = device.store;
        const selectedStoreName = stores[selectedStore];
        const deviceInfo = `${device.brand} ${device.model} (${device.color}) - IMEI: ${device.imei}`;

        // ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô
        const confirmed = await customConfirm({
            title: 'üè™ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô',
            message: deviceInfo,
            icon: 'question',
            confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType: 'success',
            list: [
                {
                    icon: 'info',
                    iconSymbol: '‚ÑπÔ∏è',
                    text: `‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà ${selectedStoreName}`
                },
                {
                    icon: 'info',
                    iconSymbol: '‚ÑπÔ∏è',
                    text: `‡∏à‡∏∞‡πÇ‡∏¢‡∏Å‡πÑ‡∏õ‡πÄ‡∏°‡∏ô‡∏π‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô ${selectedStoreName}`
                }
            ]
        });

        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
        if (!confirmed) {
            return;
        }

        // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á)
        const transactionDate = await promptTransactionDate();
        if (!transactionDate) {
            return; // ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
        }

        console.log('üìÖ Selected transaction date:', transactionDate);

        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô 'sold' (‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß) ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡∏û‡∏£‡πâ‡∏≠‡∏° note "‡∏ú‡πà‡∏≠‡∏ô" ‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å sale_date
        await API.put(`${API_ENDPOINTS.newDevices}/${deviceId}`, {
            status: 'sold',
            sale_date: transactionDate, // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
            note: `‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô ${selectedStoreName}`
        });

        // Reload new devices data
        await applyNewDevicesFilter();

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
    const today = new Date().toISOString().split('T')[0];
        const nextDueDate = new Date();
        nextDueDate.setDate(nextDueDate.getDate() + 29);
        
        const tempInstallmentData = {
            id: 'INS' + Date.now().toString(),
            brand: device.brand,
            model: device.model,
            color: device.color,
            imei: device.imei,
            ram: device.ram,
            rom: device.rom,
            customer_name: '‡∏£‡∏≠‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
            customer_phone: '',
            cost_price: device.purchase_price || device.purchasePrice || 0,
            sale_price: device.sale_price || device.salePrice || 0,
            commission: 0,
            down_payment: 0,
            total_installments: 10,
            installment_amount: 0,
            paid_installments: 0,
            next_payment_due_date: nextDueDate.toISOString().split('T')[0],
            down_payment_date: today,
            note: `‡πÇ‡∏¢‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà`,
            status: 'active',
            seized_date: null,
            installment_type: 'store', // default
            store: selectedStore
        };

        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
        await API.post(API_ENDPOINTS.installments, tempInstallmentData);

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: `‡πÇ‡∏¢‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô ${selectedStoreName} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡πà‡∏≠‡∏ô‡πÉ‡∏ô‡πÄ‡∏°‡∏ô‡∏π "‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô"`,
            icon: 'success',
            confirmType: 'success'
        });
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏≠‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ú‡πà‡∏≠‡∏ô‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
        console.error('Error transferring to installment:', error);
    }
}

// Transfer used device to installment (‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á)
async function transferUsedToInstallment(deviceId) {
    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á
        const device = await API.get(`${API_ENDPOINTS.usedDevices}/${deviceId}`);
        
        if (!device) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á',
                icon: 'error',
                confirmType: 'danger'
            });
            return;
        }

        const conditionLabels = {
            'excellent': '‡∏î‡∏µ‡∏°‡∏≤‡∏Å',
            'good': '‡∏î‡∏µ',
            'fair': '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á',
            'poor': '‡∏û‡∏≠‡πÉ‡∏ä‡πâ'
        };
        const condition = device.device_condition || device.deviceCondition || 'good';
        const conditionText = conditionLabels[condition] || condition;
        
        // ‡πÉ‡∏ä‡πâ‡∏£‡πâ‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        const selectedStore = device.store;
        const selectedStoreName = stores[selectedStore];
        const deviceInfo = `${device.brand} ${device.model} (${device.color}) - IMEI: ${device.imei} - ‡∏™‡∏†‡∏≤‡∏û: ${conditionText}`;

        // ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô
        const confirmed = await customConfirm({
            title: 'üè™ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô',
            message: deviceInfo,
            icon: 'question',
            confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType: 'success',
            list: [
                {
                    icon: 'info',
                    iconSymbol: '‚ÑπÔ∏è',
                    text: `‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà ${selectedStoreName}`
                },
                {
                    icon: 'info',
                    iconSymbol: '‚ÑπÔ∏è',
                    text: `‡∏à‡∏∞‡πÇ‡∏¢‡∏Å‡πÑ‡∏õ‡πÄ‡∏°‡∏ô‡∏π‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô ${selectedStoreName}`
                }
            ]
        });

        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
        if (!confirmed) {
            return;
        }

        // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á)
        const transactionDate = await promptTransactionDate();
        if (!transactionDate) {
            return; // ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
        }

        console.log('üìÖ Selected transaction date:', transactionDate);

        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô 'sold' (‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß) ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡∏û‡∏£‡πâ‡∏≠‡∏° note "‡∏ú‡πà‡∏≠‡∏ô" ‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å sale_date
        await API.put(`${API_ENDPOINTS.usedDevices}/${deviceId}`, {
            status: 'sold',
            sale_date: transactionDate, // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
            note: `‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô ${selectedStoreName}`
        });

        // Reload used devices data
        await applyUsedDevicesFilter();

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
        const today = new Date().toISOString().split('T')[0];
        const nextDueDate = new Date();
        nextDueDate.setDate(nextDueDate.getDate() + 29);
        
        const tempInstallmentData = {
            id: 'INS' + Date.now().toString(),
            brand: device.brand,
            model: device.model,
            color: device.color,
            imei: device.imei,
            ram: device.ram,
            rom: device.rom,
            customer_name: '‡∏£‡∏≠‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
            customer_phone: '',
            cost_price: device.purchase_price || device.purchasePrice || 0,
            sale_price: device.sale_price || device.salePrice || 0,
            commission: 0,
            down_payment: 0,
            total_installments: 10,
            installment_amount: 0,
            paid_installments: 0,
            next_payment_due_date: nextDueDate.toISOString().split('T')[0],
            down_payment_date: today,
            note: `‡πÇ‡∏¢‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á (‡∏™‡∏†‡∏≤‡∏û: ${conditionText})`,
            status: 'active',
            seized_date: null,
            installment_type: 'store', // default
            store: selectedStore
        };

        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
        await API.post(API_ENDPOINTS.installments, tempInstallmentData);

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: `‡πÇ‡∏¢‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô ${selectedStoreName} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡πà‡∏≠‡∏ô‡πÉ‡∏ô‡πÄ‡∏°‡∏ô‡∏π "‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô"`,
            icon: 'success',
            confirmType: 'success'
        });

    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏≠‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏ú‡πà‡∏≠‡∏ô‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
        console.error('Error transferring used to installment:', error);
    }
}

// Save installment (add or update)
async function saveInstallment(event) {
    console.log('üöÄüöÄüöÄ saveInstallment FUNCTION CALLED! üöÄüöÄüöÄ');
    console.log('Event:', event);
    event.preventDefault();

    const formData = new FormData(event.target);

    // Get installment type from dropdown
    const selectedInstallmentType = formData.get('installmentType') || currentInstallmentType || 'partner';

    // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å input fields ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏õ‡∏±‡∏ç‡∏´‡∏≤ name ‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á modals
    const salePrice = document.getElementById('installmentSalePrice')?.value || '';
    const costPrice = document.getElementById('costPrice')?.value || '';
    const downPaymentDate = document.getElementById('downPaymentDate')?.value || '';
    const finance = document.getElementById('installmentFinance')?.value || '';

    // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡∏≤‡∏° installment type
    let downPayment, totalInstallments, installmentAmount, lockSystemFee;

    if (selectedInstallmentType === 'store') {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô
        downPayment = document.getElementById('downPaymentStore')?.value || '';
        totalInstallments = document.getElementById('totalInstallmentsStore')?.value || '';
        installmentAmount = document.getElementById('installmentAmountStore')?.value || '';
        lockSystemFee = document.getElementById('lockSystemFeeStore')?.value || '';
    } else {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡πà‡∏≠‡∏ô partner
        downPayment = document.getElementById('downPayment')?.value || '';
        totalInstallments = document.getElementById('totalInstallments')?.value || '';
        installmentAmount = document.getElementById('installmentAmount')?.value || '';
        lockSystemFee = '0';
    }

    // Debug: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å form
    console.log('üîç Form data direct values:');
    console.log('  - installmentType:', selectedInstallmentType);
    console.log('  - finance:', finance);
    console.log('  - salePrice:', salePrice);
    console.log('  - costPrice:', costPrice);
    console.log('  - downPayment:', downPayment);
    console.log('  - downPaymentDate:', downPaymentDate);
    console.log('  - totalInstallments:', totalInstallments);
    console.log('  - installmentAmount:', installmentAmount);
    console.log('  - lockSystemFee:', lockSystemFee);

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ñ‡∏±‡∏î‡πÑ‡∏õ: ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
    const nextDueDate = new Date(downPaymentDate);
    nextDueDate.setMonth(nextDueDate.getMonth() + 1);
    const nextDueDateStr = nextDueDate.toISOString().split('T')[0];
    
    console.log('üíæ Saving installment:', {
        downPaymentDate,
        nextDueDate: nextDueDateStr,
        method: 'Next month, same day'
    });

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö status, seized_date ‡πÅ‡∏•‡∏∞ store ‡πÄ‡∏î‡∏¥‡∏°
    let existingStatus = 'active';
    let existingSeizedDate = null;
    let existingStore = currentStore;
    let existingPaidInstallments = 0;
    
    if (currentInstallmentEditId) {
        const existing = installmentDevices.find(i => i.id === currentInstallmentEditId);
        if (existing) {
            existingStatus = existing.status || 'active';
            existingSeizedDate = existing.seized_date || existing.seizedDate || null;
            existingStore = existing.store || currentStore;
            existingPaidInstallments = existing.paid_installments || existing.paidInstallments || 0;
        }
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á object ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡πÑ‡∏õ API (‡πÉ‡∏ä‡πâ snake_case)
    const installmentData = {
        id: currentInstallmentEditId || ('INS' + Date.now().toString()),
        brand: formData.get('brand') || '',
        model: formData.get('model') || '',
        color: formData.get('color') || '',
        imei: formData.get('imei') || '',
        ram: formData.get('ram') || '',
        rom: formData.get('rom') || '',
        customer_name: formData.get('customerName') || '',
        customer_phone: formData.get('customerPhone') || '',
        cost_price: parseFloat(costPrice) || 0, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        sale_price: parseFloat(salePrice) || 0, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        lock_system_fee: parseFloat(lockSystemFee) || 0, // ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô)
        commission: parseFloat(formData.get('commission')) || 0,
        down_payment: parseFloat(downPayment) || 0, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        total_installments: parseInt(totalInstallments) || 0, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
        installment_amount: parseFloat(installmentAmount) || 0, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£
        paid_installments: existingPaidInstallments,
        next_payment_due_date: nextDueDateStr,
        down_payment_date: downPaymentDate, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        note: formData.get('note') || '',
        finance: finance, // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
        status: existingStatus, // ‡πÉ‡∏ä‡πâ status ‡πÄ‡∏î‡∏¥‡∏°
        seized_date: existingSeizedDate, // ‡πÉ‡∏ä‡πâ seized_date ‡πÄ‡∏î‡∏¥‡∏°
        installment_type: selectedInstallmentType, // 'partner' or 'store' (‡∏≠‡πà‡∏≤‡∏ô‡∏à‡∏≤‡∏Å dropdown)
        store: existingStore // ‡πÉ‡∏ä‡πâ store ‡πÄ‡∏î‡∏¥‡∏° (‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á)
    };
    
    console.log('üíæ Installment data with type:', selectedInstallmentType);
    console.log('üíæ Full installment data:', installmentData);
    console.log('üíæ Finance value:', installmentData.finance);
    console.log('üíæ Sale price value:', installmentData.sale_price);

    try {
        let response;
        if (currentInstallmentEditId) {
            // Update existing installment
            console.log('üìù Updating installment ID:', currentInstallmentEditId);
            response = await API.put(`${API_ENDPOINTS.installments}/${currentInstallmentEditId}`, installmentData);
            console.log('‚úÖ API PUT response:', response);
        } else {
            // Create new installment (‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏õ‡∏∏‡πà‡∏° + ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á)
            response = await API.post(API_ENDPOINTS.installments, installmentData);
            console.log('‚úÖ API POST response:', response);
        }

        // Reload data
        console.log('üîÑ Reloading installment data...');
        await loadInstallmentData();

        // Close modal
        closeInstallmentModal();

        // Show success message
        showNotification(currentInstallmentEditId ? '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à' : '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Load and display installment data
async function loadInstallmentData() {
    try {
        console.log('üîÑ Loading Installment Data for store:', currentStore);
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API
        installmentDevices = await API.get(API_ENDPOINTS.installments, { store: currentStore });
        
        console.log('üìä Loaded installment data:', {
            total: installmentDevices.length,
            store: currentStore,
            active: installmentDevices.filter(i => i.status === 'active').length,
            partner: installmentDevices.filter(i => (i.installment_type || i.installmentType) === 'partner').length,
            storeType: installmentDevices.filter(i => (i.installment_type || i.installmentType) === 'store').length,
            completed: installmentDevices.filter(i => i.status === 'completed').length,
            seized: installmentDevices.filter(i => i.status === 'seized').length
        });

        // Active: Show current data always (no date filter)
        const activeInstallments = installmentDevices.filter(i => i.status === 'active');
        displayInstallments(activeInstallments, 'installmentActiveTableBody', 'active');

        // Completed: Filter by completedDate
        let completedInstallments = installmentDevices.filter(i => i.status === 'completed');

        // Apply date filter if exists
        if (currentInstallmentFilter.startDate || currentInstallmentFilter.endDate) {
            completedInstallments = completedInstallments.filter(inst => {
                const completedDate = inst.completed_date || inst.completedDate;
                if (!completedDate) return false;
                
                const date = new Date(completedDate);
                const startMatch = !currentInstallmentFilter.startDate || 
                                  date >= new Date(currentInstallmentFilter.startDate);
                const endMatch = !currentInstallmentFilter.endDate || 
                                date <= new Date(currentInstallmentFilter.endDate + 'T23:59:59');
                
                return startMatch && endMatch;
            });
        } else {
            // Default: current month
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        completedInstallments = completedInstallments.filter(inst => {
            if (!inst.completed_date) return false;
            const date = new Date(inst.completed_date);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
        }

        displayInstallments(completedInstallments, 'installmentCompletedTableBody', 'completed');

        // Seized: Filter by seizedDate
        let seizedInstallments = installmentDevices.filter(i => i.status === 'seized');

        // Apply date filter if exists
        if (currentInstallmentFilter.startDate || currentInstallmentFilter.endDate) {
            seizedInstallments = seizedInstallments.filter(inst => {
                const seizedDate = inst.seized_date || inst.seizedDate;
                if (!seizedDate) return false;
                
                const date = new Date(seizedDate);
                const startMatch = !currentInstallmentFilter.startDate || 
                                  date >= new Date(currentInstallmentFilter.startDate);
                const endMatch = !currentInstallmentFilter.endDate || 
                                date <= new Date(currentInstallmentFilter.endDate + 'T23:59:59');
                
                return startMatch && endMatch;
            });
        } else {
            // Default: current month
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();

        seizedInstallments = seizedInstallments.filter(inst => {
            if (!inst.seized_date) return false;
            const date = new Date(inst.seized_date);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
        }

        displayInstallments(seizedInstallments, 'installmentSeizedTableBody', 'seized');

        // Update tab counts
        updateInstallmentTabCounts();

        // Update dashboard cards (Row 1)
        updateInstallmentDashboardCards();

        // Update status cards (Row 2)
        updateInstallmentStatusCards();

        // Update dashboard stats
        updateDashboard();
        
        // Initialize date filter if not already initialized
        initializeInstallmentDateFilter();
    } catch (error) {
        console.error('Error loading installment data:', error);
    }
}

// Display installments in table
function displayInstallments(installments, tableBodyId, type) {
    const tbody = document.getElementById(tableBodyId);

    if (!tbody) return;

    if (installments.length === 0) {
        const colspan = type === 'active' ? '10' : '8';
        tbody.innerHTML = `<tr><td colspan="${colspan}" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>`;
        return;
    }

    tbody.innerHTML = installments.map(inst => {
        const installmentType = inst.installment_type || inst.installmentType || 'partner';
        const typeBadge = installmentType === 'store' ?
            '<span class="badge badge-success">‡∏£‡πâ‡∏≤‡∏ô</span>' :
            '<span class="badge badge-primary">Partner</span>';
        const deviceInfo = `${inst.brand} ${inst.model} (${inst.color}) ${typeBadge}`;
        const customerName = inst.customer_name || inst.customerName;
        const customerPhone = inst.customer_phone || inst.customerPhone;
        const customerInfo = `${customerName}<br/>${customerPhone}`;
        const salePrice = inst.sale_price || inst.salePrice;
        const downPayment = inst.down_payment || inst.downPayment;
        const totalInstallments = inst.total_installments || inst.totalInstallments;
        const paidInstallments = inst.paid_installments ?? inst.paidInstallments ?? 0;
        const installmentAmount = inst.installment_amount || inst.installmentAmount;
        const remainingAmount = (totalInstallments - paidInstallments) * installmentAmount;
        const nextDueDate = getNextDueDate(inst);
        const overdueDays = getOverdueDays(inst);

        if (type === 'active') {
            const overdueDisplay = overdueDays > 0 
                ? `<span style="color: #dc2626; font-weight: bold;">${overdueDays}</span>`
                : '0';
            
            return `
                <tr>
                    <td style="width: 13.4%;">${deviceInfo}</td>
                    <td style="width: 9.1%;">${customerInfo}</td>
                    <td style="width: 6.5%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 6.5%; text-align: right;">${formatCurrency(downPayment)}</td>
                    <td style="width: 7.5%; text-align: center;">${paidInstallments}/${totalInstallments}</td>
                    <td style="width: 7.5%; text-align: right;">${formatCurrency(installmentAmount)}</td>
                    <td style="width: 7.5%; text-align: right; color: ${remainingAmount > 0 ? '#dc2626' : '#16a34a'}">${formatCurrency(remainingAmount)}</td>
                    <td style="width: 9%; text-align: center;">${nextDueDate}</td>
                    <td style="width: 6%; text-align: center;">${overdueDisplay}</td>
                    <td style="width: 27%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="installment-action-select" id="inst-action-${inst.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="payment">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô</option>
                                <option value="history">‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥</option>
                                <option value="seize">‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeInstallmentAction('${inst.id}', '${installmentType}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'completed') {
            const completedDate = inst.completed_date || inst.completedDate;
            return `
                <tr>
                    <td style="width: 18%;">${deviceInfo}</td>
                    <td style="width: 11%;">${customerInfo}</td>
                    <td style="width: 9.5%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 9.5%; text-align: right;">${formatCurrency(downPayment)}</td>
                    <td style="width: 9.5%; text-align: center;">${paidInstallments}/${totalInstallments}</td>
                    <td style="width: 9.5%; text-align: right;">${formatCurrency(installmentAmount)}</td>
                    <td style="width: 10%; text-align: center;">${formatDate(completedDate)}</td>
                    <td style="width: 23%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="installment-action-select" id="inst-action-${inst.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="history">‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeInstallmentAction('${inst.id}', '${installmentType}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'seized') {
            const seizedDate = inst.seized_date || inst.seizedDate;
            return `
                <tr>
                    <td style="width: 18%;">${deviceInfo}</td>
                    <td style="width: 11%;">${customerInfo}</td>
                    <td style="width: 9.5%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 9.5%; text-align: right;">${formatCurrency(downPayment)}</td>
                    <td style="width: 9.5%; text-align: center;">${paidInstallments}/${totalInstallments}</td>
                    <td style="width: 9.5%; text-align: right;">${formatCurrency(remainingAmount)}</td>
                    <td style="width: 10%; text-align: center;">${formatDate(seizedDate)}</td>
                    <td style="width: 23%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="installment-action-select" id="inst-action-${inst.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="history">‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeInstallmentAction('${inst.id}', '${installmentType}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        }
    }).join('');
}

// Get next due date for installment
function getNextDueDate(installment) {
    const paidInstallments = installment.paid_installments || installment.paidInstallments || 0;
    const totalInstallments = installment.total_installments || installment.totalInstallments || 0;

    if (paidInstallments >= totalInstallments) {
        return '‡∏ú‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß';
    }

    // ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
    const nextPaymentDueDate = installment.next_payment_due_date || installment.nextPaymentDueDate;
    if (nextPaymentDueDate) {
        return formatDate(nextPaymentDueDate);
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ô‡∏ß‡∏≤‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå + (‡∏á‡∏ß‡∏î‡∏ó‡∏µ‡πà‡∏à‡πà‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß + 1) * 30 ‡∏ß‡∏±‡∏ô
    const downPaymentDate = new Date(installment.down_payment_date || installment.downPaymentDate);
    const daysToAdd = (paidInstallments + 1) * 30;
    const nextDate = new Date(downPaymentDate);
    nextDate.setDate(downPaymentDate.getDate() + daysToAdd);

    return formatDate(nextDate.toISOString().split('T')[0]);
}

// Calculate overdue days for installment
function getOverdueDays(installment) {
    const paidInstallments = installment.paid_installments || installment.paidInstallments || 0;
    const totalInstallments = installment.total_installments || installment.totalInstallments || 0;

    // ‡∏ñ‡πâ‡∏≤‡∏ú‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô
    if (paidInstallments >= totalInstallments) {
        return 0;
    }

    // ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    const nextPaymentDueDate = installment.next_payment_due_date || installment.nextPaymentDueDate;
    let dueDate;
    
    if (nextPaymentDueDate) {
        dueDate = new Date(nextPaymentDueDate);
    } else {
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏ß‡∏±‡∏ô‡∏ß‡∏≤‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå
        const downPaymentDate = new Date(installment.down_payment_date || installment.downPaymentDate);
        const daysToAdd = (paidInstallments + 1) * 30;
        dueDate = new Date(downPaymentDate);
        dueDate.setDate(downPaymentDate.getDate() + daysToAdd);
    }

    // ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    dueDate.setHours(0, 0, 0, 0);

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô
    const diffTime = today - dueDate;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

    // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô return 0
    return diffDays > 0 ? diffDays : 0;
}

// Get overdue days for pawn
function getPawnOverdueDays(pawn) {
    const dueDateStr = pawn.due_date || pawn.dueDate;
    if (!dueDateStr) return 0; // No due date, not overdue

    const dueDate = new Date(dueDateStr);
    const today = new Date();
    today.setHours(0, 0, 0, 0); // Normalize today's date to start of day
    dueDate.setHours(0, 0, 0, 0); // Normalize due date to start of day

    if (dueDate > today) {
        return 0; // Not yet due
    }

    // Calculate difference in days
    const diffTime = today - dueDate;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
}

// Execute installment action from dropdown
async function executeInstallmentAction(installmentId, installmentType) {
    const selectElement = document.getElementById(`inst-action-${installmentId}`);
    const action = selectElement.value;

    if (!action) {
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'view':
            await viewInstallmentDetail(installmentId);
            break;
        case 'payment':
            openPaymentModal(installmentId);
            break;
        case 'history':
            openHistoryModal(installmentId);
            break;
        case 'seize':
            await seizeInstallment(installmentId);
            break;
        case 'edit':
            await openInstallmentModal(installmentId, installmentType);
            break;
        case 'delete':
            await deleteInstallment(installmentId);
            break;
        default:
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å',
                icon: 'error'
            });
    }

    // Reset select after action
    selectElement.value = '';
}

// Open payment modal
function openPaymentModal(installmentId) {
    const installment = installmentDevices.find(i => i.id === installmentId);
    if (!installment) return;

    // Check if already completed
    if (installment.paidInstallments >= installment.totalInstallments) {
        alert('‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß');
        return;
    }

    const modal = document.getElementById('paymentModal');
    const nextInstallmentNumber = installment.paidInstallments + 1;

    document.getElementById('paymentCustomerName').textContent = installment.customerName;
    document.getElementById('paymentDeviceInfo').textContent = `${installment.brand} ${installment.model}`;
    document.getElementById('paymentInstallmentNumber').textContent = `‡∏á‡∏ß‡∏î‡∏ó‡∏µ‡πà ${nextInstallmentNumber}/${installment.totalInstallments}`;
    document.getElementById('paymentAmount').textContent = formatCurrency(installment.installmentAmount);
    document.getElementById('paymentInstallmentId').value = installmentId;
    document.getElementById('paymentDate').value = new Date().toISOString().split('T')[0];

    modal.classList.add('show');
}

// Close payment modal
function closePaymentModal() {
    const modal = document.getElementById('paymentModal');
    modal.classList.remove('show');
}

// Save payment
async function savePayment(event) {
    event.preventDefault();

    const installmentId = document.getElementById('paymentInstallmentId').value;
    const paymentDate = document.getElementById('paymentDate').value;

    const installment = installmentDevices.find(i => i.id === installmentId);
    if (!installment) return;

    const paidInstallments = installment.paid_installments || installment.paidInstallments || 0;
    const installmentAmount = installment.installment_amount || installment.installmentAmount;
    const nextInstallmentNumber = paidInstallments + 1;

    try {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô
        await API.post(`${API_ENDPOINTS.installments}/${installmentId}/payment`, {
            installment_number: nextInstallmentNumber,
            payment_date: paymentDate,
            amount: installmentAmount
        });

        // Reload data ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó
        await loadInstallmentData();

        // Close modal
        closePaymentModal();

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        showNotification(`‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡∏á‡∏ß‡∏î‡∏ó‡∏µ‡πà ${nextInstallmentNumber} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    } catch (error) {
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
        console.error(error);
    }
}

// Open history modal
function openHistoryModal(installmentId) {
    const installment = installmentDevices.find(i => i.id === installmentId);
    if (!installment) return;

    const modal = document.getElementById('historyModal');

    document.getElementById('historyCustomerName').textContent = installment.customerName;
    document.getElementById('historyDeviceInfo').textContent = `${installment.brand} ${installment.model}`;
    document.getElementById('historySalePrice').textContent = formatCurrency(installment.salePrice);
    document.getElementById('historyDownPayment').textContent = formatCurrency(installment.downPayment);

    const tbody = document.getElementById('historyTableBody');

    if (installment.paymentHistory.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" class="empty-state">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô</td></tr>';
    } else {
        tbody.innerHTML = installment.paymentHistory.map(payment => `
            <tr>
                <td>‡∏á‡∏ß‡∏î‡∏ó‡∏µ‡πà ${payment.installmentNumber}</td>
                <td>${formatDate(payment.paymentDate)}</td>
                <td>${formatCurrency(payment.amount)}</td>
            </tr>
        `).join('');
    }

    modal.classList.add('show');
}

// Close history modal
function closeHistoryModal() {
    const modal = document.getElementById('historyModal');
    modal.classList.remove('show');
}

// Seize installment
async function seizeInstallment(installmentId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô
            const installment = installmentDevices.find(i => i.id === installmentId);
            if (!installment) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ú‡πà‡∏≠‡∏ô');
                return;
            }

            // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏ü‡∏¥‡∏•‡∏î‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á API
            await API.put(`${API_ENDPOINTS.installments}/${installmentId}`, {
                brand: installment.brand,
                model: installment.model,
                color: installment.color,
                imei: installment.imei,
                ram: installment.ram,
                rom: installment.rom,
                customer_name: installment.customer_name || installment.customerName,
                customer_phone: installment.customer_phone || installment.customerPhone,
                cost_price: installment.cost_price || installment.costPrice,
                sale_price: installment.sale_price || installment.salePrice,
                down_payment: installment.down_payment || installment.downPayment,
                total_installments: installment.total_installments || installment.totalInstallments,
                installment_amount: installment.installment_amount || installment.installmentAmount,
                next_payment_due_date: null, // ‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î
                note: installment.note || '',
                status: 'seized',
                seized_date: new Date().toISOString().split('T')[0]
            });
            loadInstallmentData();
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
            console.error(error);
        }
    }
}

// Delete installment
async function deleteInstallment(installmentId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? (‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ)')) {
        try {
            await API.delete(`${API_ENDPOINTS.installments}/${installmentId}`);
            loadInstallmentData();
            showNotification('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
            console.error(error);
        }
    }
}

// Update installment tab counts
function updateInstallmentTabCounts() {
    const storeInstallments = installmentDevices.filter(i => i.store === currentStore);

    // Count installments by status
    const activeCount = storeInstallments.filter(i => i.status === 'active').length;
    const completedCount = storeInstallments.filter(i => i.status === 'completed').length;
    const seizedCount = storeInstallments.filter(i => i.status === 'seized').length;

    console.log('üî¢ Updating tab counts:', {
        store: currentStore,
        activeCount,
        completedCount,
        seizedCount,
        totalInStore: storeInstallments.length,
        totalAll: installmentDevices.length
    });

    // Update tab counts
    const activeCountElement = document.getElementById('installmentActiveCount');
    const completedCountElement = document.getElementById('installmentCompletedCount');
    const seizedCountElement = document.getElementById('installmentSeizedCount');

    if (activeCountElement) activeCountElement.textContent = activeCount;
    if (completedCountElement) completedCountElement.textContent = completedCount;
    if (seizedCountElement) seizedCountElement.textContent = seizedCount;
}

// Update installment status cards (Row 2)
function updateInstallmentStatusCards() {
    console.log('üîÑ Updating Installment Status Cards...');
    console.log('üìä Total installmentDevices:', installmentDevices.length);
    console.log('üè™ Current Store:', currentStore);
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    const storeInstallments = installmentDevices.filter(i => i.store === currentStore);
    console.log('üè™ Store Installments:', storeInstallments.length);
    console.log('üìã Store Installments Data:', storeInstallments);

    // 1. ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ú‡πà‡∏≠‡∏ô - ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà status = 'active'
    const activeInstallments = storeInstallments.filter(i => i.status === 'active');
    const statusActiveCount = activeInstallments.length;
    console.log('‚è≥ Active Count:', statusActiveCount);

    // 2. ‡∏ú‡πà‡∏≠‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥ - active ‡∏ó‡∏µ‡πà‡∏à‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡πÄ‡∏ß‡∏•‡∏≤ (‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏∂‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ)
    const normalInstallments = activeInstallments.filter(inst => {
        const nextDueDate = inst.next_payment_due_date || inst.nextPaymentDueDate;
        if (!nextDueDate) return true; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥
        
        const dueDate = new Date(nextDueDate);
        dueDate.setHours(0, 0, 0, 0);
        
        return dueDate >= today; // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏¢‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    });
    const statusNormalCount = normalInstallments.length;

    // 3. ‡∏ú‡πà‡∏≠‡∏ô‡∏•‡πà‡∏≤‡∏ä‡πâ‡∏≤ - active ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏¢‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÅ‡∏•‡πâ‡∏ß
    const lateInstallments = activeInstallments.filter(inst => {
        const nextDueDate = inst.next_payment_due_date || inst.nextPaymentDueDate;
        if (!nextDueDate) return false; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î ‡πÑ‡∏°‡πà‡∏ô‡∏±‡∏ö‡∏ß‡πà‡∏≤‡∏•‡πà‡∏≤‡∏ä‡πâ‡∏≤
        
        const dueDate = new Date(nextDueDate);
        dueDate.setHours(0, 0, 0, 0);
        
        return dueDate < today; // ‡πÄ‡∏•‡∏¢‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÅ‡∏•‡πâ‡∏ß
    });
    const statusLateCount = lateInstallments.length;

    // 4. ‡πÑ‡∏°‡πà‡∏¢‡πà‡∏≠‡∏° - status = 'seized'
    const defaultedInstallments = storeInstallments.filter(i => i.status === 'seized');
    const statusDefaultedCount = defaultedInstallments.length;

    // 5. ‡∏¢‡∏≠‡∏î‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß - status = 'completed'
    const completedInstallments = storeInstallments.filter(i => i.status === 'completed');
    const statusCompletedCount = completedInstallments.length;

    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Å‡∏≤‡∏£‡πå‡∏î
    const statusActiveElement = document.getElementById('installmentStatusActive');
    const statusNormalElement = document.getElementById('installmentStatusNormal');
    const statusLateElement = document.getElementById('installmentStatusLate');
    const statusDefaultedElement = document.getElementById('installmentStatusDefaulted');
    const statusCompletedElement = document.getElementById('installmentStatusCompleted');

    if (statusActiveElement) statusActiveElement.textContent = statusActiveCount;
    if (statusNormalElement) statusNormalElement.textContent = statusNormalCount;
    if (statusLateElement) statusLateElement.textContent = statusLateCount;
    if (statusDefaultedElement) statusDefaultedElement.textContent = statusDefaultedCount;
    if (statusCompletedElement) statusCompletedElement.textContent = statusCompletedCount;
    
    console.log('‚úÖ Status Cards Updated:');
    console.log('   ‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ú‡πà‡∏≠‡∏ô:', statusActiveCount);
    console.log('   ‚úÖ ‡∏ú‡πà‡∏≠‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥:', statusNormalCount);
    console.log('   ‚ö†Ô∏è ‡∏ú‡πà‡∏≠‡∏ô‡∏•‡πà‡∏≤‡∏ä‡πâ‡∏≤:', statusLateCount);
    console.log('   ‚ùå ‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≠‡∏ô:', statusDefaultedCount);
    console.log('   üìÖ ‡∏¢‡∏≠‡∏î‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß:', statusCompletedCount);
}

// Update installment dashboard cards (Row 1)
function updateInstallmentDashboardCards() {
    // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    let storeInstallments = installmentDevices.filter(i => i.store === currentStore);
    
    // Apply date filter if exists
    if (currentInstallmentFilter.startDate || currentInstallmentFilter.endDate) {
        storeInstallments = storeInstallments.filter(i => {
            const startDate = i.start_date || i.startDate || i.down_payment_date || i.downPaymentDate;
            if (!startDate) return false;
            
            const deviceDate = new Date(startDate);
            const startMatch = !currentInstallmentFilter.startDate || 
                              deviceDate >= new Date(currentInstallmentFilter.startDate);
            const endMatch = !currentInstallmentFilter.endDate || 
                            deviceDate <= new Date(currentInstallmentFilter.endDate);
            
            return startMatch && endMatch;
        });
    }
    
    // ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏° installment_type
    const partnerInstallments = storeInstallments.filter(i => 
        (i.installment_type || i.installmentType) === 'partner' && 
        (i.status === 'active' || i.status === 'completed')
    );
    const storeOnlyInstallments = storeInstallments.filter(i => 
        (i.installment_type || i.installmentType) === 'store' && 
        (i.status === 'active' || i.status === 'completed')
    );
    
    // 1. ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô (active)
    const activeCount = storeInstallments.filter(i => i.status === 'active').length;
    
    // 2. ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢
    // Partner: ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ = 0 (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ã‡∏∑‡πâ‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏≠‡∏á)
    // ‡∏£‡πâ‡∏≤‡∏ô: ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ = ‡∏¢‡∏≠‡∏î‡∏à‡∏±‡∏î + ‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Ñ
    const expensePartner = 0; // Partner ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢
    const expenseStore = storeOnlyInstallments.reduce((sum, i) => {
        const salePrice = parseFloat(i.sale_price || i.salePrice) || 0;
        const lockSystemFee = parseFloat(i.lock_system_fee || i.lockSystemFee) || 0;
        return sum + salePrice + lockSystemFee;
    }, 0);
    const totalExpense = expensePartner + expenseStore;
    
    // 3. ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö
    // Partner: ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö = commission ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    // ‡∏£‡πâ‡∏≤‡∏ô: ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö = ‡∏Ñ‡πà‡∏≤‡∏á‡∏ß‡∏î‡∏ó‡∏∏‡∏Å‡∏á‡∏ß‡∏î (‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå)
    const incomePartner = partnerInstallments.reduce((sum, i) => {
        const commission = parseFloat(i.commission) || 0;
        return sum + commission;
    }, 0);
    const incomeStore = storeOnlyInstallments.reduce((sum, i) => {
        const totalInstallments = parseInt(i.total_installments || i.totalInstallments) || 0;
        const installmentAmount = parseFloat(i.installment_amount || i.installmentAmount) || 0;
        const totalAllInstallments = totalInstallments * installmentAmount;
        return sum + totalAllInstallments;
    }, 0);
    const totalIncome = incomePartner + incomeStore;
    
    // 4. ‡∏Å‡∏≥‡πÑ‡∏£ = ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö - ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢
    const profit = totalIncome - totalExpense;
    
    // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô detail modal
    window.installmentDashboardData = {
        partner: {
            devices: partnerInstallments,
            expense: expensePartner,
            income: incomePartner,
            profit: incomePartner - expensePartner
        },
        store: {
            devices: storeOnlyInstallments,
            expense: expenseStore,
            income: incomeStore,
            profit: incomeStore - expenseStore
        }
    };
    
    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Å‡∏≤‡∏£‡πå‡∏î
    const dashboardCountElement = document.getElementById('installmentDashboardCount');
    const expenseElement = document.getElementById('installmentExpense');
    const incomeElement = document.getElementById('installmentIncome');
    const profitElement = document.getElementById('installmentProfit');
    
    if (dashboardCountElement) dashboardCountElement.textContent = activeCount;
    if (expenseElement) expenseElement.textContent = formatCurrency(totalExpense);
    if (incomeElement) incomeElement.textContent = formatCurrency(totalIncome);
    if (profitElement) profitElement.textContent = formatCurrency(profit);
}

// Show installment expense detail
function showInstallmentExpenseDetail() {
    if (!window.installmentDashboardData) return;
    
    const { partner, store } = window.installmentDashboardData;
    
    const modal = document.getElementById('installment-expense-detail');
    const tbody = document.getElementById('installmentExpenseDetailBody');
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏£‡∏∏‡∏õ
    const totalExpense = partner.expense + store.expense;
    const totalCount = partner.devices.length + store.devices.length;
    
    // ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    const monthElement = document.getElementById('installmentExpenseMonth');
    const totalElement = document.getElementById('installmentExpenseDetailTotal');
    const countElement = document.getElementById('installmentExpenseDetailCount');
    
    if (monthElement) {
        if (currentInstallmentFilter.startDate || currentInstallmentFilter.endDate) {
            // ‡πÅ‡∏™‡∏î‡∏á‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á
            const startDate = currentInstallmentFilter.startDate ? new Date(currentInstallmentFilter.startDate) : null;
            const endDate = currentInstallmentFilter.endDate ? new Date(currentInstallmentFilter.endDate) : null;
            
            if (startDate && endDate) {
                monthElement.textContent = `${formatDate(currentInstallmentFilter.startDate)} - ${formatDate(currentInstallmentFilter.endDate)}`;
            } else if (startDate) {
                monthElement.textContent = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentInstallmentFilter.startDate)}`;
            } else if (endDate) {
                monthElement.textContent = `‡∏ñ‡∏∂‡∏á ${formatDate(currentInstallmentFilter.endDate)}`;
            } else {
                monthElement.textContent = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            }
        } else {
            // ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            const now = new Date();
            const thaiMonths = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô', 
                               '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
            const thaiYear = now.getFullYear() + 543;
            monthElement.textContent = `${thaiMonths[now.getMonth()]} ${thaiYear}`;
        }
    }
    
    if (totalElement) totalElement.textContent = formatCurrency(totalExpense);
    if (countElement) countElement.textContent = totalCount;
    
    tbody.innerHTML = `
        <tr class="summary-row partner">
            <td><strong>‡∏ú‡πà‡∏≠‡∏ô Partner</strong></td>
            <td class="text-center"><strong>${partner.devices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</strong></td>
            <td class="text-right"><strong class="expense-text">${formatCurrency(partner.expense)}</strong></td>
        </tr>
        ${partner.devices.map(device => `
            <tr>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;${device.brand} ${device.model} - ${device.customer_name || device.customerName}</td>
                <td class="text-center">${device.imei}</td>
                <td class="text-right">${formatCurrency(0)}</td>
            </tr>
        `).join('')}
        <tr class="summary-row store">
            <td><strong>‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô (‡∏¢‡∏≠‡∏î‡∏à‡∏±‡∏î + ‡∏Ñ‡πà‡∏≤‡∏•‡πá‡∏≠‡∏Ñ)</strong></td>
            <td class="text-center"><strong>${store.devices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</strong></td>
            <td class="text-right"><strong class="expense-text">${formatCurrency(store.expense)}</strong></td>
        </tr>
        ${store.devices.map(device => {
            const salePrice = parseFloat(device.sale_price || device.salePrice) || 0;
            const lockFee = parseFloat(device.lock_system_fee || device.lockSystemFee) || 0;
            return `
                <tr>
                    <td>&nbsp;&nbsp;&nbsp;&nbsp;${device.brand} ${device.model} - ${device.customer_name || device.customerName}</td>
                    <td class="text-center">${device.imei}</td>
                    <td class="text-right">${formatCurrency(salePrice + lockFee)}</td>
                </tr>
            `;
        }).join('')}
        <tr class="total-row">
            <td colspan="2"><strong>‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</strong></td>
            <td class="text-right"><strong class="expense-text">${formatCurrency(totalExpense)}</strong></td>
        </tr>
    `;
    
    // Hide main page and show detail page
    document.getElementById('installment').classList.remove('active');
    document.getElementById('installment-expense-detail').classList.add('active');
}

// Show installment income detail
function showInstallmentIncomeDetail() {
    console.log('‚úÖ showInstallmentIncomeDetail() called');
    
    // Ensure dashboard data is up-to-date
    updateInstallmentDashboardCards();
    
    console.log('üìä installmentDashboardData:', window.installmentDashboardData);
    
    if (!window.installmentDashboardData) {
        console.error('‚ùå window.installmentDashboardData is undefined');
        alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö');
        return;
    }
    
    const { partner, store } = window.installmentDashboardData;
    
    console.log('üë• Partner:', partner);
    console.log('üè™ Store:', store);
    
    const modal = document.getElementById('installment-income-detail');
    const tbody = document.getElementById('installmentIncomeDetailBody');
    
    console.log('üîç Modal element:', modal ? 'Found' : 'NOT FOUND');
    console.log('üîç Tbody element:', tbody ? 'Found' : 'NOT FOUND');
    
    if (!tbody) {
        console.error('‚ùå installmentIncomeDetailBody element not found');
        return;
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏£‡∏∏‡∏õ
    const totalIncome = partner.income + store.income;
    const totalCount = partner.devices.length + store.devices.length;

    // ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    const monthElement = document.getElementById('installmentIncomeMonth');
    const totalElement = document.getElementById('installmentIncomeDetailTotal');
    const countElement = document.getElementById('installmentIncomeDetailCount');

    if (monthElement) {
        if (currentInstallmentFilter.startDate || currentInstallmentFilter.endDate) {
            const startDate = currentInstallmentFilter.startDate ? new Date(currentInstallmentFilter.startDate) : null;
            const endDate = currentInstallmentFilter.endDate ? new Date(currentInstallmentFilter.endDate) : null;

            if (startDate && endDate) {
                monthElement.textContent = `${formatDate(currentInstallmentFilter.startDate)} - ${formatDate(currentInstallmentFilter.endDate)}`;
            } else if (startDate) {
                monthElement.textContent = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentInstallmentFilter.startDate)}`;
            } else if (endDate) {
                monthElement.textContent = `‡∏ñ‡∏∂‡∏á ${formatDate(currentInstallmentFilter.endDate)}`;
            } else {
                monthElement.textContent = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            }
        } else {
            monthElement.textContent = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
        }
    }

    if (totalElement) totalElement.textContent = formatCurrency(totalIncome);
    if (countElement) countElement.textContent = totalCount;
    
    tbody.innerHTML = `
        <tr class="summary-row partner">
            <td><strong>‡∏ú‡πà‡∏≠‡∏ô Partner (‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏≠‡∏°)</strong></td>
            <td class="text-center"><strong>${partner.devices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</strong></td>
            <td class="text-right"><strong class="income-text">${formatCurrency(partner.income)}</strong></td>
        </tr>
        ${partner.devices.map(device => `
            <tr>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;${device.brand} ${device.model} - ${device.customer_name || device.customerName}</td>
                <td class="text-center">${device.imei}</td>
                <td class="text-right">${formatCurrency(parseFloat(device.commission) || 0)}</td>
            </tr>
        `).join('')}
        <tr class="summary-row store">
            <td><strong>‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô (‡∏Ñ‡πà‡∏≤‡∏á‡∏ß‡∏î‡∏ó‡∏∏‡∏Å‡∏á‡∏ß‡∏î)</strong></td>
            <td class="text-center"><strong>${store.devices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</strong></td>
            <td class="text-right"><strong class="income-text">${formatCurrency(store.income)}</strong></td>
        </tr>
        ${store.devices.map(device => {
            const totalInstallments = parseInt(device.total_installments || device.totalInstallments) || 0;
            const installmentAmount = parseFloat(device.installment_amount || device.installmentAmount) || 0;
            const totalAllInstallments = totalInstallments * installmentAmount;
            return `
                <tr>
                    <td>&nbsp;&nbsp;&nbsp;&nbsp;${device.brand} ${device.model} - ${device.customer_name || device.customerName}</td>
                    <td class="text-center">${device.imei}</td>
                    <td class="text-right">${formatCurrency(totalAllInstallments)}</td>
                </tr>
            `;
        }).join('')}
        <tr class="total-row">
            <td colspan="2"><strong>‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</strong></td>
            <td class="text-right"><strong class="income-text">${formatCurrency(partner.income + store.income)}</strong></td>
        </tr>
    `;
    
    // Hide main page and show detail page
    document.getElementById('installment').classList.remove('active');
    document.getElementById('installment-income-detail').classList.add('active');
}

// Show installment profit detail
function showInstallmentProfitDetail() {
    console.log('‚úÖ showInstallmentProfitDetail() called');

    // Ensure dashboard data is up-to-date
    updateInstallmentDashboardCards();

    if (!window.installmentDashboardData) {
        console.error('‚ùå window.installmentDashboardData is undefined');
        alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö');
        return;
    }

    const { partner, store } = window.installmentDashboardData;

    const modal = document.getElementById('installment-profit-detail');
    const tbody = document.getElementById('installmentProfitDetailBody');

    if (!tbody) {
        console.error('‚ùå installmentProfitDetailBody element not found');
        return;
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏£‡∏∏‡∏õ
    const totalProfit = partner.profit + store.profit;
    const totalCount = partner.devices.length + store.devices.length;

    // ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    const monthElement = document.getElementById('installmentProfitMonth');
    const totalElement = document.getElementById('installmentProfitDetailTotal');
    const countElement = document.getElementById('installmentProfitDetailCount');

    if (monthElement) {
        if (currentInstallmentFilter.startDate || currentInstallmentFilter.endDate) {
            const startDate = currentInstallmentFilter.startDate ? new Date(currentInstallmentFilter.startDate) : null;
            const endDate = currentInstallmentFilter.endDate ? new Date(currentInstallmentFilter.endDate) : null;

            if (startDate && endDate) {
                monthElement.textContent = `${formatDate(currentInstallmentFilter.startDate)} - ${formatDate(currentInstallmentFilter.endDate)}`;
            } else if (startDate) {
                monthElement.textContent = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentInstallmentFilter.startDate)}`;
            } else if (endDate) {
                monthElement.textContent = `‡∏ñ‡∏∂‡∏á ${formatDate(currentInstallmentFilter.endDate)}`;
            } else {
                monthElement.textContent = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            }
        } else {
            monthElement.textContent = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
        }
    }

    if (totalElement) totalElement.textContent = formatCurrency(totalProfit);
    if (countElement) countElement.textContent = totalCount;

    tbody.innerHTML = `
        <tr class="summary-row partner">
            <td><strong>‡∏ú‡πà‡∏≠‡∏ô Partner (‡∏Å‡∏≥‡πÑ‡∏£)</strong></td>
            <td class="text-center"><strong>${partner.devices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</strong></td>
            <td class="text-right"><strong class="profit-text">${formatCurrency(partner.profit)}</strong></td>
        </tr>
        ${partner.devices.map(device => `
            <tr>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;${device.brand} ${device.model} - ${device.customer_name || device.customerName}</td>
                <td class="text-center">${device.imei}</td>
                <td class="text-right">${formatCurrency((parseFloat(device.commission) || 0) - (parseFloat(device.purchase_price || device.purchasePrice) || 0))}</td>
            </tr>
        `).join('')}
        <tr class="summary-row store">
            <td><strong>‡∏ú‡πà‡∏≠‡∏ô‡∏£‡πâ‡∏≤‡∏ô (‡∏Å‡∏≥‡πÑ‡∏£)</strong></td>
            <td class="text-center"><strong>${store.devices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</strong></td>
            <td class="text-right"><strong class="profit-text">${formatCurrency(store.profit)}</strong></td>
        </tr>
        ${store.devices.map(device => {
            const totalInstallments = parseInt(device.total_installments || device.totalInstallments) || 0;
            const installmentAmount = parseFloat(device.installment_amount || device.installmentAmount) || 0;
            const totalAllInstallments = totalInstallments * installmentAmount;
            const salePrice = parseFloat(device.sale_price || device.salePrice) || 0;
            const lockFee = parseFloat(device.lock_system_fee || device.lockSystemFee) || 0;
            const profit = totalAllInstallments - (salePrice + lockFee);
            return `
                <tr>
                    <td>&nbsp;&nbsp;&nbsp;&nbsp;${device.brand} ${device.model} - ${device.customer_name || device.customerName}</td>
                    <td class="text-center">${device.imei}</td>
                    <td class="text-right">${formatCurrency(profit)}</td>
                </tr>
            `;
        }).join('')}
        <tr class="total-row">
            <td colspan="2"><strong>‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</strong></td>
            <td class="text-right"><strong class="profit-text">${formatCurrency(totalProfit)}</strong></td>
        </tr>
    `;

    // Hide main page and show detail page
    document.getElementById('installment').classList.remove('active');
    document.getElementById('installment-profit-detail').classList.add('active');
}

// Close installment expense detail modal (no longer needed)
function closeInstallmentExpenseDetailModal() {
    document.getElementById('installmentExpenseDetailModal').style.display = 'none';
}

// Close installment income detail modal
function closeInstallmentIncomeDetailModal() {
    document.getElementById('installmentIncomeDetailModal').style.display = 'none';
}

// Initialize installment search
function initializeInstallmentSearch() {
    const searchInput = document.getElementById('searchInstallment');
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            filterInstallments(searchTerm);
        });
    }
}

// Filter installments based on search term
function filterInstallments(searchTerm) {
    // Active: Show current data always with search
    let activeInstallments = installmentDevices.filter(i => i.store === currentStore && i.status === 'active');

    if (searchTerm) {
        activeInstallments = activeInstallments.filter(inst => {
            return inst.brand.toLowerCase().includes(searchTerm) ||
                   inst.model.toLowerCase().includes(searchTerm) ||
                   inst.customerName.toLowerCase().includes(searchTerm) ||
                   inst.customerPhone.includes(searchTerm) ||
                   inst.imei.toLowerCase().includes(searchTerm);
        });
    }

    displayInstallments(activeInstallments, 'installmentActiveTableBody', 'active');

    // Completed: Filter by date and search
    let completedInstallments = installmentDevices.filter(i => i.store === currentStore && i.status === 'completed');

    // Apply date filter
    if (currentInstallmentFilter.month || currentInstallmentFilter.year) {
        completedInstallments = completedInstallments.filter(inst => {
            if (!inst.completedDate) return false;
            const date = new Date(inst.completedDate);
            const instMonth = date.getMonth() + 1;
            const instYear = date.getFullYear();

            const monthMatch = !currentInstallmentFilter.month || instMonth == currentInstallmentFilter.month;
            const yearMatch = !currentInstallmentFilter.year || instYear == currentInstallmentFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        completedInstallments = completedInstallments.filter(inst => {
            if (!inst.completedDate) return false;
            const date = new Date(inst.completedDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter
    if (searchTerm) {
        completedInstallments = completedInstallments.filter(inst => {
            return inst.brand.toLowerCase().includes(searchTerm) ||
                   inst.model.toLowerCase().includes(searchTerm) ||
                   inst.customerName.toLowerCase().includes(searchTerm) ||
                   inst.customerPhone.includes(searchTerm) ||
                   inst.imei.toLowerCase().includes(searchTerm);
        });
    }

    displayInstallments(completedInstallments, 'installmentCompletedTableBody', 'completed');

    // Seized: Filter by date and search
    let seizedInstallments = installmentDevices.filter(i => i.store === currentStore && i.status === 'seized');

    // Apply date filter
    if (currentInstallmentFilter.month || currentInstallmentFilter.year) {
        seizedInstallments = seizedInstallments.filter(inst => {
            if (!inst.seizedDate) return false;
            const date = new Date(inst.seizedDate);
            const instMonth = date.getMonth() + 1;
            const instYear = date.getFullYear();

            const monthMatch = !currentInstallmentFilter.month || instMonth == currentInstallmentFilter.month;
            const yearMatch = !currentInstallmentFilter.year || instYear == currentInstallmentFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        seizedInstallments = seizedInstallments.filter(inst => {
            if (!inst.seizedDate) return false;
            const date = new Date(inst.seizedDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter
    if (searchTerm) {
        seizedInstallments = seizedInstallments.filter(inst => {
            return inst.brand.toLowerCase().includes(searchTerm) ||
                   inst.model.toLowerCase().includes(searchTerm) ||
                   inst.customerName.toLowerCase().includes(searchTerm) ||
                   inst.customerPhone.includes(searchTerm) ||
                   inst.imei.toLowerCase().includes(searchTerm);
        });
    }

    displayInstallments(seizedInstallments, 'installmentSeizedTableBody', 'seized');
}

// Initialize date filter for installment
function initializeInstallmentDateFilter() {
    const monthSelect = document.getElementById('filterInstallmentMonth');
    const yearSelect = document.getElementById('filterInstallmentYear');

    console.log('üîß Initializing installment date filter...', {
        monthSelect: monthSelect ? 'found' : 'NOT FOUND',
        yearSelect: yearSelect ? 'found' : 'NOT FOUND'
    });

    if (!monthSelect || !yearSelect) {
        console.error('‚ùå Installment date filter elements not found!');
        return;
    }

    // Clear existing options except the first one
    while (monthSelect.options.length > 1) {
        monthSelect.remove(1);
    }
    while (yearSelect.options.length > 1) {
        yearSelect.remove(1);
    }

    // Populate months
    const thaiMonths = [
        '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
        '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'
    ];
    
    thaiMonths.forEach((month, index) => {
        const option = document.createElement('option');
        option.value = index + 1;
        option.textContent = month;
        monthSelect.appendChild(option);
    });

    // Populate years - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô ‡∏Ñ.‡∏®.
    const currentYear = new Date().getFullYear();
    for (let year = currentYear; year >= currentYear - 5; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year; // ‡πÅ‡∏™‡∏î‡∏á ‡∏Ñ.‡∏®.
        yearSelect.appendChild(option);
    }

    console.log('‚úÖ Installment date filter initialized:', {
        months: monthSelect.options.length,
        years: yearSelect.options.length
    });
}

// Filter installment by date
async function filterInstallmentByDate() {
    const monthSelect = document.getElementById('filterInstallmentMonth');
    const yearSelect = document.getElementById('filterInstallmentYear');

    currentInstallmentFilter.month = monthSelect.value;
    currentInstallmentFilter.year = yearSelect.value;

    try {
        // Get all installments from API
        const allInstallments = await API.get(API_ENDPOINTS.installments, { store: currentStore });

        // Active: Show current data always (no date filter)
        const activeInstallments = allInstallments.filter(i => i.status === 'active');
        displayInstallments(activeInstallments, 'installmentActiveTableBody', 'active');

        // Completed: Filter by completedDate
        let completedInstallments = allInstallments.filter(i => i.status === 'completed');

        if (currentInstallmentFilter.month || currentInstallmentFilter.year) {
            completedInstallments = completedInstallments.filter(inst => {
                const completedDate = inst.completed_date || inst.completedDate;
                if (!completedDate) return false;
                const date = new Date(completedDate);
                const instMonth = date.getMonth() + 1;
                const instYear = date.getFullYear();

                const monthMatch = !currentInstallmentFilter.month || instMonth == currentInstallmentFilter.month;
                const yearMatch = !currentInstallmentFilter.year || instYear == currentInstallmentFilter.year;

                return monthMatch && yearMatch;
            });
        } else {
            // Show only current month if no filter is applied
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();

            completedInstallments = completedInstallments.filter(inst => {
                const completedDate = inst.completed_date || inst.completedDate;
                if (!completedDate) return false;
                const date = new Date(completedDate);
                return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
            });
        }

        displayInstallments(completedInstallments, 'installmentCompletedTableBody', 'completed');

        // Seized: Filter by seizedDate
        let seizedInstallments = allInstallments.filter(i => i.status === 'seized');

        if (currentInstallmentFilter.month || currentInstallmentFilter.year) {
            seizedInstallments = seizedInstallments.filter(inst => {
                const seizedDate = inst.seized_date || inst.seizedDate;
                if (!seizedDate) return false;
                const date = new Date(seizedDate);
                const instMonth = date.getMonth() + 1;
                const instYear = date.getFullYear();

                const monthMatch = !currentInstallmentFilter.month || instMonth == currentInstallmentFilter.month;
                const yearMatch = !currentInstallmentFilter.year || instYear == currentInstallmentFilter.year;

                return monthMatch && yearMatch;
            });
        } else {
            // Show only current month if no filter is applied
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();

            seizedInstallments = seizedInstallments.filter(inst => {
                const seizedDate = inst.seized_date || inst.seizedDate;
                if (!seizedDate) return false;
                const date = new Date(seizedDate);
                return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
            });
        }

        displayInstallments(seizedInstallments, 'installmentSeizedTableBody', 'seized');

        // Update tab counts
        const activeCountElement = document.getElementById('installmentActiveCount');
        const completedCountElement = document.getElementById('installmentCompletedCount');
        const seizedCountElement = document.getElementById('installmentSeizedCount');

        if (activeCountElement) activeCountElement.textContent = activeInstallments.length;
        if (completedCountElement) completedCountElement.textContent = completedInstallments.length;
        if (seizedCountElement) seizedCountElement.textContent = seizedInstallments.length;
    } catch (error) {
        console.error('Error loading installments:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
    }
}

// Clear installment filter
// Close modals when clicking outside
window.addEventListener('click', function(event) {
    const installmentModal = document.getElementById('installmentModal');
    const paymentModal = document.getElementById('paymentModal');
    const historyModal = document.getElementById('historyModal');
    const expenseDetailModal = document.getElementById('installmentExpenseDetailModal');
    const incomeDetailModal = document.getElementById('installmentIncomeDetailModal');

    if (event.target === installmentModal) {
        closeInstallmentModal();
    }
    if (event.target === paymentModal) {
        closePaymentModal();
    }
    if (event.target === historyModal) {
        closeHistoryModal();
    }
    if (event.target === expenseDetailModal) {
        closeInstallmentExpenseDetailModal();
    }
    if (event.target === incomeDetailModal) {
        closeInstallmentIncomeDetailModal();
    }
});

// ===== PAWN DEVICES (‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å) =====
// Note: Using MySQL database via API instead of localStorage mock data
// All data is loaded from server database through loadPawnData() function

// ===== PAWN DEVICES CRUD FUNCTIONS =====

// Initialize pawn tabs
function initializePawnTabs() {
    const tabButtons = document.querySelectorAll('#pawn .tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');

            // Remove active class from all pawn tabs and contents
            document.querySelectorAll('#pawn .tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#pawn .tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            this.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        });
    });
}

// Open pawn modal for adding/editing
async function openPawnModal(pawnId = null) {
    const modal = document.getElementById('pawnModal');
    const modalTitle = document.getElementById('pawnModalTitle');
    const form = document.getElementById('pawnForm');

    form.reset();
    currentPawnEditId = pawnId;
    
    // Set default store value
    const storeSelect = document.getElementById('pawnStore');
    if (storeSelect) {
        storeSelect.value = currentStore;
    }

    if (pawnId) {
        // Edit mode
        modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å';

        try {
            const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);

            if (pawn) {
                // Handle both snake_case and camelCase field names
                const pawnAmount = pawn.pawn_amount || pawn.pawnAmount;
                const receiveDate = pawn.receive_date || pawn.receiveDate;
                const dueDate = pawn.due_date || pawn.dueDate;
                const customerName = pawn.customer_name || pawn.customerName;

                // Fill all form fields with existing data
                if (storeSelect) {
                    storeSelect.value = pawn.store || pawn.store_id || currentStore;
                }
                document.getElementById('pawnCustomerName').value = customerName || '';
                document.getElementById('pawnBrand').value = pawn.brand || '';
                document.getElementById('pawnModel').value = pawn.model || '';
                document.getElementById('pawnColor').value = pawn.color || '';
                document.getElementById('pawnImei').value = pawn.imei || '';
                document.getElementById('pawnRam').value = pawn.ram || '';
                document.getElementById('pawnRom').value = pawn.rom || '';
                document.getElementById('pawnAmount').value = pawnAmount || 0;
                document.getElementById('pawnInterest').value = pawn.interest || 0;
                document.getElementById('pawnInterestMethod').value = pawn.interest_collection_method || pawn.interestCollectionMethod || 'not_deducted';
                document.getElementById('pawnRedemptionAmount').value = pawn.redemption_amount || pawn.redemptionAmount || 0;

                // Format dates properly - keep existing dates
                if (receiveDate) {
                    const receiveDateFormatted = receiveDate.includes('T') ? receiveDate.split('T')[0] : receiveDate;
                    document.getElementById('pawnReceiveDate').value = receiveDateFormatted;
                } else {
                    document.getElementById('pawnReceiveDate').value = '';
                }

                if (dueDate) {
                    const dueDateFormatted = dueDate.includes('T') ? dueDate.split('T')[0] : dueDate;
                    document.getElementById('pawnDueDate').value = dueDateFormatted;
                } else {
                    document.getElementById('pawnDueDate').value = '';
                }

                document.getElementById('pawnNote').value = pawn.note || '';

                console.log('‚úÖ Loaded pawn data for edit:', {
                    id: pawn.id,
                    receiveDate: receiveDate,
                    dueDate: dueDate
                });
            }
        } catch (error) {
            console.error('Error loading pawn data:', error);
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
        }
    } else {
        // Add mode
        modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å';
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('pawnReceiveDate').value = today;
        updatePawnDueDate();
    }

    modal.classList.add('show');
}

// Close pawn modal
function closePawnModal() {
    const modal = document.getElementById('pawnModal');
    modal.classList.remove('show');
    currentPawnEditId = null;
}

// Update pawn due date (+14 days from receive date)
function updatePawnDueDate() {
    const receiveDateInput = document.getElementById('pawnReceiveDate');
    const dueDateInput = document.getElementById('pawnDueDate');

    if (receiveDateInput.value) {
        const receiveDate = new Date(receiveDateInput.value);
        receiveDate.setDate(receiveDate.getDate() + 14);
        dueDateInput.value = receiveDate.toISOString().split('T')[0];
    }
}

// Calculate interest automatically (10% of pawn amount)
function calculatePawnInterest() {
    const pawnAmount = parseFloat(document.getElementById('pawnAmount').value) || 0;
    const interestAmount = pawnAmount * 0.10; // 10%
    document.getElementById('pawnInterest').value = interestAmount.toFixed(2);
    
    // Recalculate redemption amount when interest changes
    calculateRedemptionAmount();
}

// Calculate redemption amount based on interest collection method
function calculateRedemptionAmount() {
    const pawnAmount = parseFloat(document.getElementById('pawnAmount').value) || 0;
    const interest = parseFloat(document.getElementById('pawnInterest').value) || 0;
    const interestMethod = document.getElementById('pawnInterestMethod').value;
    
    let redemptionAmount = 0;
    
    if (interestMethod === 'deducted') {
        // ‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å: redemption amount = pawn amount only
        redemptionAmount = pawnAmount;
    } else if (interestMethod === 'not_deducted') {
        // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å: redemption amount = pawn amount + interest
        redemptionAmount = pawnAmount + interest;
    }
    
    document.getElementById('pawnRedemptionAmount').value = redemptionAmount.toFixed(2);
}

// Save pawn (add or update)
async function savePawn(event) {
    event.preventDefault();

    const formData = new FormData(event.target);

    const pawnData = {
        id: currentPawnEditId || ('PWN' + Date.now().toString()),
        customer_name: formData.get('customerName')?.trim() || null,
        brand: formData.get('brand'),
        model: formData.get('model'),
        color: formData.get('color'),
        imei: formData.get('imei'),
        ram: formData.get('ram'),
        rom: formData.get('rom'),
        pawn_amount: parseFloat(formData.get('pawnAmount')),
        interest: parseFloat(formData.get('interest')),
        interest_collection_method: formData.get('interestMethod'),
        redemption_amount: parseFloat(formData.get('redemptionAmount')),
        receive_date: formData.get('receiveDate'),
        due_date: formData.get('dueDate'),
        note: formData.get('note') || '',
        status: 'active',
        store: formData.get('store') || currentStore
    };
    
    console.log('üíæ Saving pawn data:', {
        store: pawnData.store,
        brand: pawnData.brand,
        model: pawnData.model,
        pawn_amount: pawnData.pawn_amount,
        interest: pawnData.interest,
        interest_collection_method: pawnData.interest_collection_method
    });

    try {
        if (currentPawnEditId) {
            // Update existing pawn - get current data first
            const currentPawn = await API.get(`${API_ENDPOINTS.pawn}/${currentPawnEditId}`);
            pawnData.return_date = currentPawn.return_date;
            pawnData.seized_date = currentPawn.seized_date;
            pawnData.status = currentPawn.status;

            // Keep the original store if not provided in form
            if (!formData.get('store')) {
                pawnData.store = currentPawn.store;
            }

            console.log('üîÑ Updating pawn:', {
                id: currentPawnEditId,
                store: pawnData.store,
                current_store: currentPawn.store
            });

            await API.put(`${API_ENDPOINTS.pawn}/${currentPawnEditId}`, pawnData);
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } else {
            // Add new pawn
            pawnData.return_date = null;
            pawnData.seized_date = null;
            const newPawn = await API.post(API_ENDPOINTS.pawn, pawnData);

            // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å transaction ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å
            if (pawnData.interest_collection_method === 'deducted' && newPawn && newPawn.id) {
                await API.post('http://localhost:5001/api/pawn-interest', {
                    pawn_id: newPawn.id,
                    interest_amount: pawnData.interest,
                    late_fee: 0,
                    transaction_type: 'initial_deduction',
                    transaction_date: pawnData.receive_date,
                    store: pawnData.store
                });
            }

            showNotification('‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }

        // Reload data
        await loadPawnData();

        // Update dashboard to reflect new income
        await updateDashboard();

        // Close modal
        closePawnModal();
    } catch (error) {
        console.error('Error saving pawn:', error);

        // Check if it's a duplicate IMEI error
        if (error.duplicate || (error.message && error.message.includes('IMEI'))) {
            await customAlert({
                title: '‚ùå IMEI ‡∏ã‡πâ‡∏≥',
                message: `IMEI "${pawnData.imei}" ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö IMEI ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà`,
                icon: 'error'
            });
        } else {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
                icon: 'error'
            });
        }
    }
}

// Load and display pawn data
async function loadPawnData() {
    try {
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('üîÑ [loadPawnData] START');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        
        // Get all pawns from API (MySQL database)
        const allPawns = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
        
        console.log('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏à‡∏≤‡∏Å MySQL database ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        console.log(`üìä ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${allPawns.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô ${currentStore}`);
        console.log('üì¶ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:', allPawns.map(p => ({
            id: p.id,
            brand: p.brand,
            model: p.model,
            status: p.status,
            receiveDate: p.receive_date || p.receiveDate,
            returnDate: p.return_date || p.returnDate,
            seizedDate: p.seized_date || p.seizedDate
        })));

        // Active: Show current data always (no date filter)
        const activePawns = allPawns.filter(p => p.status === 'active');
        displayPawns(activePawns, 'pawnActiveTableBody', 'active');

        // Returned: Filter by return_date
        let returnedPawns = allPawns.filter(p => p.status === 'returned');

        // Apply date filter if exists
        if (currentPawnFilter.startDate || currentPawnFilter.endDate) {
            returnedPawns = returnedPawns.filter(pawn => {
                const returnDate = pawn.return_date || pawn.returnDate;
                if (!returnDate) return false;
                
                const date = new Date(returnDate);
                const startMatch = !currentPawnFilter.startDate || 
                                  date >= new Date(currentPawnFilter.startDate);
                const endMatch = !currentPawnFilter.endDate || 
                                date <= new Date(currentPawnFilter.endDate + 'T23:59:59');
                
                return startMatch && endMatch;
            });
        } else {
            // Default: current month
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        returnedPawns = returnedPawns.filter(pawn => {
            const returnDate = pawn.return_date || pawn.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
        }

        displayPawns(returnedPawns, 'pawnReturnedTableBody', 'returned');

        // Seized: Filter by seized_date
        let seizedPawns = allPawns.filter(p => p.status === 'seized');

        // Apply date filter if exists
        if (currentPawnFilter.startDate || currentPawnFilter.endDate) {
            seizedPawns = seizedPawns.filter(pawn => {
                const seizedDate = pawn.seized_date || pawn.seizedDate;
                if (!seizedDate) return false;
                
                const date = new Date(seizedDate);
                const startMatch = !currentPawnFilter.startDate || 
                                  date >= new Date(currentPawnFilter.startDate);
                const endMatch = !currentPawnFilter.endDate || 
                                date <= new Date(currentPawnFilter.endDate + 'T23:59:59');
                
                return startMatch && endMatch;
            });
        } else {
            // Default: current month
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();
            
        seizedPawns = seizedPawns.filter(pawn => {
            const seizedDate = pawn.seized_date || pawn.seizedDate;
            if (!seizedDate) return false;
            const date = new Date(seizedDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
        }

        displayPawns(seizedPawns, 'pawnSeizedTableBody', 'seized');

        console.log('üìä Default Filter Result (current month):');
        console.log(`   ‚Ä¢ Active (no filter): ${activePawns.length}`);
        console.log(`   ‚Ä¢ Returned (filtered): ${returnedPawns.length}`);
        console.log(`   ‚Ä¢ Seized (filtered): ${seizedPawns.length}`);

        // Update tab counts with filtered data (matching what's displayed)
        updatePawnTabCounts({
            active: activePawns,
            returned: returnedPawns,
            seized: seizedPawns
        });

        // Update pawn dashboard cards
        console.log('üîÑ [loadPawnData] Calling updatePawnDashboard with', allPawns.length, 'pawns');
        console.log('üì¶ [loadPawnData] Store:', currentStore);
        await updatePawnDashboard(allPawns);
        console.log('‚úÖ [loadPawnData] Dashboard updated');

        // Update dashboard stats
        updateDashboard();
        
        console.log('‚úÖ [loadPawnData] COMPLETE');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    } catch (error) {
        console.error('‚ùå [loadPawnData] Error:', error);
        console.error('Error loading pawn data:', error);
        showNotification('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
    }
}

// Display pawns in table
function displayPawns(pawns, tableBodyId, type) {
    const tbody = document.getElementById(tableBodyId);

    if (!tbody) return;

    if (pawns.length === 0) {
        const colspan = type === 'active' ? '13' : '12';
        tbody.innerHTML = `<tr><td colspan="${colspan}" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>`;
        return;
    }

    tbody.innerHTML = pawns.map(pawn => {
        // Handle both snake_case and camelCase field names
        const pawnAmount = pawn.pawn_amount || pawn.pawnAmount;
        const receiveDate = pawn.receive_date || pawn.receiveDate;
        const dueDate = pawn.due_date || pawn.dueDate;
        const returnDate = pawn.return_date || pawn.returnDate;
        const seizedDate = pawn.seized_date || pawn.seizedDate;

        const ramRom = `${pawn.ram}/${pawn.rom} GB`;

        if (type === 'active') {
            // Calculate overdue days
            const overdueDays = getPawnOverdueDays(pawn);
            
            return `
                <tr>
                    <td style="width: 5%;">${pawn.brand}</td>
                    <td style="width: 7%;">${pawn.model}</td>
                    <td style="width: 4%;">${pawn.color}</td>
                    <td style="width: 7%;">${pawn.imei}</td>
                    <td style="width: 6%;">${ramRom}</td>
                    <td style="width: 7%; text-align: right;">${formatCurrency(pawnAmount)}</td>
                    <td style="width: 6%; text-align: right;">${formatCurrency(pawn.interest)}</td>
                    <td style="width: 6%; text-align: center;">${(pawn.interest_collection_method || pawn.interestCollectionMethod) === 'deducted' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å' : '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å'}</td>
                    <td style="width: 7%; text-align: right;">${formatCurrency(pawn.redemption_amount || pawn.redemptionAmount || 0)}</td>
                    <td style="width: 7%; text-align: center;">${formatDate(receiveDate)}</td>
                    <td style="width: 7%; text-align: center;">${formatDate(dueDate)}</td>
                    <td style="width: 6%; text-align: center; color: ${overdueDays > 0 ? 'red' : 'inherit'}; font-weight: ${overdueDays > 0 ? 'bold' : 'normal'};">${overdueDays}</td>
                    <td style="width: 25%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="pawn-action-select" id="pawn-action-${pawn.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="renew">‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å</option>
                                <option value="return">‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                                <option value="seize">‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executePawnAction('${pawn.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'returned') {
            return `
                <tr>
                    <td style="width: 5%;">${pawn.brand}</td>
                    <td style="width: 7%;">${pawn.model}</td>
                    <td style="width: 4%;">${pawn.color}</td>
                    <td style="width: 7%;">${pawn.imei}</td>
                    <td style="width: 6%;">${ramRom}</td>
                    <td style="width: 7%; text-align: right;">${formatCurrency(pawnAmount)}</td>
                    <td style="width: 6%; text-align: right;">${formatCurrency(pawn.interest)}</td>
                    <td style="width: 6%; text-align: center;">${(pawn.interest_collection_method || pawn.interestCollectionMethod) === 'deducted' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å' : '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å'}</td>
                    <td style="width: 7%; text-align: right;">${formatCurrency(pawn.redemption_amount || pawn.redemptionAmount || 0)}</td>
                    <td style="width: 8%; text-align: center;">${formatDate(receiveDate)}</td>
                    <td style="width: 8%; text-align: center;">${formatDate(returnDate)}</td>
                    <td style="width: 29%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="pawn-action-select" id="pawn-action-${pawn.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="revert">‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executePawnAction('${pawn.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'seized') {
            const transferredBadge = (pawn.transferred_to_used || pawn.transferredToUsed) 
                ? '<span style="color: red; font-weight: bold; margin-left: 10px;">üî¥ ‡πÇ‡∏¢‡∏Å‡πÑ‡∏õ‡∏°‡∏∑‡∏≠ 2</span>' 
                : '';
            
            return `
                <tr>
                    <td style="width: 5%;">${pawn.brand}${transferredBadge}</td>
                    <td style="width: 7%;">${pawn.model}</td>
                    <td style="width: 4%;">${pawn.color}</td>
                    <td style="width: 7%;">${pawn.imei}</td>
                    <td style="width: 6%;">${ramRom}</td>
                    <td style="width: 7%; text-align: right;">${formatCurrency(pawnAmount)}</td>
                    <td style="width: 6%; text-align: right;">${formatCurrency(pawn.interest)}</td>
                    <td style="width: 6%; text-align: center;">${(pawn.interest_collection_method || pawn.interestCollectionMethod) === 'deducted' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å' : '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å'}</td>
                    <td style="width: 7%; text-align: right;">${formatCurrency(pawn.redemption_amount || pawn.redemptionAmount || 0)}</td>
                    <td style="width: 8%; text-align: center;">${formatDate(receiveDate)}</td>
                    <td style="width: 8%; text-align: center;">${formatDate(seizedDate)}</td>
                    <td style="width: 29%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="pawn-action-select" id="pawn-action-${pawn.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="revert">‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å</option>
                                <option value="send-used" ${(pawn.transferred_to_used || pawn.transferredToUsed) ? 'disabled' : ''}>‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executePawnAction('${pawn.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        }
    }).join('');
}

// Renew pawn (extend due date by 14 days)
async function renewPawn(pawnId) {
    try {
        const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
        if (!pawn) {
            alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å');
            return;
        }

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡∏°‡πà (‡πÄ‡∏û‡∏¥‡πà‡∏° 14 ‡∏ß‡∏±‡∏ô)
        const dueDate = pawn.due_date || pawn.dueDate;
        const currentDueDate = new Date(dueDate);
        currentDueDate.setDate(currentDueDate.getDate() + 14);
        const newDueDate = currentDueDate.toISOString().split('T')[0];

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏¢‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        const today = new Date();
        today.setHours(0, 0, 0, 0); // reset ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡πá‡∏ô 00:00:00
        const dueDateObj = new Date(dueDate);
        dueDateObj.setHours(0, 0, 0, 0);
        const isOverdue = today > dueDateObj;

        // ‡πÄ‡∏õ‡∏¥‡∏î modal
        openRenewPawnModal(pawn, newDueDate, isOverdue);
    } catch (error) {
        console.error('Error loading pawn data:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
    }
}

// Open renew pawn modal
function openRenewPawnModal(pawn, newDueDate, isOverdue) {
    const modal = document.getElementById('renewPawnModal');
    
    // Set pawn info
    document.getElementById('renewPawnDevice').value = `${pawn.brand} ${pawn.model}`;
    document.getElementById('renewPawnOldDueDate').value = formatDate(pawn.due_date || pawn.dueDate);
    document.getElementById('renewPawnNewDueDate').value = formatDate(newDueDate);
    document.getElementById('renewPawnInterest').value = formatCurrency(pawn.interest);
    document.getElementById('renewPawnId').value = pawn.id;
    
    // Reset late fee
    document.getElementById('renewPawnLateFee').value = 0;
    
    // ‡πÅ‡∏™‡∏î‡∏á/‡∏ã‡πà‡∏≠‡∏ô ‡∏ä‡πà‡∏≠‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏¢‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const lateFeeGroup = document.getElementById('lateFeeGroup');
    const lateFeeWarning = document.getElementById('lateFeeWarning');
    
    if (isOverdue) {
        lateFeeGroup.style.display = 'block';
        lateFeeWarning.style.display = 'block';
    } else {
        lateFeeGroup.style.display = 'none';
        lateFeeWarning.style.display = 'none';
    }
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏£‡∏ß‡∏°
    calculateRenewTotalIncome();
    
    // Add event listener for late fee input
    const lateFeeInput = document.getElementById('renewPawnLateFee');
    lateFeeInput.removeEventListener('input', calculateRenewTotalIncome);
    lateFeeInput.addEventListener('input', calculateRenewTotalIncome);
    
    modal.classList.add('show');
}

// Calculate total income for renew (interest + late fee)
function calculateRenewTotalIncome() {
    const interestText = document.getElementById('renewPawnInterest').value;
    const interest = parseFloat(interestText.replace(/[^0-9.-]+/g, '')) || 0;
    const lateFee = parseFloat(document.getElementById('renewPawnLateFee').value) || 0;
    const total = interest + lateFee;
    
    document.getElementById('renewPawnTotalIncome').value = formatCurrency(total);
}

// Close renew pawn modal
function closeRenewPawnModal() {
    const modal = document.getElementById('renewPawnModal');
    modal.classList.remove('show');
}

// Save renew pawn
async function saveRenewPawn(event) {
    event.preventDefault();
    
    const pawnId = document.getElementById('renewPawnId').value;
    const lateFee = parseFloat(document.getElementById('renewPawnLateFee').value) || 0;
    
        try {
            const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
            if (!pawn) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å');
                return;
            }

            const dueDate = pawn.due_date || pawn.dueDate;
            const currentDueDate = new Date(dueDate);
            currentDueDate.setDate(currentDueDate.getDate() + 14);
            const newDueDate = currentDueDate.toISOString().split('T')[0];

            const pawnData = {
                customer_name: pawn.customer_name,
                brand: pawn.brand,
                model: pawn.model,
                color: pawn.color,
                imei: pawn.imei,
                ram: pawn.ram,
                rom: pawn.rom,
                pawn_amount: pawn.pawn_amount || pawn.pawnAmount,
                interest: pawn.interest,
                interest_collection_method: pawn.interest_collection_method,
                redemption_amount: pawn.redemption_amount,
                receive_date: pawn.receive_date || pawn.receiveDate,
                due_date: newDueDate,
                return_date: pawn.return_date || pawn.returnDate,
                seized_date: pawn.seized_date || pawn.seizedDate,
                status: pawn.status,
                note: pawn.note,
                store: pawn.store
            };

            await API.put(`${API_ENDPOINTS.pawn}/${pawnId}`, pawnData);

        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å transaction ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å (‡∏£‡∏ß‡∏°‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö)
        const totalAmount = pawn.interest + lateFee;
            await API.post('http://localhost:5001/api/pawn-interest', {
                pawn_id: pawnId,
            interest_amount: totalAmount, // ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢ + ‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö
            late_fee: lateFee, // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏¢‡∏Å
                transaction_type: 'renewal',
                transaction_date: new Date().toISOString().split('T')[0],
                store: pawn.store
            });

            await loadPawnData();
            await updateDashboard();
        closeRenewPawnModal();
        
        if (lateFee > 0) {
            showNotification(`‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡∏°‡πà: ${formatDate(newDueDate)}\n‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏£‡∏ß‡∏°: ${formatCurrency(totalAmount)} (‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢ ${formatCurrency(pawn.interest)} + ‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö ${formatCurrency(lateFee)})`);
        } else {
            showNotification(`‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡∏°‡πà: ${formatDate(newDueDate)}`);
        }
        } catch (error) {
            console.error('Error renewing pawn:', error);
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
    }
}

// Execute pawn action from dropdown
async function executePawnAction(pawnId) {
    const selectElement = document.getElementById(`pawn-action-${pawnId}`);
    const action = selectElement.value;

    if (!action) {
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'view':
            await viewPawnDetail(pawnId);
            break;
        case 'renew':
            await renewPawn(pawnId);
            break;
        case 'return':
            await returnPawn(pawnId);
            break;
        case 'seize':
            await seizePawn(pawnId);
            break;
        case 'revert':
            await revertPawnToActive(pawnId);
            break;
        case 'send-used':
            await sendPawnToUsedDevices(pawnId);
            break;
        case 'edit':
            await openPawnModal(pawnId);
            break;
        case 'delete':
            await deletePawn(pawnId);
            break;
        default:
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å',
                icon: 'error'
            });
    }

    // Reset select after action
    selectElement.value = '';
}

// Return pawn (customer picks up device)
async function returnPawn(pawnId) {
        try {
            const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
            if (!pawn) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å',
                icon: 'error'
            });
                return;
            }

        // Store current pawn ID for later use
        window.currentReturnPawnId = pawnId;

        // Populate modal with pawn data
        const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color}) - ${pawn.ram}/${pawn.rom} GB`;
        const pawnAmount = pawn.pawn_amount || pawn.pawnAmount || 0;
        const redemptionAmount = pawn.redemption_amount || pawn.redemptionAmount || 0;
        const receiveDate = pawn.receive_date || pawn.receiveDate || '';
        const dueDate = pawn.due_date || pawn.dueDate || '';
        
        // Interest method display
        let interestMethod = '';
        if (pawn.interest_collection_method === 'deduct') {
            interestMethod = `‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å ${pawn.interest}%`;
        } else {
            interestMethod = `‡πÄ‡∏Å‡πá‡∏ö‡∏î‡∏≠‡∏Å ${pawn.interest}%`;
        }

        document.getElementById('returnPawnDeviceInfo').textContent = deviceInfo;
        document.getElementById('returnPawnCustomerInfo').textContent = pawn.customer_name || '-';
        document.getElementById('returnPawnAmountInfo').textContent = formatCurrency(pawnAmount);
        document.getElementById('returnPawnReceiveDateInfo').textContent = formatDate(receiveDate);
        document.getElementById('returnPawnDueDateInfo').textContent = formatDate(dueDate);
        document.getElementById('returnPawnInterestMethodInfo').textContent = interestMethod;
        
        // Set default redemption amount (current value)
        document.getElementById('returnPawnRedemptionAmount').value = redemptionAmount;
        
        // Set existing note
        document.getElementById('returnPawnNote').value = pawn.note || '';

        // Open modal
        document.getElementById('returnPawnModal').style.display = 'block';
    } catch (error) {
        console.error('Error opening return pawn modal:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Close return pawn modal
function closeReturnPawnModal() {
    document.getElementById('returnPawnModal').style.display = 'none';
    document.getElementById('returnPawnForm').reset();
    window.currentReturnPawnId = null;
}

// ==================== Used Devices Expense Detail ====================

// Show used devices expense detail modal
async function showUsedDevicesExpenseDetail() {
    try {
        // Get all used devices for current store
        const allUsedDevices = await API.get(API_ENDPOINTS.usedDevices, { store: currentStore });
        
        console.log('üîç Used Devices Expense Detail:', {
            currentStore,
            totalDevices: allUsedDevices.length,
            allDevicesStatus: allUsedDevices.map(d => ({ brand: d.brand, model: d.model, status: d.status }))
        });
        
        // Use date range filter from currentUsedDevicesFilter
        let filteredDevices;
        let filterText = '';
        
        if (currentUsedDevicesFilter.startDate || currentUsedDevicesFilter.endDate) {
            // Use date range filter - ‡∏£‡∏±‡∏ö‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á status)
            filteredDevices = allUsedDevices.filter(device => {
                const importDate = new Date(device.import_date || device.importDate || 
                                            device.purchase_date || device.purchaseDate);
                const startMatch = !currentUsedDevicesFilter.startDate || 
                                  importDate >= new Date(currentUsedDevicesFilter.startDate);
                const endMatch = !currentUsedDevicesFilter.endDate || 
                                importDate <= new Date(currentUsedDevicesFilter.endDate);
                
                return startMatch && endMatch;
            });
            
            // Format filter text
            if (currentUsedDevicesFilter.startDate && currentUsedDevicesFilter.endDate) {
                filterText = `${formatDate(currentUsedDevicesFilter.startDate)} ‡∏ñ‡∏∂‡∏á ${formatDate(currentUsedDevicesFilter.endDate)}`;
            } else if (currentUsedDevicesFilter.startDate) {
                filterText = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentUsedDevicesFilter.startDate)}`;
            } else if (currentUsedDevicesFilter.endDate) {
                filterText = `‡∏ñ‡∏∂‡∏á ${formatDate(currentUsedDevicesFilter.endDate)}`;
            }
        } else {
            // No filter: use global currentMonth (from dashboard filter) - ‡∏£‡∏±‡∏ö‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á status)
            const selectedYear = currentMonth.substring(0, 4); // "2025"
            const selectedMonthNum = currentMonth.substring(5, 7); // "11"
            
            console.log('üîç Used Devices Expense Detail - Using Dashboard Month:', {
                currentMonth,
                selectedYear,
                selectedMonthNum
            });
            
            filteredDevices = allUsedDevices.filter(device => {
                const importDate = new Date(device.import_date || device.importDate || 
                                            device.purchase_date || device.purchaseDate);
                const deviceYear = importDate.getFullYear().toString();
                const deviceMonth = (importDate.getMonth() + 1).toString().padStart(2, '0');
                
                const match = deviceYear === selectedYear && deviceMonth === selectedMonthNum;
                
                console.log(`  ${device.brand} ${device.model}: date=${device.purchase_date || device.purchaseDate}, match=${match}`);
                
                return match;
            });
            
            const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                              '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
            const monthIndex = parseInt(selectedMonthNum) - 1;
            const yearBE = parseInt(selectedYear) + 543;
            filterText = `${monthNames[monthIndex]} ${yearBE}`;
        }
        
        const monthDevices = filteredDevices;
        
        // Calculate total expense (purchase prices)
        const totalExpense = monthDevices.reduce((sum, device) => {
            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
            return sum + purchasePrice;
        }, 0);
        
        // Update modal content
        document.getElementById('usedDevicesExpenseDetailTotal').textContent = formatCurrency(totalExpense);
        document.getElementById('usedDevicesExpenseDetailCount').textContent = monthDevices.length;
        document.getElementById('usedDevicesExpenseMonth').textContent = filterText;
        
        // Populate table
        const tbody = document.getElementById('usedDevicesExpenseDetailTableBody');
        
        if (monthDevices.length === 0) {
            tbody.innerHTML = '<tr><td colspan="9" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            // Sort by import_date (newest first)
            const sortedDevices = monthDevices.sort((a, b) => {
                const dateA = new Date(a.import_date || a.importDate || a.purchase_date || a.purchaseDate);
                const dateB = new Date(b.import_date || b.importDate || b.purchase_date || b.purchaseDate);
                return dateB - dateA;
            });
            
            tbody.innerHTML = sortedDevices.map(device => {
                const importDate = device.import_date || device.importDate || device.purchase_date || device.purchaseDate || '';
                const ram = device.ram || 0;
                const rom = device.rom || 0;
                const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
                
                // Condition labels in Thai
                const conditionLabels = {
                    'excellent': '‡∏™‡∏†‡∏≤‡∏û‡∏î‡∏µ‡∏°‡∏≤‡∏Å',
                    'good': '‡∏™‡∏†‡∏≤‡∏û‡∏î‡∏µ',
                    'fair': '‡∏™‡∏†‡∏≤‡∏û‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á',
                    'poor': '‡∏™‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ'
                };
                const condition = conditionLabels[device.device_condition || device.deviceCondition] || '-';
                
                // Status labels in Thai
                const statusLabels = {
                    'stock': '‡∏™‡∏ï‡πä‡∏≠‡∏Ñ',
                    'sold': '‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
                    'removed': '‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å'
                };
                const statusText = statusLabels[device.status] || device.status;
                const statusClass = device.status === 'stock' ? 'status-stock' : 
                                  device.status === 'sold' ? 'status-sold' : 'status-removed';
                
                return `
                    <tr>
                        <td>${formatDate(importDate)}</td>
                        <td>${device.brand || '-'}</td>
                        <td>${device.model || '-'}</td>
                        <td>${device.color || '-'}</td>
                        <td>${device.imei || '-'}</td>
                        <td>${ram}/${rom} GB</td>
                        <td>${condition}</td>
                        <td class="expense-text">${formatCurrency(purchasePrice)}</td>
                        <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                    </tr>
                `;
            }).join('');
        }
        
        // Hide main page and show detail page
        document.getElementById('used-devices').classList.remove('active');
        document.getElementById('used-devices-expense-detail').classList.add('active');
        
    } catch (error) {
        console.error('Error showing used devices expense detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Close used devices expense detail modal
function closeUsedDevicesExpenseDetailModal() {
    document.getElementById('usedDevicesExpenseDetailModal').style.display = 'none';
}

// Show used devices income detail modal
async function showUsedDevicesIncomeDetail() {
    try {
        // Get all used devices for current store
        const allUsedDevices = await API.get(API_ENDPOINTS.usedDevices, { store: currentStore });

        // Use date range filter from currentUsedDevicesFilter
        let filteredDevices;
        let filterText = '';
        
        if (currentUsedDevicesFilter.startDate || currentUsedDevicesFilter.endDate) {
            // Use date range filter for SALE DATE
            filteredDevices = allUsedDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                const startMatch = !currentUsedDevicesFilter.startDate || 
                                  saleDate >= new Date(currentUsedDevicesFilter.startDate);
                const endMatch = !currentUsedDevicesFilter.endDate || 
                                saleDate <= new Date(currentUsedDevicesFilter.endDate);
                
                return startMatch && endMatch;
            });
            
            // Format filter text
            if (currentUsedDevicesFilter.startDate && currentUsedDevicesFilter.endDate) {
                filterText = `${formatDate(currentUsedDevicesFilter.startDate)} ‡∏ñ‡∏∂‡∏á ${formatDate(currentUsedDevicesFilter.endDate)}`;
            } else if (currentUsedDevicesFilter.startDate) {
                filterText = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentUsedDevicesFilter.startDate)}`;
            } else if (currentUsedDevicesFilter.endDate) {
                filterText = `‡∏ñ‡∏∂‡∏á ${formatDate(currentUsedDevicesFilter.endDate)}`;
            }
        } else {
            // No filter: show current month SOLD devices only
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();
            
            filteredDevices = allUsedDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                return saleDate.getMonth() + 1 === currentMonth && 
                       saleDate.getFullYear() === currentYear;
            });
            
            const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                              '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
            filterText = `${monthNames[currentMonth - 1]} ${currentYear + 543}`;
        }

        const monthDevices = filteredDevices;

        // Calculate total income (sale prices)
        const totalIncome = monthDevices.reduce((sum, device) => {
            const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
            return sum + salePrice;
        }, 0);

        // Update modal content
        document.getElementById('usedDevicesIncomeDetailTotal').textContent = formatCurrency(totalIncome);
        document.getElementById('usedDevicesIncomeDetailCount').textContent = monthDevices.length;
        document.getElementById('usedDevicesIncomeMonth').textContent = filterText;

        // Populate table
        const tbody = document.getElementById('usedDevicesIncomeDetailTableBody');
        if (monthDevices.length === 0) {
            tbody.innerHTML = '<tr><td colspan="9" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            tbody.innerHTML = monthDevices.map(device => {
                const saleDate = new Date(device.sale_date || device.saleDate);
                const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
                const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
                const profit = salePrice - purchasePrice;
                const ram = device.ram || '-';
                const rom = device.rom || '-';
                const condition = device.device_condition === 'good' ? '‡∏î‡∏µ' :
                                 device.device_condition === 'fair' ? '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á' :
                                 device.device_condition === 'poor' ? '‡πÅ‡∏¢‡πà' : device.device_condition;

                return `
                    <tr>
                        <td>${formatDate(saleDate)}</td>
                        <td>${device.brand || '-'}</td>
                        <td>${device.model || '-'}</td>
                        <td>${device.color || '-'}</td>
                        <td>${device.imei || '-'}</td>
                        <td>${ram}/${rom} GB</td>
                        <td>${condition}</td>
                        <td class="income-text">${formatCurrency(salePrice)}</td>
                        <td class="profit-text">${formatCurrency(profit)}</td>
                    </tr>
                `;
            }).join('');
        }

        // Hide main page and show detail page
        document.getElementById('used-devices').classList.remove('active');
        document.getElementById('used-devices-income-detail').classList.add('active');

    } catch (error) {
        console.error('Error showing used devices income detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Close used devices income detail modal
function closeUsedDevicesIncomeDetailModal() {
    document.getElementById('usedDevicesIncomeDetailModal').style.display = 'none';
}

// Show used devices profit detail modal
async function showUsedDevicesProfitDetail() {
    try {
        // Get all used devices for current store
        const allUsedDevices = await API.get(API_ENDPOINTS.usedDevices, { store: currentStore });

        // Use date range filter from currentUsedDevicesFilter
        let filteredDevices;
        let filterText = '';
        
        if (currentUsedDevicesFilter.startDate || currentUsedDevicesFilter.endDate) {
            // Use date range filter for SALE DATE
            filteredDevices = allUsedDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                const startMatch = !currentUsedDevicesFilter.startDate || 
                                  saleDate >= new Date(currentUsedDevicesFilter.startDate);
                const endMatch = !currentUsedDevicesFilter.endDate || 
                                saleDate <= new Date(currentUsedDevicesFilter.endDate);
                
                return startMatch && endMatch;
            });
            
            // Format filter text
            if (currentUsedDevicesFilter.startDate && currentUsedDevicesFilter.endDate) {
                filterText = `${formatDate(currentUsedDevicesFilter.startDate)} ‡∏ñ‡∏∂‡∏á ${formatDate(currentUsedDevicesFilter.endDate)}`;
            } else if (currentUsedDevicesFilter.startDate) {
                filterText = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentUsedDevicesFilter.startDate)}`;
            } else if (currentUsedDevicesFilter.endDate) {
                filterText = `‡∏ñ‡∏∂‡∏á ${formatDate(currentUsedDevicesFilter.endDate)}`;
            }
        } else {
            // No filter: show current month SOLD devices only
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();
            
            filteredDevices = allUsedDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                return saleDate.getMonth() + 1 === currentMonth && 
                       saleDate.getFullYear() === currentYear;
            });
            
            const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                              '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
            filterText = `${monthNames[currentMonth - 1]} ${currentYear + 543}`;
        }

        const monthDevices = filteredDevices;

        // Calculate totals
        let totalExpense = 0;
        let totalIncome = 0;

        monthDevices.forEach(device => {
            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
            const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
            totalExpense += purchasePrice;
            totalIncome += salePrice;
        });

        const totalProfit = totalIncome - totalExpense;

        // Update modal content
        document.getElementById('usedDevicesProfitDetailTotal').textContent = formatCurrency(totalProfit);
        document.getElementById('usedDevicesProfitDetailCount').textContent = monthDevices.length;
        document.getElementById('usedDevicesProfitMonth').textContent = filterText;
        document.getElementById('usedDevicesProfitExpense').textContent = formatCurrency(totalExpense);
        document.getElementById('usedDevicesProfitIncome').textContent = formatCurrency(totalIncome);
        document.getElementById('usedDevicesProfitProfit').textContent = formatCurrency(totalProfit);

        // Populate table
        const tbody = document.getElementById('usedDevicesProfitDetailTableBody');
        if (monthDevices.length === 0) {
            tbody.innerHTML = '<tr><td colspan="9" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            tbody.innerHTML = monthDevices.map(device => {
                const saleDate = new Date(device.sale_date || device.saleDate);
                const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
                const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
                const profit = salePrice - purchasePrice;
                const ram = device.ram || '-';
                const rom = device.rom || '-';

                return `
                    <tr>
                        <td>${formatDate(saleDate)}</td>
                        <td>${device.brand || '-'}</td>
                        <td>${device.model || '-'}</td>
                        <td>${device.color || '-'}</td>
                        <td>${device.imei || '-'}</td>
                        <td>${ram}/${rom} GB</td>
                        <td class="expense-text">${formatCurrency(purchasePrice)}</td>
                        <td class="income-text">${formatCurrency(salePrice)}</td>
                        <td class="profit-text">${formatCurrency(profit)}</td>
                    </tr>
                `;
            }).join('');
        }

        // Hide main page and show detail page
        document.getElementById('used-devices').classList.remove('active');
        document.getElementById('used-devices-profit-detail').classList.add('active');

    } catch (error) {
        console.error('Error showing used devices profit detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≥‡πÑ‡∏£‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Close used devices profit detail modal
function closeUsedDevicesProfitDetailModal() {
    document.getElementById('usedDevicesProfitDetailModal').style.display = 'none';
}

// ==================== New Devices Expense Detail ====================

// Show new devices expense detail modal
async function showNewDevicesExpenseDetail() {
    console.log('‚úÖ showNewDevicesExpenseDetail() called');
    console.log('üìç Current page:', document.querySelector('.page-content.active')?.id || 'none');
    
    try {
        // Get all new devices for current store
        const allNewDevices = await API.get(API_ENDPOINTS.newDevices, { store: currentStore });
        
        console.log('üîç New Devices Expense Detail:', {
            currentStore,
            totalDevices: allNewDevices.length,
            deviceTypes: allNewDevices.map(d => ({ brand: d.brand, model: d.model, status: d.status }))
        });
        
        // Use date range filter from currentNewDevicesFilter
        let filteredDevices;
        let filterText = '';
        
        if (currentNewDevicesFilter.startDate || currentNewDevicesFilter.endDate) {
            // Use date range filter
            filteredDevices = allNewDevices.filter(device => {
                const importDate = new Date(device.import_date || device.importDate);
                const startMatch = !currentNewDevicesFilter.startDate || 
                                  importDate >= new Date(currentNewDevicesFilter.startDate);
                const endMatch = !currentNewDevicesFilter.endDate || 
                                importDate <= new Date(currentNewDevicesFilter.endDate);
                
                return startMatch && endMatch;
            });
            
            // Format filter text
            if (currentNewDevicesFilter.startDate && currentNewDevicesFilter.endDate) {
                filterText = `${formatDate(currentNewDevicesFilter.startDate)} ‡∏ñ‡∏∂‡∏á ${formatDate(currentNewDevicesFilter.endDate)}`;
            } else if (currentNewDevicesFilter.startDate) {
                filterText = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentNewDevicesFilter.startDate)}`;
            } else if (currentNewDevicesFilter.endDate) {
                filterText = `‡∏ñ‡∏∂‡∏á ${formatDate(currentNewDevicesFilter.endDate)}`;
            }
        } else {
            // No filter: show current month devices only (exclude removed)
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();
            
            filteredDevices = allNewDevices.filter(device => {
                if (device.status === 'removed') return false;
                const importDate = new Date(device.import_date || device.importDate);
                return importDate.getMonth() + 1 === currentMonth && 
                       importDate.getFullYear() === currentYear;
            });
            
            const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                              '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
            filterText = `${monthNames[currentMonth - 1]} ${currentYear + 543}`;
        }
        
        const monthDevices = filteredDevices;
        
        console.log('üìä Filtered devices:', {
            count: monthDevices.length,
            devices: monthDevices,
            filterText
        });
        
        // Calculate total expense (purchase prices)
        const totalExpense = monthDevices.reduce((sum, device) => {
            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
            return sum + purchasePrice;
        }, 0);
        
        console.log('üí∞ Total expense:', formatCurrency(totalExpense));
        
        // Update modal content
        document.getElementById('newDevicesExpenseDetailTotal').textContent = formatCurrency(totalExpense);
        document.getElementById('newDevicesExpenseDetailCount').textContent = monthDevices.length;
        document.getElementById('newDevicesExpenseMonth').textContent = filterText;
        
        // Populate table
        const tbody = document.getElementById('newDevicesExpenseDetailTableBody');
        
        console.log('üîç Table body element:', tbody ? 'Found' : 'NOT FOUND');
        
        if (monthDevices.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            // Sort by import_date (newest first)
            const sortedDevices = monthDevices.sort((a, b) => {
                const dateA = new Date(a.import_date || a.importDate);
                const dateB = new Date(b.import_date || b.importDate);
                return dateB - dateA;
            });
            
            tbody.innerHTML = sortedDevices.map(device => {
                const importDate = device.import_date || device.importDate || '';
                const ram = device.ram || 0;
                const rom = device.rom || 0;
                const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
                
                // Status labels in Thai
                const statusLabels = {
                    'stock': '‡∏™‡∏ï‡πä‡∏≠‡∏Ñ',
                    'sold': '‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
                    'removed': '‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å'
                };
                const status = statusLabels[device.status] || device.status;
                
                return `
                    <tr>
                        <td>${formatDate(importDate)}</td>
                        <td>${device.brand}</td>
                        <td>${device.model}</td>
                        <td>${device.color}</td>
                        <td>${device.imei}</td>
                        <td>${ram}/${rom} GB</td>
                        <td>${formatCurrency(purchasePrice)}</td>
                        <td><span class="status-badge status-${device.status}">${status}</span></td>
                    </tr>
                `;
            }).join('');
        }
        
        // Hide main page and show detail page
        console.log('üîÑ Starting page switch...');
        const mainPage = document.getElementById('new-devices');
        const detailPage = document.getElementById('new-devices-expense-detail');

        console.log('üìÑ Elements:', {
            mainPage: mainPage ? 'found' : 'NOT FOUND',
            detailPage: detailPage ? 'found' : 'NOT FOUND'
        });

        if (mainPage && detailPage) {
            mainPage.classList.remove('active');
            detailPage.classList.add('active');
            console.log('‚úÖ Page switched!');
            console.log('üìç New active page:', document.querySelector('.page-content.active')?.id || 'none');
        } else {
            console.error('‚ùå Cannot switch page - elements not found!');
        }
        
    } catch (error) {
        console.error('Error showing new devices expense detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Back to new devices page (no longer needed - will be removed)
// function closeNewDevicesExpenseDetailModal() {
//     document.getElementById('newDevicesExpenseDetailModal').style.display = 'none';
// }

// Show new devices income detail modal
async function showNewDevicesIncomeDetail() {
    try {
        const allNewDevices = await API.get(API_ENDPOINTS.newDevices, { store: currentStore });
        
        // Use date range filter from currentNewDevicesFilter
        let filteredDevices;
        let filterText = '';
        
        if (currentNewDevicesFilter.startDate || currentNewDevicesFilter.endDate) {
            // Use date range filter for SALE DATE
            filteredDevices = allNewDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                const startMatch = !currentNewDevicesFilter.startDate || 
                                  saleDate >= new Date(currentNewDevicesFilter.startDate);
                const endMatch = !currentNewDevicesFilter.endDate || 
                                saleDate <= new Date(currentNewDevicesFilter.endDate);
                
                return startMatch && endMatch;
            });
            
            // Format filter text
            if (currentNewDevicesFilter.startDate && currentNewDevicesFilter.endDate) {
                filterText = `${formatDate(currentNewDevicesFilter.startDate)} ‡∏ñ‡∏∂‡∏á ${formatDate(currentNewDevicesFilter.endDate)}`;
            } else if (currentNewDevicesFilter.startDate) {
                filterText = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentNewDevicesFilter.startDate)}`;
            } else if (currentNewDevicesFilter.endDate) {
                filterText = `‡∏ñ‡∏∂‡∏á ${formatDate(currentNewDevicesFilter.endDate)}`;
            }
        } else {
            // No filter: show current month SOLD devices only
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();
            
            filteredDevices = allNewDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                return saleDate.getMonth() + 1 === currentMonth && 
                       saleDate.getFullYear() === currentYear;
            });
            
            const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                              '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
            filterText = `${monthNames[currentMonth - 1]} ${currentYear + 543}`;
        }

        const monthDevices = filteredDevices;
        const totalIncome = monthDevices.reduce((sum, device) => sum + parseFloat(device.sale_price || device.salePrice || 0), 0);

        document.getElementById('newDevicesIncomeDetailTotal').textContent = formatCurrency(totalIncome);
        document.getElementById('newDevicesIncomeDetailCount').textContent = monthDevices.length;
        document.getElementById('newDevicesIncomeMonth').textContent = filterText;

        const tbody = document.getElementById('newDevicesIncomeDetailTableBody');
        tbody.innerHTML = monthDevices.length === 0 ? '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>' :
            monthDevices.map(device => {
                const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
                const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
                return `<tr>
                    <td>${formatDate(new Date(device.sale_date))}</td>
                    <td>${device.brand || '-'}</td>
                    <td>${device.model || '-'}</td>
                    <td>${device.color || '-'}</td>
                    <td>${device.imei || '-'}</td>
                    <td>${device.ram}/${device.rom} GB</td>
                    <td class="income-text">${formatCurrency(salePrice)}</td>
                    <td class="profit-text">${formatCurrency(salePrice - purchasePrice)}</td>
                </tr>`;
            }).join('');

        // Hide main page and show detail page
        document.getElementById('new-devices').classList.remove('active');
        document.getElementById('new-devices-income-detail').classList.add('active');

    } catch (error) {
        console.error('Error showing new devices income detail:', error);
        await customAlert({ title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î', message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ: ' + error.message, icon: 'error' });
    }
}

// function closeNewDevicesIncomeDetailModal() {
//     document.getElementById('newDevicesIncomeDetailModal').style.display = 'none';
// }

// Show new devices profit detail modal
async function showNewDevicesProfitDetail() {
    try {
        const allNewDevices = await API.get(API_ENDPOINTS.newDevices, { store: currentStore });
        
        // Use date range filter from currentNewDevicesFilter
        let filteredDevices;
        let filterText = '';
        
        if (currentNewDevicesFilter.startDate || currentNewDevicesFilter.endDate) {
            // Use date range filter for SALE DATE
            filteredDevices = allNewDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                const startMatch = !currentNewDevicesFilter.startDate || 
                                  saleDate >= new Date(currentNewDevicesFilter.startDate);
                const endMatch = !currentNewDevicesFilter.endDate || 
                                saleDate <= new Date(currentNewDevicesFilter.endDate);
                
                return startMatch && endMatch;
            });
            
            // Format filter text
            if (currentNewDevicesFilter.startDate && currentNewDevicesFilter.endDate) {
                filterText = `${formatDate(currentNewDevicesFilter.startDate)} ‡∏ñ‡∏∂‡∏á ${formatDate(currentNewDevicesFilter.endDate)}`;
            } else if (currentNewDevicesFilter.startDate) {
                filterText = `‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà ${formatDate(currentNewDevicesFilter.startDate)}`;
            } else if (currentNewDevicesFilter.endDate) {
                filterText = `‡∏ñ‡∏∂‡∏á ${formatDate(currentNewDevicesFilter.endDate)}`;
            }
        } else {
            // No filter: show current month SOLD devices only
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();
            
            filteredDevices = allNewDevices.filter(device => {
                if (!device.sale_date || device.status !== 'sold') return false;
                const saleDate = new Date(device.sale_date || device.saleDate);
                return saleDate.getMonth() + 1 === currentMonth && 
                       saleDate.getFullYear() === currentYear;
            });
            
            const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                              '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
            filterText = `${monthNames[currentMonth - 1]} ${currentYear + 543}`;
        }

        const monthDevices = filteredDevices;

        let totalExpense = 0, totalIncome = 0;
        monthDevices.forEach(device => {
            totalExpense += parseFloat(device.purchase_price || device.purchasePrice || 0);
            totalIncome += parseFloat(device.sale_price || device.salePrice || 0);
        });
        const totalProfit = totalIncome - totalExpense;

        document.getElementById('newDevicesProfitDetailTotal').textContent = formatCurrency(totalProfit);
        document.getElementById('newDevicesProfitDetailCount').textContent = monthDevices.length;
        document.getElementById('newDevicesProfitMonth').textContent = filterText;
        document.getElementById('newDevicesProfitExpense').textContent = formatCurrency(totalExpense);
        document.getElementById('newDevicesProfitIncome').textContent = formatCurrency(totalIncome);
        document.getElementById('newDevicesProfitProfit').textContent = formatCurrency(totalProfit);

        const tbody = document.getElementById('newDevicesProfitDetailTableBody');
        tbody.innerHTML = monthDevices.length === 0 ? '<tr><td colspan="9" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>' :
            monthDevices.map(device => {
                const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
                const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
                return `<tr>
                    <td>${formatDate(new Date(device.sale_date))}</td>
                    <td>${device.brand || '-'}</td>
                    <td>${device.model || '-'}</td>
                    <td>${device.color || '-'}</td>
                    <td>${device.imei || '-'}</td>
                    <td>${device.ram}/${device.rom} GB</td>
                    <td class="expense-text">${formatCurrency(purchasePrice)}</td>
                    <td class="income-text">${formatCurrency(salePrice)}</td>
                    <td class="profit-text">${formatCurrency(salePrice - purchasePrice)}</td>
                </tr>`;
            }).join('');

        // Hide main page and show detail page
        document.getElementById('new-devices').classList.remove('active');
        document.getElementById('new-devices-profit-detail').classList.add('active');

    } catch (error) {
        console.error('Error showing new devices profit detail:', error);
        await customAlert({ title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î', message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≥‡πÑ‡∏£‡πÑ‡∏î‡πâ: ' + error.message, icon: 'error' });
    }
}

// function closeNewDevicesProfitDetailModal() {
//     document.getElementById('newDevicesProfitDetailModal').style.display = 'none';
// }

// Confirm return pawn with adjusted redemption amount
async function confirmReturnPawn(event) {
    event.preventDefault();

    const pawnId = window.currentReturnPawnId;
    if (!pawnId) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Pawn ID',
            icon: 'error'
        });
        return;
    }

    try {
        const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
        if (!pawn) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å',
                icon: 'error'
            });
            return;
        }

        const formData = new FormData(event.target);
        const adjustedRedemptionAmount = parseFloat(formData.get('redemptionAmount')) || 0;
        const note = formData.get('note') || pawn.note || '';
            const returnDate = new Date().toISOString().split('T')[0];

            const pawnData = {
                customer_name: pawn.customer_name,
                brand: pawn.brand,
                model: pawn.model,
                color: pawn.color,
                imei: pawn.imei,
                ram: pawn.ram,
                rom: pawn.rom,
                pawn_amount: pawn.pawn_amount || pawn.pawnAmount,
                interest: pawn.interest,
                interest_collection_method: pawn.interest_collection_method,
            redemption_amount: adjustedRedemptionAmount,
                receive_date: pawn.receive_date || pawn.receiveDate,
                due_date: pawn.due_date || pawn.dueDate,
                return_date: returnDate,
                seized_date: pawn.seized_date,
                status: 'returned',
            note: note,
                store: pawn.store
            };

            await API.put(`${API_ENDPOINTS.pawn}/${pawnId}`, pawnData);
        closeReturnPawnModal();
            await loadPawnData();
            await updateDashboard();
        
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à\n‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô: ${formatCurrency(adjustedRedemptionAmount)}`,
            icon: 'success'
        });
        } catch (error) {
            console.error('Error returning pawn:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Seize pawn (confiscate device)
async function seizePawn(pawnId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        try {
            const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
            if (!pawn) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å');
                return;
            }

            const seizedDate = new Date().toISOString().split('T')[0];

            const pawnData = {
                customer_name: pawn.customer_name,
                brand: pawn.brand,
                model: pawn.model,
                color: pawn.color,
                imei: pawn.imei,
                ram: pawn.ram,
                rom: pawn.rom,
                pawn_amount: pawn.pawn_amount || pawn.pawnAmount,
                interest: pawn.interest,
                interest_collection_method: pawn.interest_collection_method,
                redemption_amount: pawn.redemption_amount,
                receive_date: pawn.receive_date || pawn.receiveDate,
                due_date: pawn.due_date || pawn.dueDate,
                return_date: pawn.return_date,
                seized_date: seizedDate,
                status: 'seized',
                note: pawn.note,
                store: pawn.store
            };

            await API.put(`${API_ENDPOINTS.pawn}/${pawnId}`, pawnData);
            loadPawnData();
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            console.error('Error seizing pawn:', error);
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
        }
    }
}

// Revert pawn back to active status (undo return/seize)
async function revertPawnToActive(pawnId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        try {
            const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
            if (!pawn) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å');
                return;
            }

            const pawnData = {
                customer_name: pawn.customer_name,
                brand: pawn.brand,
                model: pawn.model,
                color: pawn.color,
                imei: pawn.imei,
                ram: pawn.ram,
                rom: pawn.rom,
                pawn_amount: pawn.pawn_amount || pawn.pawnAmount,
                interest: pawn.interest,
                interest_collection_method: pawn.interest_collection_method,
                redemption_amount: pawn.redemption_amount,
                receive_date: pawn.receive_date || pawn.receiveDate,
                due_date: pawn.due_date || pawn.dueDate,
                return_date: null,
                seized_date: null,
                status: 'active',
                note: pawn.note,
                store: pawn.store
            };

            await API.put(`${API_ENDPOINTS.pawn}/${pawnId}`, pawnData);
            loadPawnData();
            showNotification('‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            console.error('Error reverting pawn to active:', error);
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
        }
    }
}

// Delete pawn
async function deletePawn(pawnId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? (‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ)')) {
        try {
            await API.delete(`${API_ENDPOINTS.pawn}/${pawnId}`);
            await loadPawnData();
            await updateDashboard();
            showNotification('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
            console.error(error);
        }
    }
}

// Delete interest transaction (for renewal/late fee records)
async function deleteInterestTransaction(transactionId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n\n‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ')) {
        try {
            console.log('üóëÔ∏è Deleting interest transaction:', transactionId);
            
            // Delete via API
            await API.delete(`http://localhost:5001/api/pawn-interest/${transactionId}`);
            
            console.log('‚úÖ Transaction deleted successfully');
            
            // Reload pawn data to refresh dashboard
            await loadPawnData();
            await updateDashboard();
            
            // If on detail page, refresh the detail view
            const detailPage = document.getElementById('pawn-income-detail');
            if (detailPage && detailPage.classList.contains('active')) {
                showPawnIncomeDetailPage();
            }
            
            showNotification('‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            console.error('‚ùå Error deleting transaction:', error);
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£: ' + error.message);
        }
    }
}

// Send seized pawn to used devices
async function sendPawnToUsedDevices(pawnId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        try {
            // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏∂‡∏î
            const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
            if (!pawn) {
                alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å');
                return;
            }

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á - ‡∏•‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å
            const usedDeviceData = {
                id: 'U' + Date.now().toString(),
                brand: pawn.brand,
                model: pawn.model,
                color: pawn.color,
                imei: pawn.imei,
                ram: pawn.ram,
                rom: pawn.rom,
                device_condition: '-', // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å ‡πÉ‡∏´‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
                purchase_price: pawn.pawn_amount || pawn.pawnAmount || 0, // ‡πÉ‡∏ä‡πâ‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô
                import_date: new Date().toISOString().split('T')[0],
                sale_price: null,
                sale_date: null,
                status: 'stock',
                note: `‡∏¢‡∏∂‡∏î‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å - ‡∏¢‡∏≠‡∏î‡∏ù‡∏≤‡∏Å: ${formatCurrency(pawn.pawn_amount || pawn.pawnAmount || 0)}`,
                store: pawn.store,
                source_pawn_id: pawnId // ‡πÄ‡∏Å‡πá‡∏ö ID ‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á
            };

            // ‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á
            await API.post(API_ENDPOINTS.usedDevices, usedDeviceData);

            // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å - ‡πÑ‡∏°‡πà‡∏•‡∏ö ‡πÅ‡∏ï‡πà‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡πÇ‡∏¢‡∏Å‡πÑ‡∏õ‡∏°‡∏∑‡∏≠ 2 ‡πÅ‡∏•‡πâ‡∏ß
            await API.put(`${API_ENDPOINTS.pawn}/${pawnId}`, {
                ...pawn,
                transferred_to_used: true, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ô‡∏µ‡πâ
                transferred_date: new Date().toISOString().split('T')[0]
            });

            loadPawnData();
            showNotification('‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏™‡∏†‡∏≤‡∏û‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£');
        } catch (error) {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
            console.error(error);
        }
    }
}

// Update pawn tab counts
function updatePawnTabCounts(filteredPawns = {}) {
    // Count pawns from filtered data (matching what's displayed in tables)
    const activeCount = filteredPawns.active ? filteredPawns.active.length : 0;
    const returnedCount = filteredPawns.returned ? filteredPawns.returned.length : 0;
    const seizedCount = filteredPawns.seized ? filteredPawns.seized.length : 0;

    // Update tab counts
    const activeCountElement = document.getElementById('pawnActiveCount');
    const returnedCountElement = document.getElementById('pawnReturnedCount');
    const seizedCountElement = document.getElementById('pawnSeizedCount');

    if (activeCountElement) activeCountElement.textContent = activeCount;
    if (returnedCountElement) returnedCountElement.textContent = returnedCount;
    if (seizedCountElement) seizedCountElement.textContent = seizedCount;
}

// Update pawn dashboard statistics
async function updatePawnDashboard(allPawns = []) {
    try {
        console.log('üîç [updatePawnDashboard] Starting with allPawns:', allPawns);
        console.log('üîç [updatePawnDashboard] Current filter:', currentPawnFilter);
        
        // Helper function to check if date is within filter range
        const isDateInRange = (dateString) => {
            if (!dateString) return false;
            
            const date = new Date(dateString);
            
            if (currentPawnFilter.startDate || currentPawnFilter.endDate) {
                // Use date range filter
                const startMatch = !currentPawnFilter.startDate || 
                                  date >= new Date(currentPawnFilter.startDate);
                const endMatch = !currentPawnFilter.endDate || 
                                date <= new Date(currentPawnFilter.endDate + 'T23:59:59');
                return startMatch && endMatch;
            } else {
                // Default: current month
        const currentDate = new Date();
                const currentMonth = currentDate.getMonth() + 1;
                const currentYear = currentDate.getFullYear();
                return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
            }
        };
        
        console.log('üìÖ Filter criteria:', currentPawnFilter);
        console.log('üì¶ All Pawns Data:', {
            total: allPawns.length,
            byStatus: {
                active: allPawns.filter(p => p.status === 'active').length,
                returned: allPawns.filter(p => p.status === 'returned').length,
                seized: allPawns.filter(p => p.status === 'seized').length
            }
        });

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏¥‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
        console.log('üîç RAW DATA - ‡πÅ‡∏™‡∏î‡∏á ALL FIELDS ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£:');
        allPawns.forEach((pawn, index) => {
            console.log(`\nüìÑ Pawn #${index + 1} (${pawn.brand} ${pawn.model}):`, pawn);
            console.log('   Available date fields:', {
                pawn_date: pawn.pawn_date,
                pawnDate: pawn.pawnDate,
                receive_date: pawn.receive_date,
                receiveDate: pawn.receiveDate,
                created_at: pawn.created_at,
                createdAt: pawn.createdAt,
                return_date: pawn.return_date,
                returnDate: pawn.returnDate,
                seized_date: pawn.seized_date,
                seizedDate: pawn.seizedDate
            });
        });
        
        // 1. ‡∏Å‡∏≤‡∏£‡πå‡∏î "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ù‡∏≤‡∏Å" - ‡πÅ‡∏™‡∏î‡∏á active ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà)
        const activePawns = allPawns.filter(p => p.status === 'active');
        const totalCount = activePawns.length;

        console.log('üì¶ Active Pawns (no date filter):', activePawns.length);

        // 2. ‡∏Å‡∏≤‡∏£‡πå‡∏î "‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢" - ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å (receive_date) ‡∏ï‡∏≤‡∏° date range
        const expensePawns = allPawns.filter(pawn => {
            // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á active ‡πÅ‡∏•‡∏∞ returned ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
            if (pawn.status !== 'active' && pawn.status !== 'returned') return false;
            
            const receiveDate = pawn.receive_date || pawn.receiveDate;
            const isMatch = isDateInRange(receiveDate);
            
            console.log(`üîç Expense Filter - Pawn ${pawn.id} (${pawn.brand} ${pawn.model}):`, {
                receiveDate: receiveDate,
                isMatch: isMatch
            });
            
            return isMatch;
        });
        
        const totalExpense = expensePawns.reduce((sum, pawn) => {
            const pawnAmount = pawn.pawn_amount || pawn.pawnAmount || 0;
            return sum + parseFloat(pawnAmount);
        }, 0);

        console.log('üí∏ Expense Pawns (filtered by receive_date):', {
            count: expensePawns.length,
            totalExpense: totalExpense,
            pawns: expensePawns.map(p => ({
                brand: p.brand,
                model: p.model,
                receiveDate: p.receive_date || p.receiveDate,
                amount: p.pawn_amount || p.pawnAmount,
                status: p.status
            }))
        });

        // 3. ‡∏Å‡∏≤‡∏£‡πå‡∏î "‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö"
        let totalIncome = 0;

        // 3.1 ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å (deducted) - ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° receive_date
        const deductedPawns = allPawns.filter(pawn => {
            // ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ö‡∏ö‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å
            if ((pawn.interest_collection_method || pawn.interestCollectionMethod) !== 'deducted') return false;
            
            // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° receive_date
            const receiveDate = pawn.receive_date || pawn.receiveDate;
            return isDateInRange(receiveDate);
        });
        
        const deductedInterest = deductedPawns.reduce((sum, pawn) => {
            return sum + (parseFloat(pawn.interest) || 0);
        }, 0);
        totalIncome += deductedInterest;

        console.log('üí∞ Deducted Interest (filtered by receive_date):', {
            count: deductedPawns.length,
            deductedInterest: deductedInterest,
            pawns: deductedPawns.map(p => ({
                id: p.id,
                brand: p.brand,
                model: p.model,
                color: p.color,
                customerName: p.customer_name || p.customerName,
                receiveDate: p.receive_date || p.receiveDate,
                interest: p.interest,
                interestMethod: p.interest_collection_method || p.interestCollectionMethod,
                status: p.status,
                pawnAmount: p.pawn_amount || p.pawnAmount
            }))
        });

        // 3.2 ‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô - ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° return_date
        const returnedPawns = allPawns.filter(pawn => {
            if (pawn.status !== 'returned') return false;
            
            const returnDate = pawn.return_date || pawn.returnDate;
            return isDateInRange(returnDate);
        });
        
        const returnedRedemption = returnedPawns.reduce((sum, pawn) => {
            return sum + (parseFloat(pawn.redemption_amount || pawn.redemptionAmount) || 0);
        }, 0);
        totalIncome += returnedRedemption;
        
        console.log('üíµ Returned Redemption (filtered by return_date):', {
            count: returnedPawns.length,
            returnedRedemption: returnedRedemption,
            pawns: returnedPawns.map(p => ({
                id: p.id,
                brand: p.brand,
                model: p.model,
                color: p.color,
                customerName: p.customer_name || p.customerName,
                returnDate: p.return_date || p.returnDate,
                receiveDate: p.receive_date || p.receiveDate,
                redemption: p.redemption_amount || p.redemptionAmount,
                pawnAmount: p.pawn_amount || p.pawnAmount,
                interest: p.interest,
                interestMethod: p.interest_collection_method || p.interestCollectionMethod
            }))
        });

        // 3.3 ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å (‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å pawn-interest table) - ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° transaction_date
        let interestTransactions = [];
        let renewalTransactions = [];  // ‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏Ç‡πâ‡∏≤‡∏á‡∏ô‡∏≠‡∏Å try block
        let renewalIncome = 0;
        try {
            interestTransactions = await API.get('http://localhost:5001/api/pawn-interest', { store: currentStore });
            renewalTransactions = interestTransactions.filter(t => {
                // ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô renewal
                if (t.transaction_type !== 'renewal') return false;
                
                // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° transaction_date
                return isDateInRange(t.transaction_date);
            });
            
            renewalIncome = renewalTransactions.reduce((sum, t) => {
                return sum + (parseFloat(t.interest_amount) || 0) + (parseFloat(t.late_fee) || 0);
            }, 0);
            totalIncome += renewalIncome;
            
            console.log('üîÑ Renewal Interest Calculation:', {
                renewalTransactions: renewalTransactions.length,
                renewalIncome: renewalIncome,
                transactions: renewalTransactions.map(t => ({
                    id: t.id,
                    pawnId: t.pawn_id,
                    date: t.transaction_date,
                    interest: t.interest_amount,
                    lateFee: t.late_fee,
                    total: (t.interest_amount || 0) + (t.late_fee || 0),
                    type: t.transaction_type
                }))
            });
        } catch (error) {
            console.warn('Could not fetch pawn interest transactions:', error);
        }

        // 4. ‡∏Å‡∏≥‡πÑ‡∏£ = ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å + ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å + ‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö
        const totalProfit = deductedInterest + renewalIncome;

        // Store data for detail modals
        pawnDetailData = {
            activePawns,
            allPawns,
            returnedPawns,
            deductedPawns,         // ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å (‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° receive_date ‡πÅ‡∏•‡πâ‡∏ß)
            expensePawns,          // ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ (‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° receive_date ‡πÅ‡∏•‡πâ‡∏ß)
            renewalTransactions,   // ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å (‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° transaction_date ‡πÅ‡∏•‡πâ‡∏ß)
            totalExpense,
            totalIncome,
            totalProfit,
            currentFilter: currentPawnFilter  // ‡πÄ‡∏Å‡πá‡∏ö filter ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏≠‡∏¢‡∏π‡πà
        };

        // Debug logging
        const filterDisplay = currentPawnFilter.startDate || currentPawnFilter.endDate 
            ? `${currentPawnFilter.startDate || '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î'} ‡∏ñ‡∏∂‡∏á ${currentPawnFilter.endDate || '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î'}` 
            : '‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô';
        
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('üîç [updatePawnDashboard] SUMMARY:');
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log(`üìÖ Filter: ${filterDisplay}`);
        console.log('');
        console.log(`üì¶ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ù‡∏≤‡∏Å (Active - no filter): ${activePawns.length} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á`);
        console.log('');
        console.log(`üí∏ ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ (filtered by receive_date):`);
        console.log(`   ‚Ä¢ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á: ${expensePawns.length} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á`);
        console.log(`   ‚Ä¢ ‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°: ‡∏ø${totalExpense.toLocaleString()}`);
        console.log('');
        console.log(`üíµ ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö (filtered by date):`);
        console.log(`   ‚Ä¢ ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å (receive_date): ‡∏ø${deductedInterest.toLocaleString()} (${deductedPawns.length} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á)`);
        console.log(`   ‚Ä¢ ‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô (return_date): ‡∏ø${returnedRedemption.toLocaleString()} (${returnedPawns.length} ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á)`);
        console.log(`   ‚Ä¢ ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å (transaction_date): ‡∏ø${(renewalIncome || 0).toLocaleString()}`);
        console.log(`   ‚Ä¢ ‡∏£‡∏ß‡∏°‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ‡∏ø${totalIncome.toLocaleString()}`);
        console.log('');
        console.log(`üìà ‡∏Å‡∏≥‡πÑ‡∏£ = ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å + ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å + ‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö`);
        console.log(`   = ‡∏ø${deductedInterest.toLocaleString()} + ‡∏ø${renewalIncome.toLocaleString()}`);
        console.log(`   = ‡∏ø${totalProfit.toLocaleString()}`);
        console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

        // Update UI
        const countElement = document.getElementById('pawnDashboardCount');
        const expenseElement = document.getElementById('pawnDashboardExpense');
        const incomeElement = document.getElementById('pawnDashboardIncome');
        const profitElement = document.getElementById('pawnDashboardProfit');

        if (countElement) {
            countElement.textContent = totalCount;
            console.log(`‚úÖ Updated count element: ${totalCount}`);
        } else {
            console.warn('‚ùå Count element not found');
        }
        
        if (expenseElement) {
            expenseElement.textContent = formatCurrency(totalExpense);
            console.log(`‚úÖ Updated expense element: ${formatCurrency(totalExpense)}`);
        } else {
            console.warn('‚ùå Expense element not found');
        }
        
        if (incomeElement) {
            incomeElement.textContent = formatCurrency(totalIncome);
            console.log(`‚úÖ Updated income element: ${formatCurrency(totalIncome)}`);
        } else {
            console.warn('‚ùå Income element not found');
        }
        
        if (profitElement) {
            profitElement.textContent = formatCurrency(totalProfit);
            console.log(`‚úÖ Updated profit element: ${formatCurrency(totalProfit)}`);
        } else {
            console.warn('‚ùå Profit element not found');
        }

    } catch (error) {
        console.error('Error updating pawn dashboard:', error);
    }
}

// Show Pawn Expense Detail Page
function showPawnExpenseDetailPage() {
    // Hide pawn page
    document.getElementById('pawn').classList.remove('active');
    
    // Show expense detail page
    const detailPage = document.getElementById('pawn-expense-detail');
    detailPage.classList.add('active');
    
    console.log('üìÑ [showPawnExpenseDetailPage] Filter:', pawnDetailData.currentFilter);
    
    // Update data
    const totalElement = document.getElementById('pawnExpensePageTotal');
    const tableBody = document.getElementById('pawnExpensePageTableBody');

    if (totalElement) {
        totalElement.textContent = formatCurrency(pawnDetailData.totalExpense);
    }

    // ‡πÉ‡∏ä‡πâ expensePawns ‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° pawn_date ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏≤‡∏Å pawnDetailData
    const expensePawns = (pawnDetailData.expensePawns || []).sort((a, b) => {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å ‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î (descending)
        const dateA = new Date(a.receive_date || a.receiveDate);
        const dateB = new Date(b.receive_date || b.receiveDate);
        return dateB - dateA;
    });

    if (tableBody) {
        if (expensePawns.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        } else {
            tableBody.innerHTML = expensePawns.map(pawn => {
                const receiveDate = formatDate(pawn.receive_date || pawn.receiveDate);
                const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
                const customerName = pawn.customer_name || pawn.customerName;
                const pawnAmount = pawn.pawn_amount || pawn.pawnAmount || 0;
                let status = '';
                if (pawn.status === 'active') status = 'üü¢ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ù‡∏≤‡∏Å';
                else if (pawn.status === 'returned') status = 'üîµ ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß';
                else if (pawn.status === 'seized') status = 'üî¥ ‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á';

                return `
                    <tr>
                        <td>${receiveDate}</td>
                        <td>${deviceInfo}</td>
                        <td>${customerName}</td>
                        <td>${status}</td>
                        <td class="expense-text">${formatCurrency(pawnAmount)}</td>
                    </tr>
                `;
            }).join('');
        }
    }
}

// Show Pawn Expense Detail Modal (keep for backward compatibility)
function showPawnExpenseDetail() {
    const modal = document.getElementById('pawnExpenseDetailModal');
    const totalElement = document.getElementById('pawnExpenseDetailTotal');
    const tableBody = document.getElementById('pawnExpenseDetailTableBody');

    if (totalElement) {
        totalElement.textContent = formatCurrency(pawnDetailData.totalExpense);
    }

    // ‡πÉ‡∏ä‡πâ expensePawns ‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° pawn_date ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏≤‡∏Å pawnDetailData
    const expensePawns = (pawnDetailData.expensePawns || []).sort((a, b) => {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å ‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î (descending)
        const dateA = new Date(a.receive_date || a.receiveDate);
        const dateB = new Date(b.receive_date || b.receiveDate);
        return dateB - dateA;
    });

    console.log('üîç [showPawnExpenseDetail] Filter:', {
        currentFilter: pawnDetailData.currentFilter,
        expenseCount: expensePawns.length
    });

    if (tableBody) {
        if (expensePawns.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            tableBody.innerHTML = expensePawns.map(pawn => {
                const receiveDate = formatDate(pawn.receive_date || pawn.receiveDate);
                const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
                const customerName = pawn.customer_name || pawn.customerName;
                const pawnAmount = pawn.pawn_amount || pawn.pawnAmount || 0;
                let status = '';
                if (pawn.status === 'active') status = 'üü¢ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ù‡∏≤‡∏Å';
                else if (pawn.status === 'returned') status = 'üîµ ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß';
                else if (pawn.status === 'seized') status = 'üî¥ ‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á';

                return `
                    <tr>
                        <td>${receiveDate}</td>
                        <td>${deviceInfo}</td>
                        <td>${customerName}</td>
                        <td>${status}</td>
                        <td class="expense-text">${formatCurrency(pawnAmount)}</td>
                    </tr>
                `;
            }).join('');
        }
    }

    modal.style.display = 'block';
}

function closePawnExpenseDetailModal() {
    document.getElementById('pawnExpenseDetailModal').style.display = 'none';
}

// Show Pawn Income Detail Page
function showPawnIncomeDetailPage() {
    // Hide pawn page
    document.getElementById('pawn').classList.remove('active');
    
    // Show income detail page
    const detailPage = document.getElementById('pawn-income-detail');
    detailPage.classList.add('active');
    
    console.log('üìÑ [showPawnIncomeDetailPage] Filter:', pawnDetailData.currentFilter);
    console.log('üìÑ [showPawnIncomeDetailPage] pawnDetailData:', pawnDetailData);
    
    // 1. ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° pawn_date ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏≤‡∏Å pawnDetailData
    const deductedPawns = (pawnDetailData.deductedPawns || []).sort((a, b) => {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å ‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î (descending)
        const dateA = new Date(a.receive_date || a.receiveDate);
        const dateB = new Date(b.receive_date || b.receiveDate);
        return dateB - dateA;
    });
    
    console.log('üí∞ [Deducted Pawns]:', deductedPawns.map(p => ({
        brand: p.brand,
        model: p.model,
        interest: p.interest,
        method: p.interest_collection_method || p.interestCollectionMethod
    })));
    
    const deductedTotal = deductedPawns.reduce((sum, p) => {
        const interest = parseFloat(p.interest) || 0;
        console.log(`  Adding ${p.brand} ${p.model}: ${interest}`);
        return sum + interest;
    }, 0);
    
    console.log('üìä [Deducted Total]:', deductedTotal);

    document.getElementById('pawnIncomePageDeductedTotal').textContent = formatCurrency(deductedTotal);
    const deductedTableBody = document.getElementById('pawnIncomePageDeductedTableBody');
    if (deductedPawns.length === 0) {
        deductedTableBody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        deductedTableBody.innerHTML = deductedPawns.map(pawn => {
            const receiveDate = formatDate(pawn.receive_date || pawn.receiveDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const interest = pawn.interest || 0;
            let statusBadge = '';
            if (pawn.status === 'returned') statusBadge = ' <span style="color: #4CAF50;">‚úì ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß</span>';
            else if (pawn.status === 'seized') statusBadge = ' <span style="color: #f44336;">‚ö† ‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</span>';

            return `
                <tr>
                    <td>${receiveDate}</td>
                    <td>${deviceInfo}${statusBadge}</td>
                    <td>${customerName}</td>
                    <td class="income-text">${formatCurrency(interest)}</td>
                </tr>
            `;
        }).join('');
    }

    // 2. ‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô (‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô)
    const returnedPawns = (pawnDetailData.returnedPawns || []).sort((a, b) => {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô ‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î (descending)
        const dateA = new Date(a.return_date || a.returnDate);
        const dateB = new Date(b.return_date || b.returnDate);
        return dateB - dateA;
    });
    
    console.log('üíµ [Returned Pawns]:', returnedPawns.map(p => ({
        brand: p.brand,
        model: p.model,
        redemption_amount: p.redemption_amount,
        redemptionAmount: p.redemptionAmount,
        return_date: p.return_date || p.returnDate
    })));
    
    const returnedTotal = returnedPawns.reduce((sum, p) => {
        const redemption = parseFloat(p.redemption_amount || p.redemptionAmount) || 0;
        console.log(`  Adding ${p.brand} ${p.model}: ${redemption}`);
        return sum + redemption;
    }, 0);
    
    console.log('üìä [Returned Total]:', returnedTotal);

    document.getElementById('pawnIncomePageReturnedTotal').textContent = formatCurrency(returnedTotal);
    const returnedTableBody = document.getElementById('pawnIncomePageReturnedTableBody');
    if (returnedPawns.length === 0) {
        returnedTableBody.innerHTML = '<tr><td colspan="4" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        returnedTableBody.innerHTML = returnedPawns.map(pawn => {
            const returnDate = formatDate(pawn.return_date || pawn.returnDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const redemption = pawn.redemption_amount || pawn.redemptionAmount || 0;

            return `
                <tr>
                    <td>${returnDate}</td>
                    <td>${deviceInfo}</td>
                    <td>${customerName}</td>
                    <td class="income-text">${formatCurrency(redemption)}</td>
                </tr>
            `;
        }).join('');
    }

    // 3. ‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° transaction_date ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏≤‡∏Å pawnDetailData
    const renewalTransactions = (pawnDetailData.renewalTransactions || []).sort((a, b) => {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏° ‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î (descending)
        const dateA = new Date(a.transaction_date);
        const dateB = new Date(b.transaction_date);
        return dateB - dateA;
    });
    const renewalTotal = renewalTransactions.reduce((sum, t) => sum + (parseFloat(t.interest_amount) || 0) + (parseFloat(t.late_fee) || 0), 0);

    console.log('üîÑ [showPawnIncomeDetailPage] Renewal Debug:', {
        renewalTransactions: renewalTransactions.length,
        renewalTotal: renewalTotal,
        transactions: renewalTransactions.map(t => ({
            date: t.transaction_date,
            interest: t.interest_amount,
            lateFee: t.late_fee,
            total: (parseFloat(t.interest_amount) || 0) + (parseFloat(t.late_fee) || 0)
        }))
    });

    document.getElementById('pawnIncomePageRenewalTotal').textContent = formatCurrency(renewalTotal);
    const renewalTableBody = document.getElementById('pawnIncomePageRenewalTableBody');
    if (renewalTransactions.length === 0) {
        renewalTableBody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        renewalTableBody.innerHTML = renewalTransactions.map(transaction => {
            const transactionDate = formatDate(transaction.transaction_date);
            const pawn = pawnDetailData.allPawns.find(p => p.id === transaction.pawn_id);
            const deviceInfo = pawn ? `${pawn.brand} ${pawn.model}` : 'N/A';
            const interest = parseFloat(transaction.interest_amount) || 0;
            const lateFee = parseFloat(transaction.late_fee) || 0;
            const total = interest + lateFee;

            return `
                <tr>
                    <td>${transactionDate}</td>
                    <td>${deviceInfo}</td>
                    <td class="income-text">${formatCurrency(interest)}</td>
                    <td class="income-text">${formatCurrency(lateFee)}</td>
                    <td class="income-text"><strong>${formatCurrency(total)}</strong></td>
                    <td>
                        <button class="btn btn-sm btn-danger" onclick="deleteInterestTransaction(${transaction.id})">‡∏•‡∏ö</button>
                    </td>
                </tr>
            `;
        }).join('');
    }

    // Update total income
    const totalIncomeCalculated = deductedTotal + returnedTotal + renewalTotal;
    
    console.log('üíµ [showPawnIncomeDetailPage] Total Income Summary:', {
        deductedInterest: deductedTotal,
        returnedRedemption: returnedTotal,
        renewalIncome: renewalTotal,
        calculatedTotal: totalIncomeCalculated,
        storedTotal: pawnDetailData.totalIncome,
        match: totalIncomeCalculated === pawnDetailData.totalIncome
    });
    
    document.getElementById('pawnIncomePageTotal').textContent = formatCurrency(pawnDetailData.totalIncome);
}

// Show Pawn Profit Detail Page
function showPawnProfitDetailPage() {
    // Hide pawn page
    document.getElementById('pawn').classList.remove('active');
    
    // Show profit detail page
    const detailPage = document.getElementById('pawn-profit-detail');
    detailPage.classList.add('active');

    console.log('üìä [showPawnProfitDetailPage] Filter:', pawnDetailData.currentFilter);
    console.log('üìä [showPawnProfitDetailPage] pawnDetailData:', pawnDetailData);

    // 1. ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° receive_date ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏≤‡∏Å pawnDetailData
    const deductedPawns = (pawnDetailData.deductedPawns || []).sort((a, b) => {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å ‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î (descending)
        const dateA = new Date(a.receive_date || a.receiveDate);
        const dateB = new Date(b.receive_date || b.receiveDate);
        return dateB - dateA;
    });
    
    console.log('üí∞ [Profit - Deducted Pawns]:', deductedPawns.map(p => ({
        brand: p.brand,
        model: p.model,
        interest: p.interest,
        receive_date: p.receive_date || p.receiveDate
    })));
    
    const deductedTotal = deductedPawns.reduce((sum, p) => {
        const interest = parseFloat(p.interest) || 0;
        console.log(`  Adding ${p.brand} ${p.model}: ${interest}`);
        return sum + interest;
    }, 0);
    
    console.log('üìä [Profit - Deducted Total]:', deductedTotal);

    document.getElementById('pawnProfitPageDeductedTotal').textContent = formatCurrency(deductedTotal);
    const deductedTableBody = document.getElementById('pawnProfitPageDeductedTableBody');
    if (deductedPawns.length === 0) {
        deductedTableBody.innerHTML = '<tr><td colspan="4" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        deductedTableBody.innerHTML = deductedPawns.map(pawn => {
            const receiveDate = formatDate(pawn.receive_date || pawn.receiveDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const interest = pawn.interest || 0;
            let statusBadge = '';
            if (pawn.status === 'returned') statusBadge = ' <span style="color: #4CAF50;">‚úì ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß</span>';
            else if (pawn.status === 'seized') statusBadge = ' <span style="color: #f44336;">‚ö† ‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</span>';

            return `
                <tr>
                    <td>${receiveDate}</td>
                    <td>${deviceInfo}${statusBadge}</td>
                    <td>${customerName}</td>
                    <td class="income-text">${formatCurrency(interest)}</td>
                </tr>
            `;
        }).join('');
    }

    // 2. ‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å - ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° transaction_date ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏≤‡∏Å pawnDetailData
    const renewalTransactions = (pawnDetailData.renewalTransactions || []).sort((a, b) => {
        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏° ‡∏à‡∏≤‡∏Å‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤‡∏™‡∏∏‡∏î (descending)
        const dateA = new Date(a.transaction_date);
        const dateB = new Date(b.transaction_date);
        return dateB - dateA;
    });
    
    console.log('üîÑ [Profit - Renewal Transactions]:', renewalTransactions.map(t => ({
        transaction_date: t.transaction_date,
        interest_amount: t.interest_amount,
        late_fee: t.late_fee
    })));
    
    const renewalTotal = renewalTransactions.reduce((sum, t) => {
        const interest = parseFloat(t.interest_amount) || 0;
        const lateFee = parseFloat(t.late_fee) || 0;
        const total = interest + lateFee;
        console.log(`  Adding transaction: interest=${interest}, late_fee=${lateFee}, total=${total}`);
        return sum + total;
    }, 0);
    
    console.log('üìä [Profit - Renewal Total]:', renewalTotal);

    document.getElementById('pawnProfitPageRenewalTotal').textContent = formatCurrency(renewalTotal);
    const renewalTableBody = document.getElementById('pawnProfitPageRenewalTableBody');
    if (renewalTransactions.length === 0) {
        renewalTableBody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        renewalTableBody.innerHTML = renewalTransactions.map(transaction => {
            const transactionDate = formatDate(transaction.transaction_date);
            const pawn = pawnDetailData.allPawns.find(p => p.id === transaction.pawn_id);
            const deviceInfo = pawn ? `${pawn.brand} ${pawn.model}` : 'N/A';
            const interest = parseFloat(transaction.interest_amount) || 0;
            const lateFee = parseFloat(transaction.late_fee) || 0;
            const total = interest + lateFee;

            return `
                <tr>
                    <td>${transactionDate}</td>
                    <td>${deviceInfo}</td>
                    <td class="income-text">${formatCurrency(interest)}</td>
                    <td class="income-text">${formatCurrency(lateFee)}</td>
                    <td class="income-text"><strong>${formatCurrency(total)}</strong></td>
                </tr>
            `;
        }).join('');
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡∏£‡∏ß‡∏° = ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å + ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å + ‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö
    const totalProfit = deductedTotal + renewalTotal;
    
    console.log('üìä [Profit - TOTAL]:', {
        deductedTotal,
        renewalTotal,
        totalProfit
    });
    
    document.getElementById('pawnProfitPageTotal').textContent = formatCurrency(totalProfit);
}

// Back to Pawn page
function backToPawn() {
    // Hide all detail pages
    document.getElementById('pawn-expense-detail').classList.remove('active');
    document.getElementById('pawn-income-detail').classList.remove('active');
    document.getElementById('pawn-profit-detail').classList.remove('active');
    
    // Show pawn page
    document.getElementById('pawn').classList.add('active');
}

// Back to New Devices page
function backToNewDevices() {
    // Hide all detail pages
    document.getElementById('new-devices-expense-detail').classList.remove('active');
    document.getElementById('new-devices-income-detail').classList.remove('active');
    document.getElementById('new-devices-profit-detail').classList.remove('active');

    // Show new devices page
    document.getElementById('new-devices').classList.add('active');
}

// Back to Used Devices page
function backToUsedDevices() {
    // Hide all detail pages
    document.getElementById('used-devices-expense-detail').classList.remove('active');
    document.getElementById('used-devices-income-detail').classList.remove('active');
    document.getElementById('used-devices-profit-detail').classList.remove('active');

    // Show used devices page
    document.getElementById('used-devices').classList.add('active');
}

// Back to Installment page
function backToInstallment() {
    // Hide all detail pages
    document.getElementById('installment-expense-detail').classList.remove('active');
    document.getElementById('installment-income-detail').classList.remove('active');
    document.getElementById('installment-profit-detail').classList.remove('active');

    // Show installment page
    document.getElementById('installment').classList.add('active');
}

// Back to Repair page
function backToRepair() {
    // Hide all detail pages
    document.getElementById('repair-expense-detail').classList.remove('active');
    document.getElementById('repair-income-detail').classList.remove('active');
    document.getElementById('repair-profit-detail').classList.remove('active');

    // Show repair page
    document.getElementById('repair').classList.add('active');
}

// Show Pawn Income Detail Modal
function showPawnIncomeDetail() {
    const modal = document.getElementById('pawnIncomeDetailModal');

    // 1. ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏à‡∏≤‡∏Å‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å‡∏ï‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏ù‡∏≤‡∏Å - ‡∏£‡∏ß‡∏° active, returned ‡πÅ‡∏•‡∏∞ seized
    const seizedPawns = pawnDetailData.allPawns ? pawnDetailData.allPawns.filter(p => p.status === 'seized') : [];
    const allPawnsForIncome = [...(pawnDetailData.activePawns || []), ...(pawnDetailData.returnedPawns || []), ...seizedPawns];
    const deductedPawns = allPawnsForIncome.filter(p => {
        const method = p.interest_collection_method || p.interestCollectionMethod;
        return method === 'deducted' && p.interest > 0;
    });
    const deductedTotal = deductedPawns.reduce((sum, p) => sum + (p.interest || 0), 0);

    document.getElementById('pawnIncomeDeductedTotal').textContent = formatCurrency(deductedTotal);
    const deductedTableBody = document.getElementById('pawnIncomeDeductedTableBody');
    if (deductedPawns.length === 0) {
        deductedTableBody.innerHTML = '<tr><td colspan="4" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        deductedTableBody.innerHTML = deductedPawns.map(pawn => {
            const receiveDate = formatDate(pawn.receive_date || pawn.receiveDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const interest = pawn.interest || 0;
            let statusBadge = '';
            if (pawn.status === 'returned') statusBadge = ' <span style="color: #4CAF50;">‚úì ‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß</span>';
            else if (pawn.status === 'seized') statusBadge = ' <span style="color: #f44336;">‚ö† ‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á</span>';

            return `
                <tr>
                    <td>${receiveDate}</td>
                    <td>${deviceInfo}${statusBadge}</td>
                    <td>${customerName}</td>
                    <td class="income-text">${formatCurrency(interest)}</td>
                </tr>
            `;
        }).join('');
    }

    // 2. ‡∏¢‡∏≠‡∏î‡πÑ‡∏ñ‡πà‡∏ñ‡∏≠‡∏ô (‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏ô)
    const returnedPawns = pawnDetailData.returnedPawns;
    const returnedTotal = returnedPawns.reduce((sum, p) => sum + (p.redemption_amount || p.redemptionAmount || 0), 0);

    document.getElementById('pawnIncomeReturnedTotal').textContent = formatCurrency(returnedTotal);
    const returnedTableBody = document.getElementById('pawnIncomeReturnedTableBody');
    if (returnedPawns.length === 0) {
        returnedTableBody.innerHTML = '<tr><td colspan="4" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        returnedTableBody.innerHTML = returnedPawns.map(pawn => {
            const returnDate = formatDate(pawn.return_date || pawn.returnDate);
            const deviceInfo = `${pawn.brand} ${pawn.model} (${pawn.color})`;
            const customerName = pawn.customer_name || pawn.customerName;
            const redemption = pawn.redemption_amount || pawn.redemptionAmount || 0;

            return `
                <tr>
                    <td>${returnDate}</td>
                    <td>${deviceInfo}</td>
                    <td>${customerName}</td>
                    <td class="income-text">${formatCurrency(redemption)}</td>
                </tr>
            `;
        }).join('');
    }

    // 3. ‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏î‡∏≠‡∏Å
    const renewalTransactions = pawnDetailData.interestTransactions.filter(t => t.transaction_type === 'renewal');
    const renewalTotal = renewalTransactions.reduce((sum, t) => sum + (parseFloat(t.interest_amount) || 0) + (parseFloat(t.late_fee) || 0), 0);

    document.getElementById('pawnIncomeRenewalTotal').textContent = formatCurrency(renewalTotal);
    const renewalTableBody = document.getElementById('pawnIncomeRenewalTableBody');
    if (renewalTransactions.length === 0) {
        renewalTableBody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    } else {
        renewalTableBody.innerHTML = renewalTransactions.map(transaction => {
            const transactionDate = formatDate(transaction.transaction_date);
            const pawn = pawnDetailData.allPawns.find(p => p.id === transaction.pawn_id);
            const deviceInfo = pawn ? `${pawn.brand} ${pawn.model}` : 'N/A';
            const interest = parseFloat(transaction.interest_amount) || 0;
            const lateFee = parseFloat(transaction.late_fee) || 0;
            const total = interest + lateFee;

            return `
                <tr>
                    <td>${transactionDate}</td>
                    <td>${deviceInfo}</td>
                    <td class="income-text">${formatCurrency(interest)}</td>
                    <td class="income-text">${formatCurrency(lateFee)}</td>
                    <td class="income-text"><strong>${formatCurrency(total)}</strong></td>
                    <td>
                        <button class="btn btn-sm btn-danger" onclick="deleteInterestTransaction(${transaction.id})">‡∏•‡∏ö</button>
                    </td>
                </tr>
            `;
        }).join('');
    }

    // Update total income
    document.getElementById('pawnIncomeDetailTotal').textContent = formatCurrency(pawnDetailData.totalIncome);

    modal.style.display = 'block';
}

function closePawnIncomeDetailModal() {
    document.getElementById('pawnIncomeDetailModal').style.display = 'none';
}

// Show Pawn Profit Detail Modal
function showPawnProfitDetail() {
    const modal = document.getElementById('pawnProfitDetailModal');

    document.getElementById('pawnProfitDetailTotal').textContent = formatCurrency(pawnDetailData.totalProfit);
    document.getElementById('pawnProfitDetailIncome').textContent = formatCurrency(pawnDetailData.totalIncome);
    document.getElementById('pawnProfitDetailExpense').textContent = formatCurrency(pawnDetailData.totalExpense);
    document.getElementById('pawnProfitDetailResult').textContent = formatCurrency(pawnDetailData.totalProfit);

    modal.style.display = 'block';
}

function closePawnProfitDetailModal() {
    document.getElementById('pawnProfitDetailModal').style.display = 'none';
}

// Initialize pawn search
function initializePawnSearch() {
    const searchInput = document.getElementById('searchPawn');
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            filterPawns(searchTerm);
        });
    }
}

// Filter pawns based on search term
function filterPawns(searchTerm) {
    // Active: Show current data always (no date filter)
    let activePawns = pawnDevices.filter(p => p.store === currentStore && p.status === 'active');

    // Apply search filter
    if (searchTerm) {
        activePawns = activePawns.filter(pawn => {
            return pawn.brand.toLowerCase().includes(searchTerm) ||
                   pawn.model.toLowerCase().includes(searchTerm) ||
                   pawn.color.toLowerCase().includes(searchTerm) ||
                   pawn.imei.toLowerCase().includes(searchTerm) ||
                   `${pawn.ram}/${pawn.rom}`.includes(searchTerm);
        });
    }

    displayPawns(activePawns, 'pawnActiveTableBody', 'active');

    // Returned: Filter by date and search
    let returnedPawns = pawnDevices.filter(p => p.store === currentStore && p.status === 'returned');

    // Apply date filter
    if (currentPawnFilter.month || currentPawnFilter.year) {
        returnedPawns = returnedPawns.filter(pawn => {
            const returnDate = pawn.return_date || pawn.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            const pawnMonth = date.getMonth() + 1;
            const pawnYear = date.getFullYear();

            const monthMatch = !currentPawnFilter.month || pawnMonth == currentPawnFilter.month;
            const yearMatch = !currentPawnFilter.year || pawnYear == currentPawnFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        returnedPawns = returnedPawns.filter(pawn => {
            const returnDate = pawn.return_date || pawn.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter
    if (searchTerm) {
        returnedPawns = returnedPawns.filter(pawn => {
            return pawn.brand.toLowerCase().includes(searchTerm) ||
                   pawn.model.toLowerCase().includes(searchTerm) ||
                   pawn.color.toLowerCase().includes(searchTerm) ||
                   pawn.imei.toLowerCase().includes(searchTerm) ||
                   `${pawn.ram}/${pawn.rom}`.includes(searchTerm);
        });
    }

    displayPawns(returnedPawns, 'pawnReturnedTableBody', 'returned');

    // Seized: Filter by date and search
    let seizedPawns = pawnDevices.filter(p => p.store === currentStore && p.status === 'seized');

    // Apply date filter
    if (currentPawnFilter.month || currentPawnFilter.year) {
        seizedPawns = seizedPawns.filter(pawn => {
            const seizedDate = pawn.seized_date || pawn.seizedDate;
            if (!seizedDate) return false;
            const date = new Date(seizedDate);
            const pawnMonth = date.getMonth() + 1;
            const pawnYear = date.getFullYear();

            const monthMatch = !currentPawnFilter.month || pawnMonth == currentPawnFilter.month;
            const yearMatch = !currentPawnFilter.year || pawnYear == currentPawnFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        seizedPawns = seizedPawns.filter(pawn => {
            const seizedDate = pawn.seized_date || pawn.seizedDate;
            if (!seizedDate) return false;
            const date = new Date(seizedDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter
    if (searchTerm) {
        seizedPawns = seizedPawns.filter(pawn => {
            return pawn.brand.toLowerCase().includes(searchTerm) ||
                   pawn.model.toLowerCase().includes(searchTerm) ||
                   pawn.color.toLowerCase().includes(searchTerm) ||
                   pawn.imei.toLowerCase().includes(searchTerm) ||
                   `${pawn.ram}/${pawn.rom}`.includes(searchTerm);
        });
    }

    displayPawns(seizedPawns, 'pawnSeizedTableBody', 'seized');

    // Update tab counts with filtered data
    updatePawnTabCounts({
        active: activePawns,
        returned: returnedPawns,
        seized: seizedPawns
    });
}

// Initialize date filter for pawn
function initializePawnDateFilter() {
    const monthSelect = document.getElementById('filterPawnMonth');
    const yearSelect = document.getElementById('filterPawnYear');

    console.log('üîÑ Initializing Pawn date filter...', { monthSelect, yearSelect });

    if (!monthSelect || !yearSelect) {
        console.error('‚ùå Pawn filter elements not found');
        return;
    }

    // Clear existing options except the first one
    while (monthSelect.options.length > 1) {
        monthSelect.remove(1);
    }
    while (yearSelect.options.length > 1) {
        yearSelect.remove(1);
    }

    // Populate months
    const thaiMonthsShort = ['‡∏°.‡∏Ñ.', '‡∏Å.‡∏û.', '‡∏°‡∏µ.‡∏Ñ.', '‡πÄ‡∏°.‡∏¢.', '‡∏û.‡∏Ñ.', '‡∏°‡∏¥.‡∏¢.', '‡∏Å.‡∏Ñ.', '‡∏™.‡∏Ñ.', '‡∏Å.‡∏¢.', '‡∏ï.‡∏Ñ.', '‡∏û.‡∏¢.', '‡∏ò.‡∏Ñ.'];
    for (let i = 0; i < 12; i++) {
        const option = document.createElement('option');
        option.value = i + 1;
        option.textContent = thaiMonthsShort[i];
        monthSelect.appendChild(option);
    }

    // Populate years - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô ‡∏Ñ.‡∏®.
    const currentYear = new Date().getFullYear(); // ‡∏Ñ.‡∏®. ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    
    console.log(`üìÖ Current year: ${currentYear} (‡∏Ñ.‡∏®.)`);
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏µ: ‡∏õ‡∏µ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô ‡∏ñ‡∏∂‡∏á‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á 3 ‡∏õ‡∏µ (2025, 2024, 2023, 2022)
    for (let year = currentYear; year >= currentYear - 3; year--) {
        const option = document.createElement('option');
        option.value = year; // ‡∏Ñ.‡∏®.
        option.textContent = year; // ‡πÅ‡∏™‡∏î‡∏á ‡∏Ñ.‡∏®.
        yearSelect.appendChild(option);
        
        console.log(`   ‚úÖ Added year: ${year} (‡∏Ñ.‡∏®.)`);
    }

    console.log('‚úÖ Pawn date filter initialized', {
        months: monthSelect.options.length,
        years: yearSelect.options.length
    });
}

// Filter pawn by date
async function filterPawnByDate() {
    const monthSelect = document.getElementById('filterPawnMonth');
    const yearSelect = document.getElementById('filterPawnYear');

    currentPawnFilter.month = monthSelect.value;
    currentPawnFilter.year = yearSelect.value;

    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üîç [filterPawnByDate] START');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìä Dropdown Information:');
    console.log('   ‚Ä¢ Selected Month Index:', monthSelect.selectedIndex);
    console.log('   ‚Ä¢ Selected Month Text:', monthSelect.options[monthSelect.selectedIndex]?.text);
    console.log('   ‚Ä¢ Selected Month Value:', monthSelect.value);
    console.log('   ‚Ä¢ Selected Year Index:', yearSelect.selectedIndex);
    console.log('   ‚Ä¢ Selected Year Text:', yearSelect.options[yearSelect.selectedIndex]?.text);
    console.log('   ‚Ä¢ Selected Year Value:', yearSelect.value);
    console.log('   ‚Ä¢ All Year Options:', Array.from(yearSelect.options).map((opt, i) => ({
        index: i,
        text: opt.text,
        value: opt.value,
        selected: opt.selected
    })));
    console.log('Current Filter:', currentPawnFilter);
    console.log('Current Store:', currentStore);

    // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API
    const allPawns = await API.get(API_ENDPOINTS.pawn, { store: currentStore });
    const allPawnsInStore = allPawns;
    
    console.log(`üì¶ Loaded ${allPawns.length} pawns from API`);
    console.log('Pawns by status:', {
        active: allPawns.filter(p => p.status === 'active').length,
        returned: allPawns.filter(p => p.status === 'returned').length,
        seized: allPawns.filter(p => p.status === 'seized').length
    });

    // Active: Show current data always (no date filter for active)
    const activePawns = allPawnsInStore.filter(p => p.status === 'active');
    displayPawns(activePawns, 'pawnActiveTableBody', 'active');

    // Returned: Filter by return_date
    let returnedPawns = allPawnsInStore.filter(p => p.status === 'returned');

    if (currentPawnFilter.month || currentPawnFilter.year) {
        returnedPawns = returnedPawns.filter(pawn => {
            const returnDate = pawn.return_date || pawn.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            const pawnMonth = date.getMonth() + 1;
            const pawnYear = date.getFullYear();

            const monthMatch = !currentPawnFilter.month || pawnMonth == currentPawnFilter.month;
            const yearMatch = !currentPawnFilter.year || pawnYear == currentPawnFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        returnedPawns = returnedPawns.filter(pawn => {
            const returnDate = pawn.return_date || pawn.returnDate;
            if (!returnDate) return false;
            const date = new Date(returnDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    displayPawns(returnedPawns, 'pawnReturnedTableBody', 'returned');

    console.log(`‚úÖ Filtered Returned: ${returnedPawns.length} pawns`);

    // Seized: Filter by seized_date
    let seizedPawns = allPawnsInStore.filter(p => p.status === 'seized');

    if (currentPawnFilter.month || currentPawnFilter.year) {
        seizedPawns = seizedPawns.filter(pawn => {
            const seizedDate = pawn.seized_date || pawn.seizedDate;
            if (!seizedDate) return false;
            const date = new Date(seizedDate);
            const pawnMonth = date.getMonth() + 1;
            const pawnYear = date.getFullYear();

            const monthMatch = !currentPawnFilter.month || pawnMonth == currentPawnFilter.month;
            const yearMatch = !currentPawnFilter.year || pawnYear == currentPawnFilter.year;

            return monthMatch && yearMatch;
        });
    } else {
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        seizedPawns = seizedPawns.filter(pawn => {
            const seizedDate = pawn.seized_date || pawn.seizedDate;
            if (!seizedDate) return false;
            const date = new Date(seizedDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    displayPawns(seizedPawns, 'pawnSeizedTableBody', 'seized');
    
    console.log(`‚úÖ Filtered Seized: ${seizedPawns.length} pawns`);
    console.log('');
    console.log('üìä Filter Result Summary:');
    console.log(`   ‚Ä¢ Active (no filter): ${activePawns.length}`);
    console.log(`   ‚Ä¢ Returned (filtered): ${returnedPawns.length}`);
    console.log(`   ‚Ä¢ Seized (filtered): ${seizedPawns.length}`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    // Update tab counts with filtered data
    updatePawnTabCounts({
        active: activePawns,
        returned: returnedPawns,
        seized: seizedPawns
    });
    
    // Update dashboard cards with filtered data
    console.log('üîÑ Calling updatePawnDashboard...');
    await updatePawnDashboard(allPawnsInStore);
    console.log('‚úÖ [filterPawnByDate] COMPLETE');
}

// Close pawn modal when clicking outside
window.addEventListener('click', function(event) {
    const pawnModal = document.getElementById('pawnModal');
    if (event.target === pawnModal) {
        closePawnModal();
    }
});

// ===== DATE FILTER FUNCTIONS =====

// Initialize date filter dropdowns for new devices
function initializeNewDevicesDateFilter() {
    const monthSelect = document.getElementById('filterNewDevicesMonth');
    const yearSelect = document.getElementById('filterNewDevicesYear');

    console.log('üîç Initializing New Devices Date Filter...');
    console.log('Month Select Element:', monthSelect);
    console.log('Year Select Element:', yearSelect);

    if (!monthSelect || !yearSelect) {
        console.error('‚ùå filterNewDevicesMonth or filterNewDevicesYear not found!');
        return;
    }

    // Clear existing options except the first one (‡∏ó‡∏∏‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô/‡∏ó‡∏∏‡∏Å‡∏õ‡∏µ)
    while (monthSelect.options.length > 1) {
        monthSelect.remove(1);
    }
    while (yearSelect.options.length > 1) {
        yearSelect.remove(1);
    }

    // Populate months
    const thaiMonthsShort = ['‡∏°.‡∏Ñ.', '‡∏Å.‡∏û.', '‡∏°‡∏µ.‡∏Ñ.', '‡πÄ‡∏°.‡∏¢.', '‡∏û.‡∏Ñ.', '‡∏°‡∏¥.‡∏¢.', '‡∏Å.‡∏Ñ.', '‡∏™.‡∏Ñ.', '‡∏Å.‡∏¢.', '‡∏ï.‡∏Ñ.', '‡∏û.‡∏¢.', '‡∏ò.‡∏Ñ.'];
    for (let i = 0; i < 12; i++) {
        const option = document.createElement('option');
        option.value = i + 1;
        option.textContent = thaiMonthsShort[i];
        monthSelect.appendChild(option);
    }
    console.log('‚úÖ Added', thaiMonthsShort.length, 'months to dropdown');

    // Populate years - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô ‡∏Ñ.‡∏®.
    const currentYear = new Date().getFullYear(); // ‡∏Ñ.‡∏®.
    for (let year = currentYear; year >= currentYear - 3; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearSelect.appendChild(option);
    }
    console.log('‚úÖ Added years from', (currentYear - 3), 'to', currentYear, '(‡∏Ñ.‡∏®.)');
}

// Filter new devices by date range
function filterNewDevicesByDateRange() {
    const startDate = document.getElementById('filterNewDevicesStartDate').value;
    const endDate = document.getElementById('filterNewDevicesEndDate').value;

    currentNewDevicesFilter.startDate = startDate;
    currentNewDevicesFilter.endDate = endDate;

    console.log('üîç Filtering New Devices:', currentNewDevicesFilter);
    applyNewDevicesFilter();
}

// Apply filter to new devices
async function applyNewDevicesFilter() {
    const searchInput = document.getElementById('searchNewDevices');
    const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
    
    console.log('üîç [New Devices Filter] Search term:', searchTerm);

    try {
        // Get devices from API
        const allDevices = await API.get(API_ENDPOINTS.newDevices, { store: currentStore });
        
        console.log('üì¶ [New Devices Filter] Total devices:', allDevices.length);
        
        // Validate data
        if (!Array.isArray(allDevices)) {
            console.warn('API returned invalid data:', allDevices);
            return;
        }

        // Stock: Show current data always (no date filter)
        let stockDevices = allDevices.filter(d => d.status === 'stock');
        
        console.log('üì¶ [New Devices Filter] Stock devices before search:', stockDevices.length);

    // Apply search filter for stock
    if (searchTerm) {
        stockDevices = stockDevices.filter(device => {
            return device.brand.toLowerCase().includes(searchTerm) ||
                   device.model.toLowerCase().includes(searchTerm) ||
                   device.color.toLowerCase().includes(searchTerm) ||
                   device.imei.toLowerCase().includes(searchTerm) ||
                   (device.ram + '/' + device.rom).includes(searchTerm);
        });
        console.log('üîç [New Devices Filter] Stock devices after search:', stockDevices.length);
    }

        // Sold: Filter by saleDate based on selected date range
        let soldDevices = allDevices.filter(d => d.status === 'sold');

    // Apply date range filter for sold devices
    if (currentNewDevicesFilter.startDate || currentNewDevicesFilter.endDate) {
        soldDevices = soldDevices.filter(device => {
            const saleDate = device.sale_date || device.saleDate;
            if (!saleDate) return false;
            
            const date = new Date(saleDate);
            const startMatch = !currentNewDevicesFilter.startDate || date >= new Date(currentNewDevicesFilter.startDate);
            const endMatch = !currentNewDevicesFilter.endDate || date <= new Date(currentNewDevicesFilter.endDate);

            return startMatch && endMatch;
        });
    } else {
        // Show only current month if no filter is applied
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        soldDevices = soldDevices.filter(device => {
            const saleDate = device.sale_date || device.saleDate;
            if (!saleDate) return false;
            const date = new Date(saleDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter for sold
    if (searchTerm) {
        soldDevices = soldDevices.filter(device => {
            return device.brand.toLowerCase().includes(searchTerm) ||
                   device.model.toLowerCase().includes(searchTerm) ||
                   device.color.toLowerCase().includes(searchTerm) ||
                   device.imei.toLowerCase().includes(searchTerm) ||
                   (device.ram + '/' + device.rom).includes(searchTerm);
        });
    }

        // Removed: Filter by saleDate based on selected date range
        let removedDevices = allDevices.filter(d => d.status === 'removed');

    // Apply date range filter for removed devices
    if (currentNewDevicesFilter.startDate || currentNewDevicesFilter.endDate) {
        removedDevices = removedDevices.filter(device => {
            const saleDate = device.sale_date || device.saleDate;
            if (!saleDate) return false;
            
            const date = new Date(saleDate);
            const startMatch = !currentNewDevicesFilter.startDate || date >= new Date(currentNewDevicesFilter.startDate);
            const endMatch = !currentNewDevicesFilter.endDate || date <= new Date(currentNewDevicesFilter.endDate);

            return startMatch && endMatch;
        });
    } else {
        // Show only current month if no filter is applied
        const currentDate = new Date();
        const currentMonth = currentDate.getMonth() + 1;
        const currentYear = currentDate.getFullYear();

        removedDevices = removedDevices.filter(device => {
            const saleDate = device.sale_date || device.saleDate;
            if (!saleDate) return false;
            const date = new Date(saleDate);
            return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
        });
    }

    // Apply search filter for removed
    if (searchTerm) {
        removedDevices = removedDevices.filter(device => {
            return device.brand.toLowerCase().includes(searchTerm) ||
                   device.model.toLowerCase().includes(searchTerm) ||
                   device.color.toLowerCase().includes(searchTerm) ||
                   device.imei.toLowerCase().includes(searchTerm) ||
                   (device.ram + '/' + device.rom).includes(searchTerm);
        });
    }

        // Sort by import date (latest first)
        stockDevices.sort((a, b) => {
            const dateA = new Date(a.import_date || a.importDate);
            const dateB = new Date(b.import_date || b.importDate);
            return dateB - dateA; // Latest first
        });

        soldDevices.sort((a, b) => {
            const dateA = new Date(a.sale_date || a.saleDate);
            const dateB = new Date(b.sale_date || b.saleDate);
            return dateB - dateA; // Latest first
        });

        removedDevices.sort((a, b) => {
            const dateA = new Date(a.sale_date || a.saleDate);
            const dateB = new Date(b.sale_date || b.saleDate);
            return dateB - dateA; // Latest first
        });

        // Display filtered results
        displayDevices(stockDevices, 'stockTableBody', 'stock');
        displayDevices(soldDevices, 'soldTableBody', 'sold');
        displayDevices(removedDevices, 'removedTableBody', 'removed');

        // Update tab counts
        const stockCountElement = document.getElementById('newStockCount');
        const soldCountElement = document.getElementById('newSoldCount');
        const removedCountElement = document.getElementById('newRemovedCount');

        if (stockCountElement) stockCountElement.textContent = stockDevices.length;
        if (soldCountElement) soldCountElement.textContent = soldDevices.length;
        if (removedCountElement) removedCountElement.textContent = removedDevices.length;

        // Update Dashboard Cards
        const stockCount = document.getElementById('newDevicesStockCount');
        const expense = document.getElementById('newDevicesExpense');
        const income = document.getElementById('newDevicesIncome');
        const profit = document.getElementById('newDevicesProfit');

        if (stockCount) stockCount.textContent = stockDevices.length;

        // Calculate expense (total purchase price of ALL devices imported in the selected date range)
        // Filter all devices by import_date for the current/selected date range
        let expenseDevices = allDevices;
        
        if (currentNewDevicesFilter.startDate || currentNewDevicesFilter.endDate) {
            // Use date range filter
            expenseDevices = allDevices.filter(device => {
                const importDate = new Date(device.import_date || device.importDate);
                const startMatch = !currentNewDevicesFilter.startDate || importDate >= new Date(currentNewDevicesFilter.startDate);
                const endMatch = !currentNewDevicesFilter.endDate || importDate <= new Date(currentNewDevicesFilter.endDate);
                
                return startMatch && endMatch;
            });
        } else {
            // Use current month/year
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();
            
            expenseDevices = allDevices.filter(device => {
                const importDate = new Date(device.import_date || device.importDate);
                const deviceMonth = importDate.getMonth() + 1;
                const deviceYear = importDate.getFullYear();
                
                return deviceMonth === currentMonth && deviceYear === currentYear;
            });
        }
        
        const totalExpense = expenseDevices.reduce((sum, device) => {
            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
            return sum + purchasePrice;
        }, 0);
        
        if (expense) expense.textContent = formatCurrency(totalExpense);

        // Calculate income (total sale price of sold devices)
        const totalIncome = soldDevices.reduce((sum, device) => {
            const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
            return sum + salePrice;
        }, 0);
        
        if (income) income.textContent = formatCurrency(totalIncome);

        // Calculate profit (income - expense for sold devices)
        const soldDevicesExpense = soldDevices.reduce((sum, device) => {
            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
            return sum + purchasePrice;
        }, 0);
        const totalProfit = totalIncome - soldDevicesExpense;
        
        if (profit) profit.textContent = formatCurrency(totalProfit);

    } catch (error) {
        console.error('Error loading new devices:', error);
        console.error('Error details:', error.message);
        // Display empty tables instead of alert
        displayDevices([], 'stockTableBody', 'stock');
        displayDevices([], 'soldTableBody', 'sold');
        displayDevices([], 'removedTableBody', 'removed');
    }
}

// Clear new devices filter
function clearNewDevicesFilter() {
    const startDateInput = document.getElementById('filterNewDevicesStartDate');
    const endDateInput = document.getElementById('filterNewDevicesEndDate');
    const searchInput = document.getElementById('searchNewDevices');
    
    if (startDateInput) startDateInput.value = '';
    if (endDateInput) endDateInput.value = '';
    if (searchInput) searchInput.value = '';
    
    currentNewDevicesFilter = { startDate: '', endDate: '' };
    applyNewDevicesFilter();
}

// Initialize date filter dropdowns for used devices
function initializeUsedDevicesDateFilter() {
    const monthSelect = document.getElementById('filterUsedDevicesMonth');
    const yearSelect = document.getElementById('filterUsedDevicesYear');

    if (!monthSelect || !yearSelect) return;

    // Clear existing options except the first one (‡∏ó‡∏∏‡∏Å‡πÄ‡∏î‡∏∑‡∏≠‡∏ô/‡∏ó‡∏∏‡∏Å‡∏õ‡∏µ)
    while (monthSelect.options.length > 1) {
        monthSelect.remove(1);
    }
    while (yearSelect.options.length > 1) {
        yearSelect.remove(1);
    }

    // Populate months
    const thaiMonthsShort = ['‡∏°.‡∏Ñ.', '‡∏Å.‡∏û.', '‡∏°‡∏µ.‡∏Ñ.', '‡πÄ‡∏°.‡∏¢.', '‡∏û.‡∏Ñ.', '‡∏°‡∏¥.‡∏¢.', '‡∏Å.‡∏Ñ.', '‡∏™.‡∏Ñ.', '‡∏Å.‡∏¢.', '‡∏ï.‡∏Ñ.', '‡∏û.‡∏¢.', '‡∏ò.‡∏Ñ.'];
    for (let i = 0; i < 12; i++) {
        const option = document.createElement('option');
        option.value = i + 1;
        option.textContent = thaiMonthsShort[i];
        monthSelect.appendChild(option);
    }

    // Populate years - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô ‡∏Ñ.‡∏®.
    const currentYear = new Date().getFullYear(); // ‡∏Ñ.‡∏®.
    for (let year = currentYear; year >= currentYear - 3; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        yearSelect.appendChild(option);
    }
}

// Filter used devices by date
function filterUsedDevicesByDateRange() {
    const startDate = document.getElementById('filterUsedDevicesStartDate').value;
    const endDate = document.getElementById('filterUsedDevicesEndDate').value;

    currentUsedDevicesFilter.startDate = startDate;
    currentUsedDevicesFilter.endDate = endDate;

    console.log('üîç Filtering Used Devices:', currentUsedDevicesFilter);
    applyUsedDevicesFilter();
}

// Apply filter to used devices
async function applyUsedDevicesFilter() {
    const searchTerm = document.getElementById('searchUsedDevices').value.toLowerCase();

    try {
        // Get devices from API
        const allDevices = await API.get(API_ENDPOINTS.usedDevices, { store: currentStore });
        
        // Validate data
        if (!Array.isArray(allDevices)) {
            console.warn('API returned invalid data:', allDevices);
            return;
        }

        // Stock: Show current data always (no date filter)
        let stockDevices = allDevices.filter(d => d.status === 'stock');

        // Apply search filter for stock
        if (searchTerm) {
            stockDevices = stockDevices.filter(device => {
                const condition = device.device_condition || device.deviceCondition || device.condition || '';
                return device.brand.toLowerCase().includes(searchTerm) ||
                       device.model.toLowerCase().includes(searchTerm) ||
                       device.color.toLowerCase().includes(searchTerm) ||
                       device.imei.toLowerCase().includes(searchTerm) ||
                       condition.toLowerCase().includes(searchTerm) ||
                       (device.ram + '/' + device.rom).includes(searchTerm);
            });
        }

        // Sold: Filter by saleDate based on selected month/year
        let soldDevices = allDevices.filter(d => d.status === 'sold');

        // Apply date range filter for sold devices
        if (currentUsedDevicesFilter.startDate || currentUsedDevicesFilter.endDate) {
            soldDevices = soldDevices.filter(device => {
                const saleDate = device.sale_date || device.saleDate;
                if (!saleDate) return false;
                
                const date = new Date(saleDate);
                const startMatch = !currentUsedDevicesFilter.startDate || date >= new Date(currentUsedDevicesFilter.startDate);
                const endMatch = !currentUsedDevicesFilter.endDate || date <= new Date(currentUsedDevicesFilter.endDate);

                return startMatch && endMatch;
            });
        } else {
            // Show only current month if no filter is applied
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();

            soldDevices = soldDevices.filter(device => {
                const saleDate = device.sale_date || device.saleDate;
                if (!saleDate) return false;
                const date = new Date(saleDate);
                return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
            });
        }

        // Apply search filter for sold
        if (searchTerm) {
            soldDevices = soldDevices.filter(device => {
                const condition = device.device_condition || device.deviceCondition || device.condition || '';
                return device.brand.toLowerCase().includes(searchTerm) ||
                       device.model.toLowerCase().includes(searchTerm) ||
                       device.color.toLowerCase().includes(searchTerm) ||
                       device.imei.toLowerCase().includes(searchTerm) ||
                       condition.toLowerCase().includes(searchTerm) ||
                       (device.ram + '/' + device.rom).includes(searchTerm);
            });
        }

        // Removed: Filter by saleDate based on selected month/year
        let removedDevices = allDevices.filter(d => d.status === 'removed');

        // Apply date range filter for removed devices
        if (currentUsedDevicesFilter.startDate || currentUsedDevicesFilter.endDate) {
            removedDevices = removedDevices.filter(device => {
                const saleDate = device.sale_date || device.saleDate;
                if (!saleDate) return false;
                
                const date = new Date(saleDate);
                const startMatch = !currentUsedDevicesFilter.startDate || date >= new Date(currentUsedDevicesFilter.startDate);
                const endMatch = !currentUsedDevicesFilter.endDate || date <= new Date(currentUsedDevicesFilter.endDate);

                return startMatch && endMatch;
            });
        } else {
            // Show only current month if no filter is applied
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();

            removedDevices = removedDevices.filter(device => {
                const saleDate = device.sale_date || device.saleDate;
                if (!saleDate) return false;
                const date = new Date(saleDate);
                return date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;
            });
        }

        // Apply search filter for removed
        if (searchTerm) {
            removedDevices = removedDevices.filter(device => {
                const condition = device.device_condition || device.deviceCondition || device.condition || '';
                return device.brand.toLowerCase().includes(searchTerm) ||
                       device.model.toLowerCase().includes(searchTerm) ||
                       device.color.toLowerCase().includes(searchTerm) ||
                       device.imei.toLowerCase().includes(searchTerm) ||
                       condition.toLowerCase().includes(searchTerm) ||
                       (device.ram + '/' + device.rom).includes(searchTerm);
            });
        }

        // Sort by import_date (newest first) - ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ã‡∏∑‡πâ‡∏≠‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÑ‡∏ß‡πâ‡∏ö‡∏ô‡∏™‡∏∏‡∏î
        stockDevices.sort((a, b) => {
            const dateA = new Date(a.import_date || a.purchase_date || a.purchaseDate || 0);
            const dateB = new Date(b.import_date || b.purchase_date || b.purchaseDate || 0);
            return dateB - dateA; // Descending order (newest first)
        });

        soldDevices.sort((a, b) => {
            const dateA = new Date(a.sale_date || a.saleDate || 0);
            const dateB = new Date(b.sale_date || b.saleDate || 0);
            return dateB - dateA; // Descending order (newest first)
        });

        removedDevices.sort((a, b) => {
            const dateA = new Date(a.sale_date || a.saleDate || 0);
            const dateB = new Date(b.sale_date || b.saleDate || 0);
            return dateB - dateA; // Descending order (newest first)
        });

        // Display filtered results
        displayUsedDevices(stockDevices, 'usedStockTableBody', 'stock');
        displayUsedDevices(soldDevices, 'usedSoldTableBody', 'sold');
        displayUsedDevices(removedDevices, 'usedRemovedTableBody', 'removed');

        // Update tab counts
        const stockCountElement = document.getElementById('usedStockCount');
        const soldCountElement = document.getElementById('usedSoldCount');
        const removedCountElement = document.getElementById('usedRemovedCount');

        if (stockCountElement) stockCountElement.textContent = stockDevices.length;
        if (soldCountElement) soldCountElement.textContent = soldDevices.length;
        if (removedCountElement) removedCountElement.textContent = removedDevices.length;

        // Update dashboard cards for used devices page
        const usedStockCountElement = document.getElementById('usedDevicesStockCount');
        const usedExpenseElement = document.getElementById('usedDevicesExpense');
        const usedIncomeElement = document.getElementById('usedDevicesIncome');
        const usedProfitElement = document.getElementById('usedDevicesProfit');

        if (usedStockCountElement) {
            usedStockCountElement.textContent = stockDevices.length;
        }

        // Calculate expense (total purchase price of ALL purchased devices - ‡∏ô‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏ã‡∏∑‡πâ‡∏≠‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏±‡πâ‡∏ô)
        // Filter ALL devices by purchase_date for the current/selected date range
        let expenseDevices = allDevices; // ‡∏ô‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á status

        console.log('üîç [Used Devices Page] Calculating Expense:', {
            totalDevices: allDevices.length,
            hasFilter: !!(currentUsedDevicesFilter.startDate || currentUsedDevicesFilter.endDate)
        });

        if (currentUsedDevicesFilter.startDate || currentUsedDevicesFilter.endDate) {
            // Use date range filter - ‡∏£‡∏±‡∏ö‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤
            expenseDevices = allDevices.filter(device => {
                const importDate = new Date(device.import_date || device.importDate || device.purchase_date || device.purchaseDate);
                const startMatch = !currentUsedDevicesFilter.startDate || importDate >= new Date(currentUsedDevicesFilter.startDate);
                const endMatch = !currentUsedDevicesFilter.endDate || importDate <= new Date(currentUsedDevicesFilter.endDate);
                const match = startMatch && endMatch;
                
                if (match) {
                    console.log(`  ‚úÖ ${device.brand} ${device.model}: date=${device.purchase_date || device.purchaseDate}, price=${device.purchase_price || device.purchasePrice}, status=${device.status}`);
                }

                return match;
            });
        } else {
            // Use current month/year - ‡∏£‡∏±‡∏ö‡∏ã‡∏∑‡πâ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth() + 1;
            const currentYear = currentDate.getFullYear();

            console.log(`  Filtering for: ${currentMonth}/${currentYear}`);

            expenseDevices = allDevices.filter(device => {
                const purchaseDate = device.purchase_date || device.purchaseDate || device.import_date || device.importDate;
                const importDate = new Date(purchaseDate);
                const deviceMonth = importDate.getMonth() + 1;
                const deviceYear = importDate.getFullYear();
                const match = deviceMonth === currentMonth && deviceYear === currentYear;

                console.log(`  ${match ? '‚úÖ' : '‚ùå'} ${device.brand} ${device.model}: date=${purchaseDate}, ${deviceMonth}/${deviceYear}, price=${device.purchase_price || device.purchasePrice}, status=${device.status}`);

                return match;
            });
        }

        const totalExpense = expenseDevices.reduce((sum, device) => {
            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
            return sum + purchasePrice;
        }, 0);

        console.log('üí∞ [Used Devices Page] Total Expense:', {
            count: expenseDevices.length,
            totalExpense: totalExpense
        });

        // Calculate income (total sale price of sold devices)
        const totalIncome = soldDevices.reduce((sum, device) => {
            const salePrice = parseFloat(device.sale_price || device.salePrice || 0);
            return sum + salePrice;
        }, 0);

        // Calculate profit (income - expense for sold devices)
        const soldDevicesExpense = soldDevices.reduce((sum, device) => {
            const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
            return sum + purchasePrice;
        }, 0);
        const totalProfit = totalIncome - soldDevicesExpense;

        if (usedExpenseElement) {
            usedExpenseElement.textContent = formatCurrency(totalExpense);
        }
        if (usedIncomeElement) {
            usedIncomeElement.textContent = formatCurrency(totalIncome);
        }
        if (usedProfitElement) {
            usedProfitElement.textContent = formatCurrency(totalProfit);
        }
    } catch (error) {
        console.error('Error loading used devices:', error);
        console.error('Error details:', error.message);
        // Display empty tables instead of alert
        displayUsedDevices([], 'usedStockTableBody', 'stock');
        displayUsedDevices([], 'usedSoldTableBody', 'sold');
        displayUsedDevices([], 'usedRemovedTableBody', 'removed');
    }
}

// Clear used devices filter
function clearUsedDevicesFilter() {
    const startDateInput = document.getElementById('filterUsedDevicesStartDate');
    const endDateInput = document.getElementById('filterUsedDevicesEndDate');
    const searchInput = document.getElementById('searchUsedDevices');
    
    if (startDateInput) startDateInput.value = '';
    if (endDateInput) endDateInput.value = '';
    if (searchInput) searchInput.value = '';
    
    currentUsedDevicesFilter = { startDate: '', endDate: '' };
    applyUsedDevicesFilter();
}

// Update store toggle buttons active state
function updateStoreToggleButtons() {
    // Update new devices page buttons
    const newDevicesPage = document.getElementById('new-devices');
    if (newDevicesPage) {
        const buttons = newDevicesPage.querySelectorAll('.store-btn');
        buttons.forEach(btn => {
            if (btn.dataset.store === currentStore) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }

    // Update used devices page buttons
    const usedDevicesPage = document.getElementById('used-devices');
    if (usedDevicesPage) {
        const buttons = usedDevicesPage.querySelectorAll('.store-btn');
        buttons.forEach(btn => {
            if (btn.dataset.store === currentStore) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }
}

// Initialize new devices page
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Application starting...');

    initializeNewDevicesDatabase();
    initializeUsedDevicesDatabase();
    initializeRepairDatabase();
    initializeInstallmentDatabase();
    // initializePawnDatabase(); // Disabled - now using MySQL API instead of localStorage
    initializeTabs();
    initializeUsedTabs();
    initializeRepairTabs();
    initializeInstallmentTabs();
    initializePawnTabs();
    loadNewDevicesData();
    loadUsedDevicesData();
    loadRepairData();
    loadInstallmentData();
    loadPawnData();
    loadAccessoriesData();
    loadEquipmentData(); // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
    initializeSearch();
    initializeUsedSearch();
    initializeRepairSearch();
    initializeInstallmentSearch();
    initializePawnSearch();

    console.log('üîß Initializing date filters...');
    setTimeout(() => {
        // Removed old month/year dropdown initializers - now using date range inputs
        // initializeNewDevicesDateFilter();
        // initializeUsedDevicesDateFilter();
    initializeRepairDateFilter();
    initializeInstallmentDateFilter();
        // initializePawnDateFilter();
    initializeAccessoryDateFilter();
        // initializeEquipmentDateFilter();
        console.log('‚úÖ Date filters initialized (date range inputs)');
    }, 500); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ß‡∏•‡∏≤ delay ‡πÄ‡∏õ‡πá‡∏ô 500ms

    updateStoreToggleButtons();
    initializeExpenseMonthSelector();
    loadExpenseData();
    initializeExpenseCardClicks();

    console.log('‚úÖ Application loaded successfully');
});

// Close modal when clicking outside of it
window.onclick = function(event) {
    // Return Pawn Modal
    const returnPawnModal = document.getElementById('returnPawnModal');
    if (event.target === returnPawnModal) {
        closeReturnPawnModal();
    }

    // Used Devices Expense Detail Modal
    const usedDevicesExpenseDetailModal = document.getElementById('usedDevicesExpenseDetailModal');
    if (event.target === usedDevicesExpenseDetailModal) {
        closeUsedDevicesExpenseDetailModal();
    }

    // Used Devices Income Detail Modal
    const usedDevicesIncomeDetailModal = document.getElementById('usedDevicesIncomeDetailModal');
    if (event.target === usedDevicesIncomeDetailModal) {
        closeUsedDevicesIncomeDetailModal();
    }

    // Used Devices Profit Detail Modal
    const usedDevicesProfitDetailModal = document.getElementById('usedDevicesProfitDetailModal');
    if (event.target === usedDevicesProfitDetailModal) {
        closeUsedDevicesProfitDetailModal();
    }

    // New Devices Expense Detail Modal
    const newDevicesExpenseDetailModal = document.getElementById('newDevicesExpenseDetailModal');
    if (event.target === newDevicesExpenseDetailModal) {
        closeNewDevicesExpenseDetailModal();
    }

    // New Devices Income Detail Modal
    const newDevicesIncomeDetailModal = document.getElementById('newDevicesIncomeDetailModal');
    if (event.target === newDevicesIncomeDetailModal) {
        closeNewDevicesIncomeDetailModal();
    }

    // New Devices Profit Detail Modal
    const newDevicesProfitDetailModal = document.getElementById('newDevicesProfitDetailModal');
    if (event.target === newDevicesProfitDetailModal) {
        closeNewDevicesProfitDetailModal();
    }

    // Other existing modals can be handled here as needed
};

// Tab switching functionality
function initializeTabs() {
    const tabButtons = document.querySelectorAll('.tab-btn');

    tabButtons.forEach(button => {
        button.addEventListener('click', function() {
            const tabName = this.getAttribute('data-tab');

            // Skip if button has onclick attribute (handled by specific function)
            if (this.hasAttribute('onclick')) {
                return;
            }

            // Remove active class from all tabs and contents
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to clicked tab and corresponding content
            this.classList.add('active');
            const tabContent = document.getElementById(tabName + '-tab');
            if (tabContent) {
                tabContent.classList.add('active');
            }
        });
    });
}

// Toggle RAM required based on brand (Apple = optional, others = required)
function toggleRamRequired() {
    const brandInput = document.getElementById('brand');
    const ramSelect = document.getElementById('ram');
    const ramLabel = document.querySelector('label[for="ram"]');
    
    if (brandInput && ramSelect && ramLabel) {
        const brand = brandInput.value.trim().toLowerCase();
        const isApple = brand === 'apple';
        
        if (isApple) {
            // Apple: RAM is optional
            ramSelect.removeAttribute('required');
            const requiredSpan = ramLabel.querySelector('.required');
            if (requiredSpan) {
                requiredSpan.style.display = 'none';
            }
        } else {
            // Other brands: RAM is required
            ramSelect.setAttribute('required', 'required');
            const requiredSpan = ramLabel.querySelector('.required');
            if (requiredSpan) {
                requiredSpan.style.display = 'inline';
            }
        }
    }
}

// Open new device modal
function openNewDeviceModal(deviceId = null) {
    const modal = document.getElementById('newDeviceModal');
    const modalTitle = document.getElementById('modalTitle');
    const form = document.getElementById('newDeviceForm');

    // Reset form
    form.reset();
    currentEditId = deviceId;

    if (deviceId) {
        // Edit mode
        modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà';

        API.get(`${API_ENDPOINTS.newDevices}/${deviceId}`).then(device => {
            document.getElementById('deviceId').value = device.id;
            document.getElementById('brand').value = device.brand;
            document.getElementById('model').value = device.model;
            document.getElementById('color').value = device.color;
            document.getElementById('imei').value = device.imei;
            document.getElementById('ram').value = device.ram;
            document.getElementById('rom').value = device.rom;
            document.getElementById('purchasedFrom').value = device.purchased_from || '';
            document.getElementById('deviceCategory').value = device.device_category || 'No Active';
            document.getElementById('purchasePrice').value = device.purchase_price || device.purchasePrice;
            document.getElementById('importDate').value = device.import_date || device.importDate;
            document.getElementById('salePrice').value = device.sale_price || device.salePrice;
            document.getElementById('saleDate').value = device.sale_date || device.saleDate || '';
            document.getElementById('status').value = device.status;
            document.getElementById('note').value = device.note || '';

            toggleSaleDateField();
            toggleRamRequired(); // Check brand and toggle RAM requirement
        }).catch(error => {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
            console.error(error);
        });
    } else {
        // Add mode
        modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà';
        // Set default import date to today
        document.getElementById('importDate').value = new Date().toISOString().split('T')[0];
        toggleRamRequired(); // Initialize RAM requirement check
    }

    modal.classList.add('show');
}

// Close modal
function closeNewDeviceModal() {
    const modal = document.getElementById('newDeviceModal');
    modal.classList.remove('show');
    currentEditId = null;
}

// Toggle sale date field based on status
function toggleSaleDateField() {
    const status = document.getElementById('status').value;
    const saleDateGroup = document.querySelector('label[for="saleDate"]').parentElement;
    const noteGroup = document.getElementById('noteGroup');

    if (status === 'sold') {
        saleDateGroup.style.display = 'flex';
        noteGroup.style.display = 'none';
    } else if (status === 'removed') {
        saleDateGroup.style.display = 'none';
        noteGroup.style.display = 'flex';
    } else {
        saleDateGroup.style.display = 'none';
        noteGroup.style.display = 'none';
    }
}

// Save new device
async function saveNewDevice(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const deviceData = {
        brand: formData.get('brand'),
        model: formData.get('model'),
        color: formData.get('color'),
        imei: formData.get('imei'),
        ram: formData.get('ram'),
        rom: formData.get('rom'),
        purchased_from: formData.get('purchasedFrom') || '',
        device_category: formData.get('deviceCategory') || 'No Active',
        purchase_price: parseFloat(formData.get('purchasePrice')),
        import_date: formData.get('importDate'),
        sale_price: parseFloat(formData.get('salePrice')),
        sale_date: formData.get('saleDate') || null,
        status: formData.get('status'),
        note: formData.get('note') || '',
        store: currentStore
    };

    // üõ°Ô∏è ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏•‡∏∞‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
    if (deviceData.status === 'sold' && deviceData.note) {
        const hasConflict = deviceData.note.includes('‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö') || 
                           deviceData.note.includes('‡πÇ‡∏≠‡∏ô') || 
                           deviceData.note.includes('‡∏¢‡πâ‡∏≤‡∏¢');
        
        if (hasConflict) {
            await customAlert({
                title: '‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ\n\n' +
                        '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á:\n' +
                        '‚Ä¢ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ "‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß" (sold) - ‡∏ñ‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ñ‡∏π‡∏Å‡∏Ç‡∏≤‡∏¢‡∏à‡∏£‡∏¥‡∏á\n' +
                        '‚Ä¢ ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ "‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å" (removed) + ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏ "‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö/‡πÇ‡∏≠‡∏ô" - ‡∏ñ‡πâ‡∏≤‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÇ‡∏≠‡∏ô‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô',
                icon: 'error'
            });
            return; // ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
        }
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ removed ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏Ç‡∏≤‡∏¢
    if (deviceData.status === 'removed' && deviceData.note) {
        const hasConflict = deviceData.note.includes('‡∏Ç‡∏≤‡∏¢') || deviceData.note.includes('sold');
        
        if (hasConflict) {
            await customAlert({
                title: '‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
                icon: 'error'
            });
            return; // ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
        }
    }

    try {
        if (currentEditId) {
            // Update existing device
            await API.put(`${API_ENDPOINTS.newDevices}/${currentEditId}`, deviceData);
            showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } else {
            // Add new device
            deviceData.id = Date.now().toString();
            await API.post(API_ENDPOINTS.newDevices, deviceData);
            showNotification('‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }

        // Reload data
        loadNewDevicesData();

        // Close modal
        closeNewDeviceModal();
    } catch (error) {
        console.error('Error saving device:', error);

        // Check if it's a duplicate IMEI error
        if (error.duplicate || (error.message && error.message.includes('IMEI'))) {
            await customAlert({
                title: '‚ùå IMEI ‡∏ã‡πâ‡∏≥',
                message: `IMEI "${deviceData.imei}" ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö IMEI ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà`,
                icon: 'error'
            });
        } 
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á
        else if (error.conflict || (error.message && error.message.includes('‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á'))) {
            await customAlert({
                title: '‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á',
                message: error.message || '‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å',
                icon: 'error'
            });
        }
        else {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
                icon: 'error'
            });
        }
    }
}

// Load and display new devices data
function loadNewDevicesData() {
    // Apply current filter (which will show current month by default)
    applyNewDevicesFilter();

    // Update dashboard stats
    updateDashboard();
}

// Display devices in table
function displayDevices(devices, tableBodyId, type) {
    const tbody = document.getElementById(tableBodyId);

    if (!tbody) return;

    if (devices.length === 0) {
        const colspan = type === 'stock' ? '9' : (type === 'sold' ? '11' : '10');
        tbody.innerHTML = `<tr><td colspan="${colspan}" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>`;
        return;
    }

    tbody.innerHTML = devices.map(device => {
        const purchasePrice = device.purchase_price || device.purchasePrice;
        const salePrice = device.sale_price || device.salePrice;
        const importDate = device.import_date || device.importDate;
        const saleDate = device.sale_date || device.saleDate;

        if (type === 'stock') {
            return `
                <tr>
                    <td style="width: 8%;">${device.brand}</td>
                    <td style="width: 10%;">${device.model}</td>
                    <td style="width: 6%;">${device.color}</td>
                    <td style="width: 9%;">${device.imei}</td>
                    <td style="width: 9%;">${device.ram}/${device.rom} GB</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(purchasePrice)}</td>
                    <td style="width: 10%; text-align: center;">${formatDate(importDate)}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 32%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="device-action-select" id="new-action-${device.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="sell">‡∏Ç‡∏≤‡∏¢</option>
                                <option value="installment">‡∏ú‡πà‡∏≠‡∏ô</option>
                                <option value="remove">‡∏ï‡∏±‡∏î</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeNewDeviceAction('${device.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else if (type === 'sold') {
            const profit = salePrice - purchasePrice;
            const profitColor = profit >= 0 ? '#10b981' : '#ef4444';
            const note = device.note || '-';
            return `
                <tr>
                    <td style="width: 7%;">${device.brand}</td>
                    <td style="width: 9%;">${device.model}</td>
                    <td style="width: 5%;">${device.color}</td>
                    <td style="width: 8%;">${device.imei}</td>
                    <td style="width: 8%;">${device.ram}/${device.rom} GB</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(purchasePrice)}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 9%; text-align: center;">${formatDate(saleDate)}</td>
                    <td style="width: 8%; text-align: right; color: ${profitColor}; font-weight: 600;">${formatCurrency(profit)}</td>
                    <td style="width: 10%;">${note}</td>
                    <td style="width: 20%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="device-action-select" id="new-action-${device.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="back-stock">‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeNewDeviceAction('${device.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        } else {
            // Removed tab - ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏Å‡∏≥‡πÑ‡∏£/‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
            const profit = salePrice - purchasePrice;
            const profitColor = profit >= 0 ? '#10b981' : '#ef4444';
            return `
                <tr>
                    <td style="width: 7%;">${device.brand}</td>
                    <td style="width: 9%;">${device.model}</td>
                    <td style="width: 5%;">${device.color}</td>
                    <td style="width: 8%;">${device.imei}</td>
                    <td style="width: 8%;">${device.ram}/${device.rom} GB</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(purchasePrice)}</td>
                    <td style="width: 8%; text-align: right;">${formatCurrency(salePrice)}</td>
                    <td style="width: 9%; text-align: center;">${formatDate(saleDate)}</td>
                    <td style="width: 8%; text-align: right; color: ${profitColor}; font-weight: 600;">${formatCurrency(profit)}</td>
                    <td style="width: 10%;">${device.note || '-'}</td>
                    <td style="width: 20%; text-align: center;">
                        <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                            <select class="device-action-select" id="new-action-${device.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                                <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                                <option value="view">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</option>
                                <option value="back-stock">‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ</option>
                                <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                                <option value="delete">‡∏•‡∏ö</option>
                            </select>
                            <button class="action-btn btn-primary" onclick="executeNewDeviceAction('${device.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                        </div>
                    </td>
                </tr>
            `;
        }
    }).join('');
}

// Execute new device action from dropdown
async function executeNewDeviceAction(deviceId) {
    const selectElement = document.getElementById(`new-action-${deviceId}`);
    const action = selectElement.value;

    if (!action) {
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'view':
            await viewNewDeviceDetail(deviceId);
            break;
        case 'sell':
            await markAsSold(deviceId);
            break;
        case 'installment':
            await transferToInstallment(deviceId);
            break;
        case 'remove':
            await markAsRemoved(deviceId);
            break;
        case 'back-stock':
            await moveBackToStock(deviceId);
            break;
        case 'edit':
            await openNewDeviceModal(deviceId);
            break;
        case 'delete':
            await deleteDevice(deviceId);
            break;
        default:
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å',
                icon: 'error'
            });
    }

    // Reset select after action
    selectElement.value = '';
}

// Mark device as sold - Open confirmation modal
async function markAsSold(deviceId) {
    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
        const device = await API.get(`${API_ENDPOINTS.newDevices}/${deviceId}`);
        if (!device) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
                icon: 'error',
                confirmType: 'danger'
            });
            return;
        }

        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ
        window.currentSaleDevice = device;

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Modal
        const deviceInfo = `${device.brand} ${device.model} (${device.color})`;
        const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
        const originalSalePrice = parseFloat(device.sale_price || device.salePrice || 0);

        document.getElementById('saleDeviceInfo').textContent = deviceInfo;
        document.getElementById('salePurchasePrice').textContent = formatCurrency(purchasePrice);
        document.getElementById('saleOriginalPrice').textContent = formatCurrency(originalSalePrice);
        document.getElementById('actualSalePrice').value = originalSalePrice;
        document.getElementById('saleDeviceId').value = deviceId;
        
        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('saleDateInput').value = today;

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        updateSaleProfit(originalSalePrice, purchasePrice);

        // ‡πÄ‡∏û‡∏¥‡πà‡∏° event listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≥‡πÑ‡∏£‡πÅ‡∏ö‡∏ö real-time
        const priceInput = document.getElementById('actualSalePrice');
        priceInput.oninput = function() {
            const salePrice = parseFloat(this.value) || 0;
            updateSaleProfit(salePrice, purchasePrice);
        };

        // ‡πÅ‡∏™‡∏î‡∏á Modal
        document.getElementById('confirmSalePriceModal').style.display = 'block';

    } catch (error) {
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
        console.error(error);
    }
}

// Update sale profit display
function updateSaleProfit(salePrice, purchasePrice) {
    const profit = salePrice - purchasePrice;
    const profitPercent = purchasePrice > 0 ? ((profit / purchasePrice) * 100).toFixed(2) : 0;

    const profitElement = document.getElementById('saleProfit');
    const percentElement = document.getElementById('saleProfitPercent');

    profitElement.textContent = formatCurrency(profit);
    percentElement.textContent = `${profitPercent}%`;

    // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏Å‡∏≥‡πÑ‡∏£/‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô
    if (profit > 0) {
        profitElement.className = 'profit-value profit-text';
        percentElement.style.color = '#4CAF50';
    } else if (profit < 0) {
        profitElement.className = 'profit-value expense-text';
        percentElement.style.color = '#f44336';
    } else {
        profitElement.className = 'profit-value';
        percentElement.style.color = '#666';
    }
}

// Close sale price confirmation modal
function closeConfirmSalePriceModal() {
    document.getElementById('confirmSalePriceModal').style.display = 'none';
    document.getElementById('confirmSalePriceForm').reset();
    window.currentSaleDevice = null;
}

// Confirm and save sale price
async function confirmSalePrice(event) {
    event.preventDefault();

    const deviceId = document.getElementById('saleDeviceId').value;
    const salePrice = parseFloat(document.getElementById('actualSalePrice').value);
    const saleDate = document.getElementById('saleDateInput').value; // ‡∏≠‡πà‡∏≤‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å input
    const deviceType = window.currentSaleDeviceType || 'new'; // ‡∏î‡∏π‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á

    if (isNaN(salePrice) || salePrice < 0) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
            icon: 'warning',
            confirmType: 'warning'
        });
        return;
    }

    if (!saleDate) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢',
            icon: 'warning',
            confirmType: 'warning'
        });
        return;
    }

    try {
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢ (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡∏∞‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á)
        const endpoint = deviceType === 'used' ? API_ENDPOINTS.usedDevices : API_ENDPOINTS.newDevices;

        await API.put(`${endpoint}/${deviceId}`, {
            status: 'sold',
            sale_price: salePrice,
            sale_date: saleDate, // ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            note: null // ‡∏•‡πâ‡∏≤‡∏á note ‡πÄ‡∏Å‡πà‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ç‡∏±‡∏î‡πÅ‡∏¢‡πâ‡∏á‡∏Å‡∏±‡∏ö validation (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô note ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö", "‡πÇ‡∏≠‡∏ô", "‡∏¢‡πâ‡∏≤‡∏¢")
        });

        closeConfirmSalePriceModal();
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (${formatCurrency(salePrice)})`,
            icon: 'success',
            confirmType: 'success'
        });
        
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó
        if (deviceType === 'used') {
            await applyUsedDevicesFilter();
        } else {
            await applyNewDevicesFilter();
        }

        // Clear device type
        window.currentSaleDeviceType = null;

    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Move sold device back to stock (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏ú‡∏¥‡∏î)
async function moveBackToStock(deviceId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏™‡∏ï‡πä‡∏≠‡∏Ñ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'question',
        confirmText: '‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
        confirmType: 'primary',
        list: [
            { icon: 'info', iconSymbol: '‚Ü©Ô∏è', text: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Tab "‡∏™‡∏ï‡πä‡∏≠‡∏Ñ"' },
            { icon: 'info', iconSymbol: '‚ÑπÔ∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö' }
        ]
    });

    if (!confirmed) return;

    try {
        await API.put(`${API_ENDPOINTS.newDevices}/${deviceId}`, {
            status: 'stock',
            sale_price: null,
            sale_date: null
            });
            loadNewDevicesData();
        showNotification('‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
            console.error(error);
        }
    }

// Move used device back to stock (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏ú‡∏¥‡∏î - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á)
async function moveUsedBackToStock(deviceId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏™‡∏ï‡πä‡∏≠‡∏Ñ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'question',
        confirmText: '‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
        confirmType: 'primary',
        list: [
            { icon: 'info', iconSymbol: '‚Ü©Ô∏è', text: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Tab "‡∏™‡∏ï‡πä‡∏≠‡∏Ñ"' },
            { icon: 'info', iconSymbol: '‚ÑπÔ∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢/‡∏ï‡∏±‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö' }
        ]
    });

    if (!confirmed) return;

    try {
        await API.put(`${API_ENDPOINTS.usedDevices}/${deviceId}`, {
            status: 'stock',
            sale_price: null,
            sale_date: null,
            note: ''
        });
        
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏¢‡πâ‡∏≤‡∏¢‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πä‡∏≠‡∏Ñ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            icon: 'success',
            confirmType: 'success'
        });
        
        await applyUsedDevicesFilter();
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Mark device as removed - Open selection modal
async function markAsRemoved(deviceId) {
    try {
        const device = await API.get(`${API_ENDPOINTS.newDevices}/${deviceId}`);
        if (!device) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
                icon: 'error',
                confirmType: 'danger'
            });
            return;
        }

        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ
        window.currentRemoveDevice = device;

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô Modal
        const deviceInfo = `${device.brand} ${device.model} (${device.color})`;
        const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
        const originalSalePrice = parseFloat(device.sale_price || device.salePrice || 0);

        document.getElementById('removeDeviceInfo').textContent = deviceInfo;
        document.getElementById('removePurchasePrice').textContent = formatCurrency(purchasePrice);
        document.getElementById('removeOriginalPrice').textContent = formatCurrency(originalSalePrice);
        document.getElementById('removeDeviceId').value = deviceId;

        // ‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
        const otherStore = device.store === 'salaya' ? 'klongyong' : 'salaya';
        const otherStoreName = stores[otherStore];
        document.getElementById('transferStoreName').textContent = `‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ: ${otherStoreName}`;

        // ‡πÅ‡∏™‡∏î‡∏á Modal
        document.getElementById('confirmRemoveModal').style.display = 'block';

    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Close remove modal
function closeConfirmRemoveModal() {
    document.getElementById('confirmRemoveModal').style.display = 'none';
    window.currentRemoveDevice = null;
}

// Select remove option
async function selectRemoveOption(option) {
    const device = window.currentRemoveDevice;
    const deviceId = document.getElementById('removeDeviceId').value;

    if (!device) {
        await customAlert({
            title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
            message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
            icon: 'error',
            confirmType: 'danger'
        });
        return;
    }

    closeConfirmRemoveModal();

    if (option === 'other') {
        // ‡∏ï‡∏±‡∏î‡∏Ç‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏à‡πâ‡∏≤‡∏≠‡∏∑‡πà‡∏ô - ‡πÅ‡∏™‡∏î‡∏á Modal ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏Ñ‡∏≤
        openConfirmRemoveOtherModal(device, deviceId);
    } else if (option === 'transfer') {
        // ‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á - ‡∏¢‡πâ‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡∏™‡∏ï‡πä‡∏≠‡∏Ñ‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        confirmTransferToOtherStore(device, deviceId);
    }
}

// Confirm transfer to other store (‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å + ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á)
async function confirmTransferToOtherStore(device, deviceId) {
    try {
        const deviceType = window.currentRemoveDeviceType || 'new';
            const otherStore = device.store === 'salaya' ? 'klongyong' : 'salaya';
            const otherStoreName = stores[otherStore];
        const currentStoreName = stores[device.store];

        // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á)
        const transactionDate = await promptTransactionDate('remove'); // ‡πÉ‡∏ä‡πâ 'remove' ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î
        if (!transactionDate) {
            return; // ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
        }

        console.log('üìÖ Selected transaction date:', transactionDate);

        // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö
        const confirmed = await customConfirm({
            title: '‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô',
            message: `${device.brand} ${device.model} (${device.color})`,
            icon: 'question',
            confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType: 'success',
            list: [
                {
                    icon: 'check',
                    iconSymbol: '‚úì',
                    text: `‡∏£‡πâ‡∏≤‡∏ô${currentStoreName}: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô "‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å"`
                },
                {
                    icon: 'check',
                    iconSymbol: '‚úì',
                    text: `‡∏£‡πâ‡∏≤‡∏ô${otherStoreName}: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô "‡∏™‡∏ï‡πä‡∏≠‡∏Ñ"`
                },
                {
                    icon: 'check',
                    iconSymbol: '‚úì',
                    text: '‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°'
                },
                {
                    icon: 'info',
                    iconSymbol: 'üí°',
                    text: '‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡πá‡∏Ñ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á 2 ‡∏£‡πâ‡∏≤‡∏ô'
                }
            ]
        });

        if (confirmed) {
            const endpoint = deviceType === 'used' ? API_ENDPOINTS.usedDevices : API_ENDPOINTS.newDevices;
            
            // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏° (‡∏£‡πâ‡∏≤‡∏ô‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á) ‚Üí ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô 'removed'
            await API.put(`${endpoint}/${deviceId}`, {
                status: 'removed',
                sale_date: transactionDate, // ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
                note: `‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô${otherStoreName}`
            });

            // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
            const newDeviceData = {
                id: (deviceType === 'used' ? 'U' : 'N') + Date.now().toString(),
                brand: device.brand,
                model: device.model,
                color: device.color,
                imei: device.imei.substring(0, 10) + 'T' + Date.now().toString().slice(-4), // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß IMEI
                ram: device.ram,
                rom: device.rom,
                purchased_from: device.purchased_from || device.purchasedFrom || '',
                device_category: device.device_category || device.deviceCategory || 'No Active',
                purchase_price: device.purchase_price || device.purchasePrice,
                import_date: device.import_date || device.importDate || device.purchase_date || device.purchaseDate,
                sale_price: device.sale_price || device.salePrice,
                sale_date: null,
                status: 'stock',
                note: `‡∏£‡∏±‡∏ö‡πÇ‡∏≠‡∏ô‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô${currentStoreName} (‡πÄ‡∏î‡∏¥‡∏° ID: ${deviceId})`,
                    store: otherStore
            };

            // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏¥‡∏•‡∏î‡πå device_condition
            if (deviceType === 'used') {
                newDeviceData.device_condition = device.device_condition || device.condition || 'good';
            }

            await API.post(endpoint, newDeviceData);
            
            // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
            await customAlert({
                title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                message: `‡∏ï‡∏±‡∏î‡∏™‡∏•‡∏±‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!\n\n‡∏£‡πâ‡∏≤‡∏ô${currentStoreName}: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô "‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å"\n‡∏£‡πâ‡∏≤‡∏ô${otherStoreName}: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô "‡∏™‡∏ï‡πä‡∏≠‡∏Ñ"`,
                icon: 'success',
                confirmType: 'success'
            });
            
            // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó
            if (deviceType === 'used') {
                await applyUsedDevicesFilter();
            } else {
                await applyNewDevicesFilter();
            }
            
            // Clear device type
            window.currentRemoveDeviceType = null;
        }
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Open confirm remove to other store modal
function openConfirmRemoveOtherModal(device, deviceId) {
    const deviceInfo = `${device.brand} ${device.model} (${device.color})`;
    const purchasePrice = parseFloat(device.purchase_price || device.purchasePrice || 0);
    const originalSalePrice = parseFloat(device.sale_price || device.salePrice || 0);

    document.getElementById('removeOtherDeviceInfo').textContent = deviceInfo;
    document.getElementById('removeOtherPurchasePrice').textContent = formatCurrency(purchasePrice);
    document.getElementById('removeOtherOriginalPrice').textContent = formatCurrency(originalSalePrice);
    document.getElementById('removeOtherSalePrice').value = originalSalePrice;
    document.getElementById('removeOtherDeviceId').value = deviceId;
    
    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('removeOtherDateInput').value = today;

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    updateRemoveOtherProfit(originalSalePrice, purchasePrice);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏° event listener ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á‡πÅ‡∏ö‡∏ö real-time
    const priceInput = document.getElementById('removeOtherSalePrice');
    priceInput.oninput = function() {
        const salePrice = parseFloat(this.value) || 0;
        updateRemoveOtherProfit(salePrice, purchasePrice);
    };

    // ‡πÅ‡∏™‡∏î‡∏á Modal
    document.getElementById('confirmRemoveOtherModal').style.display = 'block';
}

// Update remove other profit display
function updateRemoveOtherProfit(salePrice, purchasePrice) {
    const profit = salePrice - purchasePrice;
    const percentage = purchasePrice > 0 ? ((profit / purchasePrice) * 100).toFixed(2) : 0;

    const profitValue = document.getElementById('removeOtherProfit');
    const profitPercent = document.getElementById('removeOtherProfitPercent');

    profitValue.textContent = formatCurrency(profit);
    profitPercent.textContent = `${percentage}%`;

    // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏µ
    if (profit > 0) {
        profitValue.style.color = '#10b981';
        profitPercent.style.color = '#10b981';
    } else if (profit < 0) {
        profitValue.style.color = '#ef4444';
        profitPercent.style.color = '#ef4444';
    } else {
        profitValue.style.color = '#6b7280';
        profitPercent.style.color = '#6b7280';
    }
}

// Close confirm remove other modal
function closeConfirmRemoveOtherModal() {
    document.getElementById('confirmRemoveOtherModal').style.display = 'none';
    document.getElementById('confirmRemoveOtherForm').reset();
}

// Confirm remove to other store
async function confirmRemoveToOther(event) {
    event.preventDefault();

    const deviceId = document.getElementById('removeOtherDeviceId').value;
    const salePrice = parseFloat(document.getElementById('removeOtherSalePrice').value);
    const removeDate = document.getElementById('removeOtherDateInput').value; // ‡∏≠‡πà‡∏≤‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å input
    const note = document.getElementById('removeOtherNote').value;
    const deviceType = window.currentRemoveDeviceType || 'new';

    if (!salePrice || salePrice < 0) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
            icon: 'warning',
            confirmType: 'warning'
        });
        return;
    }

    if (!removeDate) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏î',
            icon: 'warning',
            confirmType: 'warning'
        });
        return;
    }

    try {
        const endpoint = deviceType === 'used' ? API_ENDPOINTS.usedDevices : API_ENDPOINTS.newDevices;
        
        await API.put(`${endpoint}/${deviceId}`, {
            status: 'removed',
            sale_price: salePrice,
            sale_date: removeDate, // ‡πÉ‡∏ä‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            note: note
        });

        closeConfirmRemoveOtherModal();
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏ï‡∏±‡∏î‡∏Ç‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏à‡πâ‡∏≤‡∏≠‡∏∑‡πà‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            icon: 'success',
            confirmType: 'success'
        });
        
        // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó
        if (deviceType === 'used') {
            await applyUsedDevicesFilter();
        } else {
            await applyNewDevicesFilter();
        }
        
        // Clear device type
        window.currentRemoveDeviceType = null;

    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message,
            icon: 'error',
            confirmType: 'danger'
        });
        console.error(error);
    }
}

// Delete device
// View New Device Detail (Read-only)
async function viewNewDeviceDetail(deviceId) {
    try {
        const device = await API.get(`${API_ENDPOINTS.newDevices}/${deviceId}`);
        
        // Open modal with read-only data
        document.getElementById('deviceDetailModalTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà';
        document.getElementById('detailBrand').textContent = device.brand || '-';
        document.getElementById('detailModel').textContent = device.model || '-';
        document.getElementById('detailColor').textContent = device.color || '-';
        document.getElementById('detailImei').textContent = device.imei || '-';
        document.getElementById('detailRam').textContent = device.ram || '-';
        document.getElementById('detailRom').textContent = device.rom || '-';
        document.getElementById('detailPurchasePrice').textContent = formatCurrency(device.purchase_price || device.purchasePrice || 0);
        document.getElementById('detailSalePrice').textContent = formatCurrency(device.sale_price || device.salePrice || 0);
        document.getElementById('detailImportDate').textContent = formatDate(device.import_date || device.importDate);
        document.getElementById('detailStatus').textContent = getStatusLabel(device.status);
        document.getElementById('detailStore').textContent = device.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
        document.getElementById('detailNote').textContent = device.note || '-';
        
        // Set device ID for edit button
        document.getElementById('editDeviceFromDetailBtn').onclick = () => {
            closeModal('deviceDetailModal');
            openNewDeviceModal(deviceId);
        };
        
        openModal('deviceDetailModal');
    } catch (error) {
        console.error('Error loading device detail:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message);
    }
}

function getStatusLabel(status) {
    const labels = {
        'stock': '‡∏™‡∏ï‡πá‡∏≠‡∏Ñ',
        'sold': '‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
        'removed': '‡∏ï‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß',
        'installment': '‡∏ú‡πà‡∏≠‡∏ô‡∏ä‡∏≥‡∏£‡∏∞'
    };
    return labels[status] || status;
}

// View Used Device Detail (Read-only)
async function viewUsedDeviceDetail(deviceId) {
    try {
        const device = await API.get(`${API_ENDPOINTS.usedDevices}/${deviceId}`);
        
        document.getElementById('deviceDetailModalTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á';
        document.getElementById('detailBrand').textContent = device.brand || '-';
        document.getElementById('detailModel').textContent = device.model || '-';
        document.getElementById('detailColor').textContent = device.color || '-';
        document.getElementById('detailImei').textContent = device.imei || '-';
        document.getElementById('detailRam').textContent = device.ram || '-';
        document.getElementById('detailRom').textContent = device.rom || '-';
        document.getElementById('detailPurchasePrice').textContent = formatCurrency(device.purchase_price || device.purchasePrice || 0);
        document.getElementById('detailSalePrice').textContent = formatCurrency(device.sale_price || device.salePrice || 0);
        document.getElementById('detailImportDate').textContent = formatDate(device.purchase_date || device.purchaseDate);
        document.getElementById('detailStatus').textContent = getStatusLabel(device.status);
        document.getElementById('detailStore').textContent = device.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
        document.getElementById('detailNote').textContent = device.note || '-';
        
        document.getElementById('editDeviceFromDetailBtn').onclick = () => {
            closeModal('deviceDetailModal');
            openUsedDeviceModal(deviceId);
        };
        
        openModal('deviceDetailModal');
    } catch (error) {
        console.error('Error loading used device detail:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message);
    }
}

// View Installment Detail (Read-only)
async function viewInstallmentDetail(installmentId) {
    console.log('üîç viewInstallmentDetail called with ID:', installmentId);
    try {
        const inst = await API.get(`${API_ENDPOINTS.installment}/${installmentId}`);
        console.log('‚úÖ Installment data loaded:', inst);
        
        document.getElementById('installmentDetailModalTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ú‡πà‡∏≠‡∏ô';
        document.getElementById('detailInstBrand').textContent = inst.brand || '-';
        document.getElementById('detailInstModel').textContent = inst.model || '-';
        document.getElementById('detailInstColor').textContent = inst.color || '-';
        document.getElementById('detailInstImei').textContent = inst.imei || '-';
        document.getElementById('detailInstCustomerName').textContent = inst.customer_name || inst.customerName || '-';
        document.getElementById('detailInstCustomerPhone').textContent = inst.customer_phone || inst.customerPhone || '-';
        document.getElementById('detailInstSalePrice').textContent = formatCurrency(inst.sale_price || inst.salePrice || 0);
        document.getElementById('detailInstDownPayment').textContent = formatCurrency(inst.down_payment || inst.downPayment || 0);
        document.getElementById('detailInstAmount').textContent = formatCurrency(inst.installment_amount || inst.installmentAmount || 0);
        document.getElementById('detailInstTotal').textContent = `${inst.paid_installments || inst.paidInstallments || 0}/${inst.total_installments || inst.totalInstallments || 0}`;
        document.getElementById('detailInstStatus').textContent = getInstallmentStatusLabel(inst.status);
        document.getElementById('detailInstStore').textContent = inst.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
        
        document.getElementById('editInstFromDetailBtn').onclick = () => {
            closeModal('installmentDetailModal');
            const type = inst.installment_type || inst.installmentType || 'partner';
            openInstallmentModal(installmentId, type);
        };
        
        console.log('‚úÖ Opening installment detail modal');
        openModal('installmentDetailModal');
    } catch (error) {
        console.error('‚ùå Error loading installment detail:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message);
    }
}

function getInstallmentStatusLabel(status) {
    const labels = {
        'active': '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ú‡πà‡∏≠‡∏ô',
        'completed': '‡∏ú‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß',
        'seized': '‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á'
    };
    return labels[status] || status;
}

// View Pawn Detail (Read-only)
async function viewPawnDetail(pawnId) {
    try {
        const pawn = await API.get(`${API_ENDPOINTS.pawn}/${pawnId}`);
        
        document.getElementById('pawnDetailModalTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å';
        document.getElementById('detailPawnBrand').textContent = pawn.brand || '-';
        document.getElementById('detailPawnModel').textContent = pawn.model || '-';
        document.getElementById('detailPawnColor').textContent = pawn.color || '-';
        document.getElementById('detailPawnImei').textContent = pawn.imei || '-';
        document.getElementById('detailPawnCustomerName').textContent = pawn.customer_name || pawn.customerName || '-';
        document.getElementById('detailPawnCustomerPhone').textContent = pawn.customer_phone || pawn.customerPhone || '-';
        document.getElementById('detailPawnAmount').textContent = formatCurrency(pawn.pawn_amount || pawn.pawnAmount || 0);
        document.getElementById('detailPawnInterest').textContent = formatCurrency(pawn.interest || 0);
        document.getElementById('detailPawnRedemption').textContent = formatCurrency(pawn.redemption_amount || pawn.redemptionAmount || 0);
        document.getElementById('detailPawnReceiveDate').textContent = formatDate(pawn.receive_date || pawn.receiveDate);
        document.getElementById('detailPawnDueDate').textContent = formatDate(pawn.due_date || pawn.dueDate);
        document.getElementById('detailPawnStatus').textContent = getPawnStatusLabel(pawn.status);
        document.getElementById('detailPawnStore').textContent = pawn.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
        
        document.getElementById('editPawnFromDetailBtn').onclick = () => {
            closeModal('pawnDetailModal');
            openPawnModal(pawnId);
        };
        
        openModal('pawnDetailModal');
    } catch (error) {
        console.error('Error loading pawn detail:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message);
    }
}

function getPawnStatusLabel(status) {
    const labels = {
        'active': '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ù‡∏≤‡∏Å',
        'returned': '‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
        'seized': '‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á'
    };
    return labels[status] || status;
}

// View Repair Detail (Read-only)
async function viewRepairDetail(repairId) {
    try {
        console.log('üîç [viewRepairDetail] Loading repair detail for ID:', repairId);
        const repair = await API.get(`${API_ENDPOINTS.repairs}/${repairId}`);
        console.log('üìã [viewRepairDetail] Repair data:', repair);
        
        document.getElementById('repairDetailModalTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ã‡πà‡∏≠‡∏°';
        document.getElementById('detailRepairBrand').textContent = repair.brand || '-';
        document.getElementById('detailRepairModel').textContent = repair.model || '-';
        document.getElementById('detailRepairColor').textContent = repair.color || '-';
        document.getElementById('detailRepairImei').textContent = repair.imei || '-';
        document.getElementById('detailRepairCustomerName').textContent = repair.customer_name || repair.customerName || '-';
        document.getElementById('detailRepairCustomerPhone').textContent = repair.customer_phone || repair.customerPhone || '-';
        document.getElementById('detailRepairCost').textContent = formatCurrency(repair.repair_cost || repair.price || 0);
        document.getElementById('detailRepairCommission').textContent = formatCurrency(repair.commission || 0);
        document.getElementById('detailRepairTechnician').textContent = repair.technician || '-';
        document.getElementById('detailRepairStatus').textContent = getRepairStatusLabel(repair.status);
        document.getElementById('detailRepairStore').textContent = repair.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏±‡∏ô‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á
        const receiveDateEl = document.getElementById('detailRepairReceiveDate');
        if (!receiveDateEl) {
            console.error('‚ùå [viewRepairDetail] Element detailRepairReceiveDate not found!');
        } else {
            const receiveDate = repair.received_date || repair.receiveDate;
            console.log('üìÖ [viewRepairDetail] Receive date:', receiveDate);
            if (receiveDate) {
                const date = new Date(receiveDate);
                // Format: DD/MM/YYYY (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ toLocaleDateString ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏õ‡∏µ ‡∏û.‡∏®.)
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                const formattedDate = `${day}/${month}/${year}`;
                console.log('üìÖ [viewRepairDetail] Formatted date:', formattedDate);
                receiveDateEl.textContent = formattedDate;
            } else {
                console.log('üìÖ [viewRepairDetail] No receive date found');
                receiveDateEl.textContent = '-';
            }
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô
        const warrantyEl = document.getElementById('detailRepairWarrantyInline');
        if (!warrantyEl) {
            console.error('‚ùå [viewRepairDetail] Element detailRepairWarrantyInline not found!');
        } else {
            const warranty = repair.warranty;
            console.log('üõ°Ô∏è [viewRepairDetail] Raw warranty value:', warranty);
            console.log('üõ°Ô∏è [viewRepairDetail] Warranty type:', typeof warranty);
            console.log('üõ°Ô∏è [viewRepairDetail] Full repair object:', repair);
            
            if (warranty !== null && warranty !== undefined && warranty !== '') {
                const warrantyLabels = {
                    '7': '7 ‡∏ß‡∏±‡∏ô',
                    '30': '1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',
                    '90': '3 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',
                    '180': '6 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',
                    '365': '1 ‡∏õ‡∏µ'
                };
                const warrantyText = warrantyLabels[warranty.toString()] || `${warranty} ‡∏ß‡∏±‡∏ô`;
                console.log('‚úÖ [viewRepairDetail] Setting warranty text:', warrantyText);
                warrantyEl.textContent = warrantyText;
            } else {
                console.log('‚ö†Ô∏è [viewRepairDetail] Warranty is null/undefined/empty, showing dash');
                warrantyEl.textContent = '-';
            }
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏ (‡∏•‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏≠‡∏≠‡∏Å)
        let regularNote = repair.note || '';
        // ‡∏•‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ß‡∏á‡πÄ‡∏•‡πá‡∏ö ‡πÄ‡∏ä‡πà‡∏ô (‡∏ø220) ‡∏´‡∏£‡∏∑‡∏≠ (220)
        regularNote = regularNote.replace(/\s*\([‡∏ø‡∏ø]?\d+(?:,\d+)*\)/g, '');
        
        const noteSection = document.getElementById('detailRepairNoteSection');
        if (regularNote.trim()) {
            document.getElementById('detailRepairNote').textContent = regularNote;
            noteSection.style.display = 'block';
        } else {
            noteSection.style.display = 'none';
        }
        
        document.getElementById('editRepairFromDetailBtn').onclick = () => {
            closeModal('repairDetailModal');
            openRepairModal(repairId);
        };
        
        openModal('repairDetailModal');
    } catch (error) {
        console.error('Error loading repair detail:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message);
    }
}

function getRepairStatusLabel(status) {
    const labels = {
        'pending': '‡∏£‡∏≠‡∏ã‡πà‡∏≠‡∏°',
        'in-progress': '‡∏™‡πà‡∏á‡∏ã‡πà‡∏≠‡∏°',
        'completed': '‡∏ã‡πà‡∏≠‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à',
        'returned': '‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
        'received': '‡∏£‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á',
        'seized': '‡∏¢‡∏∂‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á'
    };
    return labels[status] || status;
}

async function deleteDevice(deviceId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'warning',
        confirmText: '‡∏•‡∏ö',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
        confirmType: 'danger',
        list: [
            { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ' },
            { icon: 'info', iconSymbol: '‚ÑπÔ∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏ñ‡∏≤‡∏ß‡∏£' }
        ]
    });

    if (confirmed) {
        try {
            await API.delete(`${API_ENDPOINTS.newDevices}/${deviceId}`);
            loadNewDevicesData();
            showNotification('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } catch (error) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: error.message,
                icon: 'error',
                confirmType: 'danger'
            });
            console.error(error);
        }
    }
}

// Initialize search
function initializeSearch() {
    const searchInput = document.getElementById('searchNewDevices');
    console.log('üîç Initializing search for new devices, input element:', searchInput);
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            console.log('üîç Search triggered:', e.target.value);
            applyNewDevicesFilter();
        });
        console.log('‚úÖ Search event listener added');
    } else {
        console.warn('‚ö†Ô∏è searchNewDevices input element not found');
    }
}

// Filter devices based on search term
function filterDevices(searchTerm) {
    applyNewDevicesFilter();
}

// Prompt for transaction date (with date picker)
async function promptTransactionDate(actionType = 'installment') {
    return new Promise((resolve) => {
        const today = new Date().toISOString().split('T')[0];
        
        // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
        const labels = {
            'installment': '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ú‡πà‡∏≠‡∏ô',
            'remove': '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î'
        };
        const labelText = labels[actionType] || '‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£';
        
        // ‡πÉ‡∏ä‡πâ customConfirm ‡πÅ‡∏ó‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠
        const dialog = document.getElementById('customDialog');
        const dialogTitle = document.getElementById('customDialogTitle');
        const dialogMessage = document.getElementById('customDialogMessage');
        const dialogIcon = document.getElementById('customDialogIcon');
        const dialogList = document.getElementById('customDialogList');
        const btnCancel = document.getElementById('customDialogCancel');
        const btnConfirm = document.getElementById('customDialogConfirm');

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ dialog
        dialogTitle.textContent = 'üìÖ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£';
        dialogMessage.innerHTML = `
            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #333;">${labelText}:</label>
                <input type="date" id="transactionDateInput" value="${today}" 
                    style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px; font-family: inherit;">
                <small style="color: #666; margin-top: 8px; display: block;">
                    üí° ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÑ‡∏î‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                </small>
            </div>
        `;
        
        dialogIcon.innerHTML = '<span class="dialog-icon-symbol">üìÖ</span>';
        dialogList.style.display = 'none';
        
        // ‡πÅ‡∏™‡∏î‡∏á dialog
        dialog.classList.add('active');
        
        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏∏‡πà‡∏°
        btnCancel.textContent = '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å';
        btnConfirm.textContent = '‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô';
        
        // Remove old listeners
        const newBtnCancel = btnCancel.cloneNode(true);
        const newBtnConfirm = btnConfirm.cloneNode(true);
        btnCancel.parentNode.replaceChild(newBtnCancel, btnCancel);
        btnConfirm.parentNode.replaceChild(newBtnConfirm, btnConfirm);
        
        // Add new listeners
        newBtnCancel.onclick = () => {
            dialog.classList.remove('active');
            resolve(null);
        };
        
        newBtnConfirm.onclick = () => {
            const date = document.getElementById('transactionDateInput').value;
            dialog.classList.remove('active');
            resolve(date);
        };
        
        // Focus on date input
        setTimeout(() => {
            const input = document.getElementById('transactionDateInput');
            if (input) input.focus();
        }, 100);
    });
}

// Format date
function formatDate(dateString) {
    if (!dateString) return '-';
    const date = new Date(dateString);
    // Use en-GB locale to display year in Christian Era (e.g., 2025) instead of Buddhist Era (e.g., 2568)
    const day = date.getDate();
    const month = date.toLocaleDateString('th-TH', { month: 'short' });
    const year = date.getFullYear(); // This returns Christian Era year (e.g., 2025)
    return `${day} ${month} ${year}`;
}

// Show notification
function showNotification(message) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        padding: 16px 24px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease;
    `;
    notification.textContent = message;

    document.body.appendChild(notification);

    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 2000);
}

// Close modal when clicking outside
window.onclick = function(event) {
    const modal = document.getElementById('newDeviceModal');
    if (event.target === modal) {
        closeNewDeviceModal();
    }
}

// ===== DATABASE MANAGEMENT FUNCTIONS =====

// Note: Reset function removed - now using MySQL API instead of localStorage mock data

// Clear all data
async function clearNewDevicesDatabase() {
    const confirmed = await customConfirm({
        title: '‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î',
        message: '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'warning',
        confirmText: '‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
        confirmType: 'danger',
        list: [
            { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ' },
            { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏ñ‡∏≤‡∏ß‡∏£' },
            { icon: 'info', iconSymbol: '‚ÑπÔ∏è', text: '‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏ö' }
        ]
    });

    if (confirmed) {
        newDevices = [];
        localStorage.setItem('newDevices', JSON.stringify(newDevices));
        loadNewDevicesData();
        showNotification('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        console.log('üóëÔ∏è ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß');
    }
}

// Export database to JSON file
function exportNewDevicesDatabase() {
    const dataStr = JSON.stringify(newDevices, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `new-devices-backup-${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    URL.revokeObjectURL(url);
    showNotification('‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
}

// Import database from JSON file
async function importNewDevicesDatabase(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const importedData = JSON.parse(e.target.result);
            
            const confirmed = await customConfirm({
                title: '‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: `‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ${importedData.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`,
                icon: 'question',
                confirmText: '‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤',
                cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
                confirmType: 'success',
                list: [
                    { icon: 'info', iconSymbol: 'üì¶', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ${importedData.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£` },
                    { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà' }
                ]
            });

            if (confirmed) {
                newDevices = importedData;
                localStorage.setItem('newDevices', JSON.stringify(newDevices));
                loadNewDevicesData();
                showNotification('‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
                console.log('‚úÖ ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
                console.log(`üìä ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${newDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
            }
        } catch (error) {
            await customAlert({
                title: '‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå JSON ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                icon: 'error',
                confirmType: 'danger'
            });
            console.error('Import error:', error);
        }
    };
    reader.readAsText(file);
}

// Show database statistics in console
function showDatabaseStats() {
    console.log('üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà');
    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

    const salayaDevices = newDevices.filter(d => d.store === 'salaya');
    const klongyongDevices = newDevices.filter(d => d.store === 'klongyong');

    console.log(`üìç ‡∏£‡πâ‡∏≤‡∏ô‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤: ${salayaDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
    console.log(`   - ‡∏™‡∏ï‡πä‡∏≠‡∏Ñ: ${salayaDevices.filter(d => d.status === 'stock').length}`);
    console.log(`   - ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß: ${salayaDevices.filter(d => d.status === 'sold').length}`);
    console.log(`   - ‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å: ${salayaDevices.filter(d => d.status === 'removed').length}`);

    console.log(`üìç ‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á: ${klongyongDevices.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
    console.log(`   - ‡∏™‡∏ï‡πä‡∏≠‡∏Ñ: ${klongyongDevices.filter(d => d.status === 'stock').length}`);
    console.log(`   - ‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß: ${klongyongDevices.filter(d => d.status === 'sold').length}`);
    console.log(`   - ‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å: ${klongyongDevices.filter(d => d.status === 'removed').length}`);

    console.log(`\nüí∞ ‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏™‡∏ï‡πä‡∏≠‡∏Ñ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${formatCurrency(
        newDevices.filter(d => d.status === 'stock')
            .reduce((sum, d) => sum + d.purchasePrice, 0)
    )}`);

    console.log(`üíµ ‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${formatCurrency(
        newDevices.filter(d => d.status === 'sold')
            .reduce((sum, d) => sum + d.salePrice, 0)
    )}`);

    console.log(`üìà ‡∏Å‡∏≥‡πÑ‡∏£‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢: ${formatCurrency(
        newDevices.filter(d => d.status === 'sold')
            .reduce((sum, d) => sum + (d.salePrice - d.purchasePrice), 0)
    )}`);

    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
}

// Add to window for console access
window.resetNewDevicesDB = resetNewDevicesDatabase;
window.clearNewDevicesDB = clearNewDevicesDatabase;
window.exportNewDevicesDB = exportNewDevicesDatabase;
window.showNewDevicesStats = showDatabaseStats;

// ===== ACCESSORIES (‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà) =====


// Data storage for accessories
let accessories = [];

// Open accessory modal
async function openAccessoryModal(accessoryId = null) {
    const modal = document.getElementById('accessoryModal');
    const modalTitle = document.getElementById('accessoryModalTitle');
    const form = document.getElementById('accessoryForm');

    form.reset();
    currentAccessoryEditId = accessoryId;

    if (accessoryId) {
        // Edit mode
        modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';
        try {
            const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);
            document.getElementById('accessoryType').value = accessory.type;
            document.getElementById('accessoryCode').value = accessory.code;
            document.getElementById('accessoryBrand').value = accessory.brand;
            document.getElementById('accessoryModels').value = accessory.models;
            document.getElementById('accessoryQuantity').value = accessory.quantity;
            document.getElementById('accessoryCostPrice').value = accessory.cost_price;
            document.getElementById('accessoryRepairPrice').value = accessory.repair_price;
            // Convert date to YYYY-MM-DD format
            const importDate = accessory.import_date ? new Date(accessory.import_date).toISOString().split('T')[0] : '';
            document.getElementById('accessoryImportDate').value = importDate;
            document.getElementById('accessoryNote').value = accessory.note || '';
        } catch (error) {
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà');
            console.error(error);
            return;
        }
    } else {
        // Add mode
        modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà';
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('accessoryImportDate').value = today;

        // Set default type based on current tab
        if (currentAccessoryTab !== 'outofstock' && currentAccessoryTab !== 'claim') {
            document.getElementById('accessoryType').value = currentAccessoryTab;
        }
    }

    modal.classList.add('show');
}

// Close accessory modal
function closeAccessoryModal() {
    const modal = document.getElementById('accessoryModal');
    modal.classList.remove('show');
    currentAccessoryEditId = null;
}

// Save accessory
async function saveAccessory(event) {
    event.preventDefault();

    const formData = new FormData(event.target);

    const accessoryData = {
        type: formData.get('type'),
        code: formData.get('code'),
        brand: formData.get('brand'),
        models: formData.get('models'),
        quantity: parseInt(formData.get('quantity')),
        claim_quantity: 0,
        cost_price: parseFloat(formData.get('costPrice')),
        repair_price: parseFloat(formData.get('repairPrice')),
        import_date: formData.get('importDate'),
        claim_date: null,
        note: formData.get('note') || '',
        store: currentStore
    };

    try {
        if (currentAccessoryEditId) {
            // Update - check if we need to restore from removed status
            const existingAccessory = await API.get(`${API_ENDPOINTS.accessories}/${currentAccessoryEditId}`);

            // Preserve damage information (don't reset it)
            if (existingAccessory.damage_quantity !== undefined) {
                accessoryData.damage_quantity = existingAccessory.damage_quantity;
            }
            if (existingAccessory.damage_date !== undefined) {
                accessoryData.damage_date = existingAccessory.damage_date;
            }

            // If was removed ([REMOVED] or [REMOVED:date] prefix in note) and quantity > 0, remove the prefix
            if (existingAccessory.note && existingAccessory.note.startsWith('[REMOVED') && accessoryData.quantity > 0) {
                // Remove [REMOVED] or [REMOVED:date] prefix to restore to normal category
                accessoryData.note = accessoryData.note.replace(/^\[REMOVED(:\d{4}-\d{2}-\d{2})?\]\s*/, '');
            }

            await API.put(`${API_ENDPOINTS.accessories}/${currentAccessoryEditId}`, accessoryData);
            showNotification('‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } else {
            // Add
            accessoryData.id = 'ACC' + Date.now().toString();
            console.log('[saveAccessory] Creating new accessory:', accessoryData);
            await API.post(API_ENDPOINTS.accessories, accessoryData);
            showNotification('‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }

        loadAccessoriesData();
        closeAccessoryModal();
    } catch (error) {
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
        console.error(error);
    }
}

// Execute accessory action from dropdown
async function executeAccessoryAction(accessoryId) {
    console.log('üéØ [executeAccessoryAction START]', { accessoryId });
    
    const selectElement = document.getElementById(`acc-action-${accessoryId}`);
    
    if (!selectElement) {
        console.error('‚ùå [executeAccessoryAction] Select element not found!', { accessoryId });
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏û‡∏ö dropdown ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'error'
        });
        return;
    }
    
    const action = selectElement.value;
    const allOptions = Array.from(selectElement.options).map(opt => ({ 
        value: opt.value, 
        text: opt.text, 
        selected: opt.selected 
    }));

    console.log('üîß [executeAccessoryAction] Details:', {
        accessoryId,
        action,
        selectValue: action,
        selectedIndex: selectElement.selectedIndex,
        selectedOption: selectElement.options[selectElement.selectedIndex]?.value,
        allOptions: allOptions
    });
    
    // Log each option individually
    allOptions.forEach((opt, idx) => {
        console.log(`  Option ${idx}: value="${opt.value}", text="${opt.text}", selected=${opt.selected}`);
    });

    if (!action || action === '') {
        console.warn('‚ö†Ô∏è [executeAccessoryAction] No action selected!');
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡∏ï‡∏Å‡∏•‡∏á"',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'use':
            await useAccessory(accessoryId);
            break;
        case 'cut':
            await openCutStockModal(accessoryId);
            break;
        case 'claim':
            await openClaimModal(accessoryId);
            break;
        case 'damage':
            await openDamageModal(accessoryId);
            break;
        case 'return-stock':
            await openReturnStockModal(accessoryId);
            break;
        case 'delete-damage':
            await deleteDamageAccessory(accessoryId);
            break;
        case 'edit-damage':
            await openEditDamageModal(accessoryId);
            break;
        case 'edit':
            await openAccessoryModal(accessoryId);
            break;
        case 'delete':
            await deleteAccessory(accessoryId);
            break;
        default:
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å',
                icon: 'error'
            });
    }

    // Reset select after action
    selectElement.value = '';
}

// Delete accessory
// Use accessory (decrease quantity by 1)
async function useAccessory(accessoryId) {
    try {
        // Get current accessory data
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);

        if (!accessory) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô',
                icon: 'error'
            });
            return;
        }

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
        // ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: quantity ‡πÉ‡∏ô DB ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏±‡∏Å cut_quantity)
        const claimQuantity = Number(accessory.claim_quantity) || 0;
        const availableQuantity = Number(accessory.quantity) - claimQuantity;

        console.log(`[useAccessory] Accessory: ${accessory.code}, quantity=${accessory.quantity}, claim=${claimQuantity}, available=${availableQuantity}`);

        if (availableQuantity <= 0) {
            await customAlert({
                title: '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏´‡∏°‡∏î',
                message: '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ô‡∏µ‡πâ‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ',
                icon: 'warning'
            });
            return;
        }

        // Decrease quantity by 1
        const newQuantity = Number(accessory.quantity) - 1;
        const newAvailable = availableQuantity - 1;

        // Confirm before using
        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà',
            message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
            icon: 'question',
            confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            list: [
                { icon: 'info', iconSymbol: 'üì¶', text: `${accessory.code} - ${accessory.brand} ${accessory.models}` },
                { icon: 'info', iconSymbol: 'üî¢', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${accessory.quantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                { icon: 'warning', iconSymbol: '‚ûñ', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô: ${newQuantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                ...(newQuantity === 0 ? [{ icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡πÅ‡∏ó‡πá‡∏ö "‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏´‡∏°‡∏î"' }] : [])
            ]
        });

        if (!confirmed) return;

        // Convert import_date to YYYY-MM-DD format
        const importDate = accessory.import_date ? new Date(accessory.import_date).toISOString().split('T')[0] : new Date().toISOString().split('T')[0];

        // Update accessory
        await API.put(`${API_ENDPOINTS.accessories}/${accessoryId}`, {
            type: accessory.type,
            code: accessory.code,
            brand: accessory.brand,
            models: accessory.models,
            quantity: newQuantity,
            cost_price: accessory.cost_price,
            repair_price: accessory.repair_price,
            import_date: importDate,
            note: accessory.note,
            store: accessory.store
        });

        loadAccessoriesData();
        
        // Show appropriate notification
        if (newQuantity === 0) {
            showNotification('‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ñ‡∏π‡∏Å‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡πÅ‡∏ó‡πá‡∏ö "‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏´‡∏°‡∏î"', 'success');
        } else {
            showNotification(`‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${newQuantity} ‡∏ä‡∏¥‡πâ‡∏ô`, 'success');
        }
    } catch (error) {
        console.error('Error using accessory:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Delete accessory
async function deleteAccessory(accessoryId) {
    try {
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);
        if (!accessory) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
                icon: 'error'
            });
            return;
        }

        const typeName = getAccessoryTypeName(accessory.type);
        const claimQuantity = Number(accessory.claim_quantity) || 0;

        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå',
            message: '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? ‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ',
            icon: 'warning',
            confirmText: '‡∏•‡∏ö',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType: 'danger',
            list: [
                { icon: 'info', iconSymbol: 'üîß', text: `‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: ${typeName}` },
                { icon: 'info', iconSymbol: 'üì¶', text: `‡∏£‡∏´‡∏±‡∏™: ${accessory.code}` },
                { icon: 'info', iconSymbol: 'üì±', text: `${accessory.brand} - ${accessory.models || '-'}` },
                { icon: 'info', iconSymbol: 'üìä', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${accessory.quantity}${claimQuantity > 0 ? ` (‡πÄ‡∏Ñ‡∏•‡∏°: ${claimQuantity})` : ''}` },
                { icon: 'info', iconSymbol: 'üí∞', text: `‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô: ${formatCurrency(accessory.cost_price)} | ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ã‡πà‡∏≠‡∏°: ${formatCurrency(accessory.repair_price)}` },
                { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏ñ‡∏≤‡∏ß‡∏£‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö' }
            ]
        });

        if (confirmed) {
        await API.delete(`${API_ENDPOINTS.accessories}/${accessoryId}`);
        loadAccessoriesData();
            showNotification('‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
            console.log(`‚úÖ ‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå ID: ${accessoryId}`);
        }
    } catch (error) {
        console.error('Error deleting accessory:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Switch accessory tab
function switchAccessoryTab(tab) {
    // Only reset brand if actually changing to a different tab
    if (currentAccessoryTab !== tab) {
        currentAccessoryBrand = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î'; // Reset brand to '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' when switching accessory type
    }
    
    currentAccessoryTab = tab;
    
    // Update tab buttons
    const tabButtons = document.querySelectorAll('#accessories .tabs:not(.brand-tabs) .tab-btn');
    const tabContents = document.querySelectorAll('#accessories .tab-content');
    
    tabButtons.forEach(btn => {
        if (btn.getAttribute('data-tab') === 'accessory-' + tab) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    tabContents.forEach(content => {
        if (content.id === 'accessory-' + tab) {
            content.classList.add('active');
        } else {
            content.classList.remove('active');
        }
    });
    
    // Update brand tabs
    updateAccessoryBrandTabs();
}

// Switch accessory brand (‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 2)
function switchAccessoryBrand(brand, event) {
    currentAccessoryBrand = brand;
    
    // Update brand tab buttons
    const brandButtons = document.querySelectorAll('.brand-tab-btn');
    brandButtons.forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Add active class to clicked button
    if (event && event.target) {
        event.target.closest('.brand-tab-btn').classList.add('active');
    }
    
    // Re-render current tab with brand filter
    loadAccessoriesData();
}

// Update brand tabs (counts and visibility)
function updateAccessoryBrandTabs() {
    // Remove active from all buttons
    const brandButtons = document.querySelectorAll('.brand-tab-btn');
    brandButtons.forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Add active to current brand
    if (currentAccessoryBrand) {
        brandButtons.forEach(btn => {
            const onclickAttr = btn.getAttribute('onclick');
            if (onclickAttr && onclickAttr.includes(`'${currentAccessoryBrand}'`)) {
                btn.classList.add('active');
            }
        });
    }
    
    // Update brand counts
    updateAccessoryBrandCounts();
}

// Update brand badge counts
function updateAccessoryBrandCounts() {
    const BRAND_CATEGORIES = ['Apple', 'Samsung', 'Redmi', 'Oppo', 'Vivo', 'Realme', 'Infinix'];
    
    // Get data from cache for current tab
    const currentData = accessoriesDataCache[currentAccessoryTab] || [];
    
    // Count by brand
    const brandCounts = {
        '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î': currentData.length,
        'Apple': 0,
        'Samsung': 0,
        'Redmi': 0,
        'Oppo': 0,
        'Vivo': 0,
        'Realme': 0,
        'Infinix': 0,
        '‡∏≠‡∏∑‡πà‡∏ô‡πÜ': 0
    };
    
    currentData.forEach(item => {
        const brand = item.brand || '';
        
        // Find matching brand category
        const brandKey = BRAND_CATEGORIES.find(b => brand.toLowerCase().includes(b.toLowerCase()));
        if (brandKey) {
            brandCounts[brandKey]++;
        } else {
            brandCounts['‡∏≠‡∏∑‡πà‡∏ô‡πÜ']++;
        }
    });
    
    // Update badges
    const updateBadge = (id, count) => {
        const badge = document.getElementById(id);
        if (badge) badge.textContent = count;
    };
    
    updateBadge('brandAllCount', brandCounts['‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î']);
    updateBadge('brandAppleCount', brandCounts['Apple']);
    updateBadge('brandSamsungCount', brandCounts['Samsung']);
    updateBadge('brandRedmiCount', brandCounts['Redmi']);
    updateBadge('brandOppoCount', brandCounts['Oppo']);
    updateBadge('brandVivoCount', brandCounts['Vivo']);
    updateBadge('brandRealmeCount', brandCounts['Realme']);
    updateBadge('brandInfinixCount', brandCounts['Infinix']);
    updateBadge('brandOthersCount', brandCounts['‡∏≠‡∏∑‡πà‡∏ô‡πÜ']);
    
    console.log('[updateAccessoryBrandCounts] Brand counts:', brandCounts);
}

// Load accessories data
async function loadAccessoriesData() {
    console.log(`[loadAccessoriesData] Loading for store: ${currentStore}`);
    try {
        // Get accessories from API (with timestamp to prevent caching)
        const allAccessories = await API.get(API_ENDPOINTS.accessories, { 
            store: currentStore,
            _t: Date.now() // Add timestamp to bypass cache
        });
        
        console.log(`‚úÖ [loadAccessoriesData] Loaded ${allAccessories.length} accessories from API`);
        
        // Log sample data to check quantity values
        const sampleData = allAccessories.slice(0, 3).map(a => ({
            code: a.code,
            type: a.type,
            quantity: a.quantity,
            damage_quantity: a.damage_quantity
        }));
        console.log('üì¶ [loadAccessoriesData] Sample data:', sampleData);
        
        // Validate data
        if (!Array.isArray(allAccessories)) {
            console.warn('API returned invalid data:', allAccessories);
            // Display empty tables
            displayAccessories([], 'batteryTableBody');
            displayAccessories([], 'screenTableBody');
            displayAccessories([], 'chargingTableBody');
            displayAccessories([], 'switchTableBody');
            displayAccessories([], 'flexTableBody');
            displayAccessories([], 'speakerTableBody');
            displayOutOfStockAccessories([], 'outofstockTableBody');
            displayClaimAccessories([], 'claimTableBody');
            displayDamageAccessories([], 'damageTableBody');
            return;
        }
        
        console.log(`[loadAccessoriesData] Loaded ${allAccessories.length} accessories`);

        // Apply search only (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà - ‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏ï‡πá‡∏≠‡∏Ñ)
        let filteredAccessories = allAccessories;
        if (currentAccessoryFilter.search) {
            const search = currentAccessoryFilter.search.toLowerCase();
            filteredAccessories = filteredAccessories.filter(a =>
                a.brand.toLowerCase().includes(search) ||
                a.code.toLowerCase().includes(search) ||
                a.models.toLowerCase().includes(search)
            );
        }

        // Separate by type and cache (‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà quantity > 0)
        const batteryAccessories = filteredAccessories.filter(a => a.type === 'battery' && Number(a.quantity) > 0);
        const screenAccessories = filteredAccessories.filter(a => a.type === 'screen' && Number(a.quantity) > 0);
        const chargingAccessories = filteredAccessories.filter(a => a.type === 'charging' && Number(a.quantity) > 0);
        const switchAccessories = filteredAccessories.filter(a => a.type === 'switch' && Number(a.quantity) > 0);
        const flexAccessories = filteredAccessories.filter(a => a.type === 'flex' && Number(a.quantity) > 0);
        const speakerAccessories = filteredAccessories.filter(a => a.type === 'speaker' && Number(a.quantity) > 0);
        
        console.log('üìã [loadAccessoriesData] Filtered by type (quantity > 0):', {
            battery: batteryAccessories.length,
            screen: screenAccessories.length,
            charging: chargingAccessories.length,
            switch: switchAccessories.length,
            flex: flexAccessories.length,
            speaker: speakerAccessories.length
        });
        
        // Cache data for brand counting
        accessoriesDataCache.battery = batteryAccessories;
        accessoriesDataCache.screen = screenAccessories;
        accessoriesDataCache.charging = chargingAccessories;
        accessoriesDataCache.switch = switchAccessories;
        accessoriesDataCache.flex = flexAccessories;
        accessoriesDataCache.speaker = speakerAccessories;
        
        // Get cut accessories from API endpoint (‡πÉ‡∏ä‡πâ cut_quantity)
        let removedAccessories = [];
        try {
            const cutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: currentStore });
            console.log(`[loadAccessoriesData] Loaded ${cutAccessories.length} cut accessories from API`);
            
            // Apply search filter only to cut accessories (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà)
            if (currentAccessoryFilter.search) {
                const search = currentAccessoryFilter.search.toLowerCase();
                removedAccessories = (cutAccessories || []).filter(a =>
                    a.brand.toLowerCase().includes(search) ||
                    a.code.toLowerCase().includes(search) ||
                    a.models.toLowerCase().includes(search)
                );
            } else {
                removedAccessories = cutAccessories || [];
            }
            
            console.log(`[loadAccessoriesData] Final removedAccessories: ${removedAccessories.length} items`, removedAccessories);
        } catch (error) {
            console.error('Error loading cut accessories:', error);
            // Fallback: filter from filteredAccessories if API fails
            removedAccessories = filteredAccessories.filter(a => (Number(a.cut_quantity) || 0) > 0);
        }
        
        const outOfStockAccessories = filteredAccessories.filter(a => Number(a.quantity) === 0);
        const claimAccessories = filteredAccessories.filter(a => (Number(a.claim_quantity) || 0) > 0);
        
        // Filter damage accessories by date filter (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        let damageAccessories = filteredAccessories.filter(a => (Number(a.damage_quantity) || 0) > 0);
        
        // Determine date range (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        const startDate = currentAccessoryFilter.startDate || getFirstDayOfMonth();
        const endDate = currentAccessoryFilter.endDate || getLastDayOfMonth();
        
        console.log('üîç [Damage Filter]:', {
            startDate,
            endDate,
            isFiltered: !!(currentAccessoryFilter.startDate || currentAccessoryFilter.endDate),
            beforeFilter: damageAccessories.length
        });

        // Apply date filter to damage accessories (‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° damage_date)
        const beforeDamageFilter = damageAccessories.length;
        damageAccessories = damageAccessories.filter(a => {
            const damageDate = a.damage_date;
            if (!damageDate) {
                console.log('‚ùå No damage_date for:', a.code);
                return false;
            }

            const dateOnly = damageDate.split('T')[0]; // YYYY-MM-DD
            const matched = dateOnly >= startDate && dateOnly <= endDate;
            
            console.log(`${matched ? '‚úÖ' : '‚ùå'} Damage item: ${a.code}, date: ${dateOnly}, filter: ${startDate} - ${endDate}, matched: ${matched}`);
            
            return matched;
        });
        
        console.log(`üìä Damage accessories: ${beforeDamageFilter} ‚Üí ${damageAccessories.length}`);
        
        // Cache data for removed, outofstock, claim, damage tabs
        accessoriesDataCache.removed = removedAccessories;
        accessoriesDataCache.outofstock = outOfStockAccessories;
        accessoriesDataCache.claim = claimAccessories;
        accessoriesDataCache.damage = damageAccessories;

        console.log(`[loadAccessoriesData] removedAccessories: ${removedAccessories.length} items`);
        console.log(`[loadAccessoriesData] outOfStockAccessories (quantity = 0): ${outOfStockAccessories.length} items`, 
            outOfStockAccessories.map(a => ({ code: a.code, type: a.type, quantity: a.quantity, damage_qty: a.damage_quantity })));
        console.log(`[loadAccessoriesData] damageAccessories (damage_quantity > 0): ${damageAccessories.length} items`,
            damageAccessories.map(a => ({ code: a.code, type: a.type, quantity: a.quantity, damage_qty: a.damage_quantity })));

        // Update counts
        const batteryCountEl = document.getElementById('batteryCount');
        const screenCountEl = document.getElementById('screenCount');
        const chargingCountEl = document.getElementById('chargingCount');
        const switchCountEl = document.getElementById('switchCount');
        const flexCountEl = document.getElementById('flexCount');
        const speakerCountEl = document.getElementById('speakerCount');
        const removedCountEl = document.getElementById('removedCount');
        const outofstockCountEl = document.getElementById('outofstockCount');
        const claimCountEl = document.getElementById('claimCount');
        const damageCountEl = document.getElementById('damageCount');

        if (batteryCountEl) batteryCountEl.textContent = batteryAccessories.length;
        if (screenCountEl) screenCountEl.textContent = screenAccessories.length;
        if (chargingCountEl) chargingCountEl.textContent = chargingAccessories.length;
        if (switchCountEl) switchCountEl.textContent = switchAccessories.length;
        if (flexCountEl) flexCountEl.textContent = flexAccessories.length;
        if (speakerCountEl) speakerCountEl.textContent = speakerAccessories.length;
        if (removedCountEl) removedCountEl.textContent = removedAccessories.length;
        if (outofstockCountEl) outofstockCountEl.textContent = outOfStockAccessories.length;
        if (claimCountEl) claimCountEl.textContent = claimAccessories.length;
        if (damageCountEl) damageCountEl.textContent = damageAccessories.length;

        // Display accessories
        displayAccessories(batteryAccessories, 'batteryTableBody');
        displayAccessories(screenAccessories, 'screenTableBody');
        displayAccessories(chargingAccessories, 'chargingTableBody');
        displayAccessories(switchAccessories, 'switchTableBody');
        displayAccessories(flexAccessories, 'flexTableBody');
        displayAccessories(speakerAccessories, 'speakerTableBody');
        displayRemovedAccessories(removedAccessories, 'accessoryRemovedTableBody');
        displayOutOfStockAccessories(outOfStockAccessories, 'outofstockTableBody');
        displayClaimAccessories(claimAccessories, 'claimTableBody');
        displayDamageAccessories(damageAccessories, 'damageTableBody');
        
        // Update brand counts for current tab
        updateAccessoryBrandCounts();
        
        // Update dashboard cards with all accessories data
        updateAccessoriesDashboardCards(allAccessories);
        
        // Initialize tab display
        switchAccessoryTab(currentAccessoryTab || 'battery');
    } catch (error) {
        console.error('Error loading accessories:', error);
        console.error('Error details:', error.message);
        // Display empty tables instead of alert
        displayAccessories([], 'batteryTableBody');
        displayAccessories([], 'screenTableBody');
        displayAccessories([], 'chargingTableBody');
        displayAccessories([], 'switchTableBody');
        displayAccessories([], 'flexTableBody');
        displayAccessories([], 'speakerTableBody');
        displayRemovedAccessories([], 'accessoryRemovedTableBody');
        displayOutOfStockAccessories([], 'outofstockTableBody');
        displayClaimAccessories([], 'claimTableBody');
        
        // Update dashboard cards with empty data
        updateAccessoriesDashboardCards([]);
    }
}

// Update accessories dashboard cards
async function updateAccessoriesDashboardCards(allAccessories) {
    console.log('[updateAccessoriesDashboardCards] Calculating with', allAccessories.length, 'accessories');
    
    // Filter by current store (for all calculations)
    const storeAccessoriesAll = allAccessories.filter(a => a.store === currentStore);
    
    // 1. ‡∏™‡∏ï‡πá‡∏≠‡∏Ñ: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏™‡∏°‡∏≠ ‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á date)
    const totalStock = storeAccessoriesAll
        .filter(a => Number(a.quantity) > 0)
        .reduce((sum, a) => sum + Number(a.quantity), 0);
    
    // 2. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏î (cut) ‡∏à‡∏≤‡∏Å API
    let allCutAccessories = [];
    try {
        allCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: currentStore });
    } catch (error) {
        console.error('[updateAccessoriesDashboardCards] Error loading cut accessories:', error);
    }
    
    let storeCutAccessories = allCutAccessories.filter(a => a.store === currentStore);
    let damageAccessories = storeAccessoriesAll.filter(a => (Number(a.damage_quantity) || 0) > 0);
    
    // Apply date filter if exists
    if (currentAccessoryFilter.startDate || currentAccessoryFilter.endDate) {
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏î ‡∏ï‡∏≤‡∏° cut_date
        storeCutAccessories = storeCutAccessories.filter(a => {
            const cutDate = a.cut_date || a.cutDate;
            if (!cutDate) return false;
            
            const date = new Date(cutDate);
            const startMatch = !currentAccessoryFilter.startDate || 
                              date >= new Date(currentAccessoryFilter.startDate);
            const endMatch = !currentAccessoryFilter.endDate || 
                            date <= new Date(currentAccessoryFilter.endDate + 'T23:59:59');
            
            return startMatch && endMatch;
        });
        
        // ‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ‡∏ï‡∏≤‡∏° damage_date
        damageAccessories = damageAccessories.filter(a => {
            const damageDate = a.damage_date;
            if (!damageDate) return false;
            
            const date = new Date(damageDate);
            const startMatch = !currentAccessoryFilter.startDate || 
                              date >= new Date(currentAccessoryFilter.startDate);
            const endMatch = !currentAccessoryFilter.endDate || 
                            date <= new Date(currentAccessoryFilter.endDate + 'T23:59:59');
            
            return startMatch && endMatch;
        });
    }
    
    console.log('[updateAccessoriesDashboardCards] Stock (all):', totalStock, 'Cut:', storeCutAccessories.length, 'Damage:', damageAccessories.length);
    
    // 3. ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ (‡∏Å‡∏≤‡∏£‡πå‡∏î): ‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏≤‡∏°‡∏™‡∏ï‡πá‡∏≠‡∏Ñ ‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà)
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å: (quantity + cut_quantity + damage_quantity) √ó cost_price
    const totalExpense = storeAccessoriesAll.reduce((sum, a) => {
        const quantity = Number(a.quantity) || 0;
        const cutQuantity = Number(a.cut_quantity) || 0;
        const damageQuantity = Number(a.damage_quantity) || 0;
        const totalQuantity = quantity + cutQuantity + damageQuantity;
        const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
        return sum + (costPrice * totalQuantity);
    }, 0);
    
    // 4. ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö (‡∏Å‡∏≤‡∏£‡πå‡∏î): ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà (‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà)
    const totalIncome = storeCutAccessories.reduce((sum, a) => {
        const cutQuantity = Number(a.cut_quantity || 0);
        const cutPrice = parseFloat(a.repair_price || a.cut_price || a.cutPrice || 0);
        return sum + (cutPrice * cutQuantity);
    }, 0);

    // 5. ‡∏Å‡∏≥‡πÑ‡∏£ (‡∏Å‡∏≤‡∏£‡πå‡∏î): ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ + ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î)
    // ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á = ‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢ + ‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ (‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà)
    const expenseFromSold = storeCutAccessories.reduce((sum, a) => {
        const cutQuantity = Number(a.cut_quantity) || 0;
        const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
        return sum + (costPrice * cutQuantity);
    }, 0);
    
    const expenseFromDamage = damageAccessories.reduce((sum, a) => {
        const damageQuantity = Number(a.damage_quantity) || 0;
        const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
        return sum + (costPrice * damageQuantity);
    }, 0);
    
    const filteredExpense = expenseFromSold + expenseFromDamage;
    
    // ‡∏Å‡∏≥‡πÑ‡∏£‡∏™‡∏∏‡∏ó‡∏ò‡∏¥ = ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö (‡∏Å‡∏£‡∏≠‡∏á) - ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ (‡∏Å‡∏£‡∏≠‡∏á)
    const totalProfit = totalIncome - filteredExpense;
    
    // Update UI
    const stockCountElement = document.getElementById('accessoriesStockCount');
    const expenseElement = document.getElementById('accessoriesExpense');
    const incomeElement = document.getElementById('accessoriesIncome');
    const profitElement = document.getElementById('accessoriesProfit');
    
    if (stockCountElement) {
        stockCountElement.textContent = totalStock;
    }
    
    if (expenseElement) {
        expenseElement.textContent = formatCurrency(totalExpense);
    }
    
    if (incomeElement) {
        incomeElement.textContent = formatCurrency(totalIncome);
    }
    
    if (profitElement) {
        profitElement.textContent = formatCurrency(totalProfit);
        // Change color based on profit/loss
        const profitCard = profitElement.closest('.page-stat-card');
        if (profitCard) {
            profitCard.classList.remove('negative');
            if (totalProfit < 0) {
                profitCard.classList.add('negative');
            }
        }
    }
    
    console.log('üìä Accessories Dashboard Cards Updated:', {
        stock: `${totalStock} ‡∏ä‡∏¥‡πâ‡∏ô (‡∏Ñ‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô ‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á date)`,
        expenseCard: formatCurrency(totalExpense) + ' (‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏ï‡πá‡∏≠‡∏Ñ ‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á date)',
        incomeCard: formatCurrency(totalIncome) + ' (‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢ ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° cut_date)',
        profitCard: formatCurrency(totalProfit) + ' (‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö - ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß)',
        detail: {
            cut: `${storeCutAccessories.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`,
            damage: `${damageAccessories.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`,
            expenseFromSold: formatCurrency(expenseFromSold),
            expenseFromDamage: formatCurrency(expenseFromDamage),
            filteredExpense: formatCurrency(filteredExpense)
        },
        filtered: !!currentAccessoryFilter.startDate || !!currentAccessoryFilter.endDate
    });
}

// Show accessories expense detail page
async function showAccessoriesExpenseDetail() {
    try {
        // Get all accessories
        const allAccessories = await API.get(API_ENDPOINTS.accessories, { store: currentStore });

        // Filter by current store
        let storeAccessories = allAccessories.filter(a => a.store === currentStore);

        // Apply date filter if exists
        if (currentAccessoryFilter.startDate || currentAccessoryFilter.endDate) {
            storeAccessories = storeAccessories.filter(a => {
                const importDate = a.import_date || a.importDate;
                if (!importDate) return false;

                const date = new Date(importDate);
                const startMatch = !currentAccessoryFilter.startDate ||
                                  date >= new Date(currentAccessoryFilter.startDate);
                const endMatch = !currentAccessoryFilter.endDate ||
                                date <= new Date(currentAccessoryFilter.endDate + 'T23:59:59');

                return startMatch && endMatch;
            });
        }

        // Calculate total expense
        const totalExpense = storeAccessories.reduce((sum, a) => {
            const quantity = Number(a.quantity) || 0;
            const cutQuantity = Number(a.cut_quantity) || 0;
            const totalQuantity = quantity + cutQuantity;
            const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
            return sum + (costPrice * totalQuantity);
        }, 0);

        // Update page summary
        const monthElement = document.getElementById('accessoriesExpenseMonth');
        const totalElement = document.getElementById('accessoriesExpenseDetailTotal');
        const countElement = document.getElementById('accessoriesExpenseDetailCount');

        if (monthElement) {
            if (currentAccessoryFilter.startDate || currentAccessoryFilter.endDate) {
                const startStr = currentAccessoryFilter.startDate ? formatDate(currentAccessoryFilter.startDate) : '‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î';
                const endStr = currentAccessoryFilter.endDate ? formatDate(currentAccessoryFilter.endDate) : '‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î';
                monthElement.textContent = `${startStr} ‡∏ñ‡∏∂‡∏á ${endStr}`;
            } else {
                monthElement.textContent = '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î';
            }
        }

        if (totalElement) totalElement.textContent = formatCurrency(totalExpense);
        if (countElement) countElement.textContent = storeAccessories.length;

        // Update table - show individual items
        const tbody = document.getElementById('accessoriesExpenseDetailTableBody');
        if (!tbody) return;

        if (storeAccessories.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        } else {
            tbody.innerHTML = storeAccessories.map(a => {
                const quantity = Number(a.quantity) || 0;
                const cutQuantity = Number(a.cut_quantity) || 0;
                const totalQuantity = quantity + cutQuantity;
                const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
                const totalPrice = costPrice * totalQuantity;
                const importDate = a.import_date || a.importDate;

                return `
                    <tr>
                        <td style="text-align: center;">${importDate ? formatDate(importDate) : '-'}</td>
                        <td style="text-align: left;">${getAccessoryTypeName(a.type)}</td>
                        <td style="text-align: left;">${a.code}</td>
                        <td style="text-align: left;">${a.brand}</td>
                        <td style="text-align: left;">${a.models}</td>
                        <td style="text-align: center;">${totalQuantity}</td>
                        <td style="text-align: right;">${formatCurrency(costPrice)}</td>
                        <td style="text-align: right; font-weight: bold; color: #dc3545;">${formatCurrency(totalPrice)}</td>
                    </tr>
                `;
            }).join('');
        }

        // Hide accessories page and show detail page
        document.getElementById('accessories').classList.remove('active');
        document.getElementById('accessories-expense-detail').classList.add('active');

    } catch (error) {
        console.error('Error showing accessories expense detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close accessories expense detail modal
function closeAccessoriesExpenseDetailModal() {
    const modal = document.getElementById('accessoriesExpenseDetailModal');
    if (modal) modal.classList.remove('show');
}

// Show accessories income detail page
async function showAccessoriesIncomeDetail() {
    try {
        // Get cut accessories from the correct API endpoint
        const allCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: currentStore });
        
        // Get all accessories to get damage data
        const allAccessories = await API.get(API_ENDPOINTS.accessories, { store: currentStore });

        // Filter cut accessories by current store
        let storeCutAccessories = allCutAccessories.filter(a => a.store === currentStore);
        
        // Filter all accessories by current store
        let storeAccessories = allAccessories.filter(a => a.store === currentStore);
        
        // Get damaged accessories first
        let damageAccessories = storeAccessories.filter(a => (Number(a.damage_quantity) || 0) > 0);
        
        // Get date filter (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        const startDate = currentAccessoryFilter.startDate || getFirstDayOfMonth();
        const endDate = currentAccessoryFilter.endDate || getLastDayOfMonth();

        console.log('üîç [Income Detail] Filter:', {
            startDate,
            endDate,
            isFiltered: !!(currentAccessoryFilter.startDate || currentAccessoryFilter.endDate),
            beforeFilter: {
                cut: storeCutAccessories.length,
                damage: damageAccessories.length
            }
        });

        // Always apply date filter (‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á)
        // Filter cut accessories by cut_date (‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏î)
        const beforeCutFilter = storeCutAccessories.length;
        storeCutAccessories = storeCutAccessories.filter(a => {
                const cutDate = a.cut_date || a.cutDate;
            if (!cutDate) {
                console.log('‚ùå No cut_date for:', a.code);
                return false;
            }

            const dateOnly = cutDate.split('T')[0]; // YYYY-MM-DD
            const matched = dateOnly >= startDate && dateOnly <= endDate;
            
            console.log(`${matched ? '‚úÖ' : '‚ùå'} Cut item: ${a.code}, date: ${dateOnly}, filter: ${startDate} - ${endDate}, matched: ${matched}`);

            return matched;
        });
        console.log(`üìä Cut accessories: ${beforeCutFilter} ‚Üí ${storeCutAccessories.length}`);
        
        // Filter damage accessories by damage_date (‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢)
        const beforeDamageFilter = damageAccessories.length;
        damageAccessories = damageAccessories.filter(a => {
            const damageDate = a.damage_date;
            if (!damageDate) {
                console.log('‚ùå No damage_date for:', a.code);
                return false;
            }

            const dateOnly = damageDate.split('T')[0]; // YYYY-MM-DD
            const matched = dateOnly >= startDate && dateOnly <= endDate;
            
            console.log(`${matched ? '‚úÖ' : '‚ùå'} Damage item: ${a.code}, date: ${dateOnly}, filter: ${startDate} - ${endDate}, matched: ${matched}`);

            return matched;
        });
        console.log(`üìä Damage accessories: ${beforeDamageFilter} ‚Üí ${damageAccessories.length}`);

        // Calculate total income from cut
        const incomeFromCut = storeCutAccessories.reduce((sum, a) => {
            const cutQuantity = Number(a.cut_quantity || 0);
            const cutPrice = parseFloat(a.repair_price || a.cut_price || a.cutPrice || 0);
            return sum + (cutPrice * cutQuantity);
        }, 0);
        
        // Calculate total loss from damage
        const lossFromDamage = damageAccessories.reduce((sum, a) => {
            const damageQuantity = Number(a.damage_quantity || 0);
            const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
            return sum + (costPrice * damageQuantity);
        }, 0);
        
        // Total income = income from cut only (not subtract damage loss)
        // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏Ñ‡∏∑‡∏≠‡∏£‡∏ß‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å‡∏Ñ‡πà‡∏≤‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢
        const totalIncome = incomeFromCut;

        // Update page summary
        const monthElement = document.getElementById('accessoriesIncomeMonth');
        const totalElement = document.getElementById('accessoriesIncomeDetailTotal');
        const countElement = document.getElementById('accessoriesIncomeDetailCount');
        
        if (monthElement) {
            if (currentAccessoryFilter.startDate || currentAccessoryFilter.endDate) {
                const startStr = formatDate(startDate);
                const endStr = formatDate(endDate);
                monthElement.textContent = `${startStr} ‡∏ñ‡∏∂‡∏á ${endStr}`;
            } else {
                // ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
                const now = new Date();
                const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                                  '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
                monthElement.textContent = `${monthNames[now.getMonth()]} ${now.getFullYear() + 543}`;
            }
        }
        
        if (totalElement) totalElement.textContent = formatCurrency(totalIncome);
        if (countElement) countElement.textContent = storeCutAccessories.length + damageAccessories.length;
        
        // Update table
        const tbody = document.getElementById('accessoriesIncomeDetailTableBody');
        if (!tbody) return;
        
        let html = '';
        
        // Section 1: ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà (‡∏ö‡∏ß‡∏Å)
        if (storeCutAccessories.length > 0) {
            html += `
                <tr class="summary-row" style="background: #e8f5e9;">
                    <td colspan="8" style="text-align: left; font-weight: bold; padding: 12px;">
                        üìà ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà
                    </td>
                    <td style="text-align: right; font-weight: bold; color: #28a745; padding: 12px;">
                        ${formatCurrency(incomeFromCut)}
                    </td>
                </tr>
            `;
            
            storeCutAccessories.forEach(a => {
                const cutQuantity = Number(a.cut_quantity || 0);
                const cutPrice = parseFloat(a.repair_price || a.cut_price || a.cutPrice || 0);
                const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
                const totalIncomeItem = cutPrice * cutQuantity;
                const profitPerUnit = cutPrice - costPrice;
                const totalProfit = profitPerUnit * cutQuantity;
                const cutDate = a.cut_date || a.cutDate;

                html += `
                    <tr>
                        <td style="width: 10%; text-align: center;">${cutDate ? formatDate(cutDate) : '-'}</td>
                        <td style="width: 12%; text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;${getAccessoryTypeName(a.type)}</td>
                        <td style="width: 12%; text-align: left;">${a.code}</td>
                        <td style="width: 10%; text-align: left;">${a.brand}</td>
                        <td style="width: 10%; text-align: left;">${a.models}</td>
                        <td style="width: 8%; text-align: center;">${cutQuantity}</td>
                        <td style="width: 12%; text-align: right;">${formatCurrency(costPrice)}</td>
                        <td style="width: 12%; text-align: right;">${formatCurrency(cutPrice)}</td>
                        <td style="width: 14%; text-align: right; font-weight: bold; ${totalProfit >= 0 ? 'color: #28a745;' : 'color: #dc3545;'}">${formatCurrency(totalProfit)}</td>
                    </tr>
                `;
            });
        }
        
        // Section 2: ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏à‡∏≤‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ (‡∏•‡∏ö)
        if (damageAccessories.length > 0) {
            html += `
                <tr class="summary-row" style="background: #ffebee;">
                    <td colspan="8" style="text-align: left; font-weight: bold; padding: 12px;">
                        üìâ ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏à‡∏≤‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢
                    </td>
                    <td style="text-align: right; font-weight: bold; color: #dc3545; padding: 12px;">
                        -${formatCurrency(lossFromDamage)}
                    </td>
                </tr>
            `;
            
            damageAccessories.forEach(a => {
                const damageQuantity = Number(a.damage_quantity || 0);
                const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
                const totalLoss = costPrice * damageQuantity;
                const damageDate = a.damage_date;

                html += `
                    <tr>
                        <td style="width: 10%; text-align: center;">${damageDate ? formatDate(damageDate) : '-'}</td>
                        <td style="width: 12%; text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;${getAccessoryTypeName(a.type)}</td>
                        <td style="width: 12%; text-align: left;">${a.code}</td>
                        <td style="width: 10%; text-align: left;">${a.brand}</td>
                        <td style="width: 10%; text-align: left;">${a.models}</td>
                        <td style="width: 8%; text-align: center;">${damageQuantity}</td>
                        <td style="width: 12%; text-align: right;">${formatCurrency(costPrice)}</td>
                        <td style="width: 12%; text-align: right; color: #6c757d;">‡∏ø0</td>
                        <td style="width: 14%; text-align: right; font-weight: bold; color: #dc3545;">-${formatCurrency(totalLoss)}</td>
                    </tr>
                `;
            });
        }
        
        // Summary row
        if (storeCutAccessories.length > 0 || damageAccessories.length > 0) {
            html += `
                <tr class="total-row" style="background: #f5f5f5; border-top: 2px solid #ddd;">
                    <td colspan="8" style="text-align: right; font-weight: bold; padding: 12px;">
                        ‡∏£‡∏ß‡∏°‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö (‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢):
                    </td>
                    <td style="text-align: right; font-weight: bold; font-size: 16px; padding: 12px; color: #28a745;">
                        ${formatCurrency(totalIncome)}
                    </td>
                </tr>
            `;
        }
        
        if (html === '') {
            tbody.innerHTML = '<tr><td colspan="9" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        } else {
            tbody.innerHTML = html;
        }

        // Hide accessories page and show detail page
        document.getElementById('accessories').classList.remove('active');
        document.getElementById('accessories-income-detail').classList.add('active');
        
    } catch (error) {
        console.error('Error showing accessories income detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close accessories income detail modal
function closeAccessoriesIncomeDetailModal() {
    const modal = document.getElementById('accessoriesIncomeDetailModal');
    if (modal) modal.classList.remove('show');
}

// Show accessories profit detail page
async function showAccessoriesProfitDetail() {
    try {
        // Get all accessories for expense calculation
        const allAccessories = await API.get(API_ENDPOINTS.accessories, { store: currentStore });

        // Get cut accessories for income and profit calculation
        const allCutAccessories = await API.get(API_ENDPOINTS.accessoryCutList, { store: currentStore });
        
        // Filter by current store and date
        let storeAccessories = allAccessories.filter(a => a.store === currentStore);
        let storeCutAccessories = allCutAccessories.filter(a => a.store === currentStore);

        // Get date filter (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        const startDate = currentAccessoryFilter.startDate || getFirstDayOfMonth();
        const endDate = currentAccessoryFilter.endDate || getLastDayOfMonth();
        
        // Apply date filter if exists
        let damageAccessories = storeAccessories.filter(a => (Number(a.damage_quantity) || 0) > 0);
        
        console.log('üîç [Profit Detail] Filter:', {
            startDate,
            endDate,
            isFiltered: !!(currentAccessoryFilter.startDate || currentAccessoryFilter.endDate),
            beforeFilter: {
                cut: storeCutAccessories.length,
                damage: damageAccessories.length
            }
        });
        
        // Always apply date filter (‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á)
        // Filter cut accessories by cut_date (‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà)
        const beforeCutFilter = storeCutAccessories.length;
        storeCutAccessories = storeCutAccessories.filter(a => {
                const cutDate = a.cut_date || a.cutDate;
            if (!cutDate) {
                console.log('‚ùå No cut_date for:', a.code);
                return false;
            }

            const dateOnly = cutDate.split('T')[0]; // YYYY-MM-DD
            const matched = dateOnly >= startDate && dateOnly <= endDate;
            
            console.log(`${matched ? '‚úÖ' : '‚ùå'} Cut item: ${a.code}, date: ${dateOnly}, filter: ${startDate} - ${endDate}, matched: ${matched}`);

            return matched;
        });
        console.log(`üìä Cut accessories: ${beforeCutFilter} ‚Üí ${storeCutAccessories.length}`);
        
        // Filter damaged accessories by damage_date (‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢)
        const beforeDamageFilter = damageAccessories.length;
        damageAccessories = damageAccessories.filter(a => {
            const damageDate = a.damage_date;
            if (!damageDate) {
                console.log('‚ùå No damage_date for:', a.code);
                return false;
            }

            const dateOnly = damageDate.split('T')[0]; // YYYY-MM-DD
            const matched = dateOnly >= startDate && dateOnly <= endDate;
            
            console.log(`${matched ? '‚úÖ' : '‚ùå'} Damage item: ${a.code}, date: ${dateOnly}, filter: ${startDate} - ${endDate}, matched: ${matched}`);

            return matched;
        });
        console.log(`üìä Damage accessories: ${beforeDamageFilter} ‚Üí ${damageAccessories.length}`);

        // Calculate total expense (cost of sold items + cost of damaged items)
        const expenseFromSold = storeCutAccessories.reduce((sum, a) => {
            const cutQuantity = Number(a.cut_quantity) || 0;
            const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
            return sum + (costPrice * cutQuantity);
        }, 0);
        
        const expenseFromDamage = damageAccessories.reduce((sum, a) => {
            const damageQuantity = Number(a.damage_quantity) || 0;
            const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
            return sum + (costPrice * damageQuantity);
        }, 0);

        const totalExpense = expenseFromSold + expenseFromDamage;

        // Calculate total income (only from sold items, damage = 0)
        const totalIncome = storeCutAccessories.reduce((sum, a) => {
            const cutQuantity = Number(a.cut_quantity) || 0;
            const cutPrice = parseFloat(a.repair_price || a.cut_price || a.cutPrice || 0);
            return sum + (cutPrice * cutQuantity);
        }, 0);

        // Calculate total profit (income - expense)
        const totalProfit = totalIncome - totalExpense;

        // Update page summary
        const monthElement = document.getElementById('accessoriesProfitMonth');
        const totalElement = document.getElementById('accessoriesProfitDetailTotal');
        const countElement = document.getElementById('accessoriesProfitDetailCount');
        const expenseElement = document.getElementById('accessoriesProfitExpense');
        const incomeElement = document.getElementById('accessoriesProfitIncome');
        const resultElement = document.getElementById('accessoriesProfitResult');
        
        if (monthElement) {
            if (currentAccessoryFilter.startDate || currentAccessoryFilter.endDate) {
                const startStr = formatDate(startDate);
                const endStr = formatDate(endDate);
                monthElement.textContent = `${startStr} ‡∏ñ‡∏∂‡∏á ${endStr}`;
            } else {
                // ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
                const now = new Date();
                const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                                  '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
                monthElement.textContent = `${monthNames[now.getMonth()]} ${now.getFullYear() + 543}`;
            }
        }
        
        if (totalElement) totalElement.textContent = formatCurrency(totalProfit);
        if (countElement) countElement.textContent = storeCutAccessories.length + damageAccessories.length;
        if (expenseElement) expenseElement.textContent = formatCurrency(totalExpense);
        if (incomeElement) incomeElement.textContent = formatCurrency(totalIncome);
        if (resultElement) resultElement.textContent = formatCurrency(totalProfit);
        
        // Update table
        const tbody = document.getElementById('accessoriesProfitDetailTableBody');
        if (!tbody) return;
        
        let html = '';

        // Section 1: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢ (‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö)
        if (storeCutAccessories.length > 0) {
            html += `
                <tr class="summary-row" style="background: #e8f5e9;">
                    <td colspan="6" style="text-align: left; font-weight: bold; padding: 12px; width: 60%;">
                        üí∞ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢
                    </td>
                    <td style="width: 13%; text-align: right; font-weight: bold; color: #dc3545; padding: 12px;">
                        ${formatCurrency(expenseFromSold)}
                    </td>
                    <td style="width: 13%; text-align: right; font-weight: bold; color: #28a745; padding: 12px;">
                        ${formatCurrency(totalIncome)}
                    </td>
                    <td style="width: 14%; text-align: right; font-weight: bold; color: #17a2b8; padding: 12px;">
                        ${formatCurrency(totalIncome - expenseFromSold)}
                    </td>
                </tr>
            `;

            storeCutAccessories.forEach(a => {
                const cutQuantity = Number(a.cut_quantity || 0);
                const cutPrice = parseFloat(a.repair_price || a.cut_price || a.cutPrice || 0);
                const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
                const totalCost = costPrice * cutQuantity;
                const totalSale = cutPrice * cutQuantity;
                const profit = totalSale - totalCost;
                const cutDate = a.cut_date || a.cutDate;

                html += `
                    <tr>
                        <td style="width: 10%; text-align: center;">${cutDate ? formatDate(cutDate) : '-'}</td>
                        <td style="width: 10%; text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;${getAccessoryTypeName(a.type)}</td>
                        <td style="width: 12%; text-align: left;">${a.code}</td>
                        <td style="width: 10%; text-align: left;">${a.brand}</td>
                        <td style="width: 10%; text-align: left;">${a.models}</td>
                        <td style="width: 8%; text-align: center;">${cutQuantity}</td>
                        <td style="width: 13%; text-align: right;">${formatCurrency(totalCost)}</td>
                        <td style="width: 13%; text-align: right;">${formatCurrency(totalSale)}</td>
                        <td style="width: 14%; text-align: right; font-weight: bold; ${profit >= 0 ? 'color: #28a745;' : 'color: #dc3545;'}">${formatCurrency(profit)}</td>
                    </tr>
                `;
            });
        }

        // Section 2: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö)
        if (damageAccessories.length > 0) {
            html += `
                <tr class="summary-row" style="background: #ffebee;">
                    <td colspan="6" style="text-align: left; font-weight: bold; padding: 12px; width: 60%;">
                        ‚ö†Ô∏è ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö)
                    </td>
                    <td style="width: 13%; text-align: right; font-weight: bold; color: #dc3545; padding: 12px;">
                        ${formatCurrency(expenseFromDamage)}
                    </td>
                    <td style="width: 13%; text-align: right; font-weight: bold; color: #6c757d; padding: 12px;">
                        ‡∏ø0
                    </td>
                    <td style="width: 14%; text-align: right; font-weight: bold; color: #dc3545; padding: 12px;">
                        -${formatCurrency(expenseFromDamage)}
                    </td>
                </tr>
            `;

            damageAccessories.forEach(a => {
                const damageQuantity = Number(a.damage_quantity) || 0;
                const costPrice = parseFloat(a.cost_price || a.costPrice || 0);
                const totalCost = costPrice * damageQuantity;
                const damageDate = a.damage_date;

                html += `
                    <tr>
                        <td style="width: 10%; text-align: center;">${damageDate ? formatDate(damageDate) : '-'}</td>
                        <td style="width: 10%; text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;${getAccessoryTypeName(a.type)}</td>
                        <td style="width: 12%; text-align: left;">${a.code}</td>
                        <td style="width: 10%; text-align: left;">${a.brand}</td>
                        <td style="width: 10%; text-align: left;">${a.models}</td>
                        <td style="width: 8%; text-align: center;">${damageQuantity}</td>
                        <td style="width: 13%; text-align: right;">${formatCurrency(totalCost)}</td>
                        <td style="width: 13%; text-align: right; color: #6c757d;">‡∏ø0</td>
                        <td style="width: 14%; text-align: right; font-weight: bold; color: #dc3545;">-${formatCurrency(totalCost)}</td>
                    </tr>
                `;
            });
        }

        // Summary row
        if (storeCutAccessories.length > 0 || damageAccessories.length > 0) {
            html += `
                <tr class="total-row" style="background: #f5f5f5; border-top: 2px solid #ddd;">
                    <td colspan="6" style="text-align: right; font-weight: bold; padding: 12px; width: 60%;">
                        ‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:
                    </td>
                    <td style="width: 13%; text-align: right; font-weight: bold; font-size: 16px; padding: 12px; color: #dc3545;">
                        ${formatCurrency(totalExpense)}
                    </td>
                    <td style="width: 13%; text-align: right; font-weight: bold; font-size: 16px; padding: 12px; color: #28a745;">
                        ${formatCurrency(totalIncome)}
                    </td>
                    <td style="width: 14%; text-align: right; font-weight: bold; font-size: 16px; padding: 12px; ${totalProfit >= 0 ? 'color: #28a745;' : 'color: #dc3545;'}">
                        ${formatCurrency(totalProfit)}
                    </td>
                </tr>
            `;
        }

        if (html === '') {
            tbody.innerHTML = '<tr><td colspan="9" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        } else {
            tbody.innerHTML = html;
        }

        // Hide accessories page and show detail page
        document.getElementById('accessories').classList.remove('active');
        document.getElementById('accessories-profit-detail').classList.add('active');
        
    } catch (error) {
        console.error('Error showing accessories profit detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close accessories profit detail modal
function closeAccessoriesProfitDetailModal() {
    const modal = document.getElementById('accessoriesProfitDetailModal');
    if (modal) modal.classList.remove('show');
}

// Back to accessories page from detail pages
function backToAccessories() {
    // Hide all detail pages
    document.getElementById('accessories-expense-detail').classList.remove('active');
    document.getElementById('accessories-income-detail').classList.remove('active');
    document.getElementById('accessories-profit-detail').classList.remove('active');

    // Show accessories page
    document.getElementById('accessories').classList.add('active');
}

// Display accessories (with brand filter from tabs)
function displayAccessories(accessoriesList, tableBodyId) {
    console.log(`[displayAccessories] ${tableBodyId}: ${accessoriesList.length} items, Brand filter: ${currentAccessoryBrand}`);
    
    const tbody = document.getElementById(tableBodyId);
    if (!tbody) {
        console.error(`[displayAccessories] Table body not found: ${tableBodyId}`);
        return;
    }

    // Brand categories
    const BRAND_CATEGORIES = ['Apple', 'Samsung', 'Redmi', 'Oppo', 'Vivo', 'Realme', 'Infinix'];
    
    // Filter by selected brand
    const filteredList = accessoriesList.filter(acc => {
        const brand = acc.brand || '';
        
        // Show all if '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' is selected
        if (currentAccessoryBrand === '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î') {
            return true;
        }
        
        if (currentAccessoryBrand === '‡∏≠‡∏∑‡πà‡∏ô‡πÜ') {
            // Show items that don't match any predefined brand
            return !BRAND_CATEGORIES.some(b => brand.toLowerCase().includes(b.toLowerCase()));
        } else {
            // Show items matching the selected brand
            return brand.toLowerCase().includes(currentAccessoryBrand.toLowerCase());
        }
    });

    if (filteredList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        console.log(`[displayAccessories] ${tableBodyId}: No data after filtering, set empty state`);
        return;
    }

    // Sort by import_date (newest first)
    filteredList.sort((a, b) => {
        const dateA = new Date(a.import_date || 0);
        const dateB = new Date(b.import_date || 0);
        return dateB - dateA;
    });
    
    // Build HTML - simple rows without grouping
    let html = '';
    
    filteredList.forEach(acc => {
        const claimQuantity = Number(acc.claim_quantity) || 0;
        const availableQuantity = Number(acc.quantity) - claimQuantity;

        html += `
        <tr>
            <td>${acc.code}</td>
            <td>${acc.brand}</td>
            <td title="${acc.models || ''}">${acc.models}</td>
            <td><strong>${acc.quantity}</strong>${claimQuantity > 0 ? ` <small style="color: #e67e22;">(‡πÄ‡∏Ñ‡∏•‡∏°: ${claimQuantity})</small>` : ''}</td>
            <td>${formatCurrency(acc.cost_price)}</td>
            <td>${formatCurrency(acc.repair_price)}</td>
            <td>${formatDate(acc.import_date)}</td>
            <td>
                <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                    <select class="accessory-action-select" id="acc-action-${acc.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                        ${availableQuantity > 0 ? '<option value="use">‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</option>' : ''}
                        ${availableQuantity > 0 ? '<option value="cut">‡∏ï‡∏±‡∏î</option>' : ''}
                        ${availableQuantity > 0 ? '<option value="claim">‡πÄ‡∏Ñ‡∏•‡∏°</option>' : ''}
                        ${availableQuantity > 0 ? '<option value="damage">‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢</option>' : ''}
                        <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                        <option value="delete">‡∏•‡∏ö</option>
                    </select>
                    <button class="action-btn btn-primary" onclick="executeAccessoryAction('${acc.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                </div>
            </td>
        </tr>
        `;
    });
    
    tbody.innerHTML = html;
    console.log(`[displayAccessories] ${tableBodyId}: Done! Displayed ${filteredList.length} items`);
}

// Display removed accessories (‡∏ï‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß)
function displayRemovedAccessories(accessoriesList, tableBodyId) {
    console.log(`[displayRemovedAccessories] ${tableBodyId}: ${accessoriesList.length} items, Brand filter: ${currentAccessoryBrand}`, accessoriesList);

    const tbody = document.getElementById(tableBodyId);
    if (!tbody) {
        console.error(`[displayRemovedAccessories] Table body not found: ${tableBodyId}`);
        return;
    }

    // Brand categories
    const BRAND_CATEGORIES = ['Apple', 'Samsung', 'Redmi', 'Oppo', 'Vivo', 'Realme', 'Infinix'];
    
    // Filter by selected brand
    const filteredList = accessoriesList.filter(acc => {
        const brand = acc.brand || '';
        
        // Show all if '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' is selected
        if (currentAccessoryBrand === '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î') {
            return true;
        }
        
        if (currentAccessoryBrand === '‡∏≠‡∏∑‡πà‡∏ô‡πÜ') {
            return !BRAND_CATEGORIES.some(b => brand.toLowerCase().includes(b.toLowerCase()));
        } else {
            return brand.toLowerCase().includes(currentAccessoryBrand.toLowerCase());
        }
    });

    if (filteredList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡∏î</td></tr>';
        console.log(`[displayRemovedAccessories] ${tableBodyId}: No data after filtering, set empty state`);
        return;
    }

    // Sort by cut_date (newest first)
    filteredList.sort((a, b) => {
        const dateA = new Date(a.cut_date || a.cutDate || 0);
        const dateB = new Date(b.cut_date || b.cutDate || 0);
        return dateB - dateA;
    });

    try {
        const htmlContent = filteredList.map(acc => {
            const cutQuantity = Number(acc.cut_quantity) || 0;
            const cutPrice = parseFloat(acc.cut_price || acc.cutPrice || 0);
            const totalPrice = cutPrice * cutQuantity;
            const cutDate = acc.cut_date || acc.cutDate;

            return `
            <tr style="background: #fff9e6;">
                <td style="text-align: left;">${acc.code}</td>
                <td style="text-align: left;">${getAccessoryTypeName(acc.type)}</td>
                <td style="text-align: left;">${acc.brand} ${acc.models}</td>
                <td style="text-align: center; font-weight: bold; color: #e67e22;">${cutQuantity}</td>
                <td style="text-align: right;">${formatCurrency(cutPrice)}</td>
                <td style="text-align: right; font-weight: bold; color: #28a745;">${formatCurrency(totalPrice)}</td>
                <td style="text-align: center;">${cutDate ? formatDate(cutDate) : '-'}</td>
                <td style="text-align: center;">
                    <button class="btn btn-sm btn-edit" onclick="editCutAccessory('${acc.id}')">
                        ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
                    </button>
                    <button class="btn btn-sm btn-delete" onclick="deleteCutAccessory('${acc.id}')">
                        ‡∏•‡∏ö
                    </button>
                </td>
            </tr>
        `;
        }).join('');

        console.log(`[displayRemovedAccessories] ${tableBodyId}: HTML length:`, htmlContent.length);
        tbody.innerHTML = htmlContent;
        console.log(`[displayRemovedAccessories] ${tableBodyId}: Done! Set ${accessoriesList.length} rows`);
        console.log(`[displayRemovedAccessories] ${tableBodyId}: Current tbody.children.length:`, tbody.children.length);
    } catch (error) {
        console.error(`[displayRemovedAccessories] Error rendering table:`, error);
        tbody.innerHTML = '<tr><td colspan="7" class="empty-state">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
    }
}

// Display out of stock accessories
function displayOutOfStockAccessories(accessoriesList, tableBodyId) {
    console.log(`[displayOutOfStockAccessories] ${tableBodyId}: ${accessoriesList.length} items, Brand filter: ${currentAccessoryBrand}`, accessoriesList);

    const tbody = document.getElementById(tableBodyId);
    if (!tbody) {
        console.error(`[displayOutOfStockAccessories] Table body not found: ${tableBodyId}`);
        return;
    }

    // Brand categories
    const BRAND_CATEGORIES = ['Apple', 'Samsung', 'Redmi', 'Oppo', 'Vivo', 'Realme', 'Infinix'];
    
    // Filter by selected brand
    const filteredList = accessoriesList.filter(acc => {
        const brand = acc.brand || '';
        
        // Show all if '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' is selected
        if (currentAccessoryBrand === '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î') {
            return true;
        }
        
        if (currentAccessoryBrand === '‡∏≠‡∏∑‡πà‡∏ô‡πÜ') {
            return !BRAND_CATEGORIES.some(b => brand.toLowerCase().includes(b.toLowerCase()));
        } else {
            return brand.toLowerCase().includes(currentAccessoryBrand.toLowerCase());
        }
    });

    if (filteredList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å</td></tr>';
        console.log(`[displayOutOfStockAccessories] ${tableBodyId}: No data after filtering, set empty state`);
        return;
    }

    // Sort by import_date (newest first)
    filteredList.sort((a, b) => {
        const dateA = new Date(a.import_date || 0);
        const dateB = new Date(b.import_date || 0);
        return dateB - dateA;
    });

    const typeNames = {
        battery: '‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà',
        screen: '‡∏à‡∏≠',
        charging: '‡πÅ‡∏û‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        switch: '‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå',
        flex: '‡∏™‡∏≤‡∏¢‡πÅ‡∏û',
        speaker: '‡∏•‡∏≥‡πÇ‡∏û‡∏á'
    };

    tbody.innerHTML = filteredList.map(acc => {
        const modelsOneLine = (acc.models || '').replace(/\n/g, ', ').replace(/\r/g, '');
        return `
        <tr style="background: #fff5f5;">
            <td>${acc.code}</td>
            <td><span class="badge badge-danger">${typeNames[acc.type]}</span></td>
            <td>${acc.brand}</td>
            <td style="white-space: nowrap;">${modelsOneLine}</td>
            <td>${formatCurrency(acc.cost_price)}</td>
            <td>${formatCurrency(acc.repair_price)}</td>
            <td>${formatDate(acc.import_date)}</td>
            <td>
                <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                    <select class="accessory-action-select" id="acc-action-${acc.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                        <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                        <option value="delete">‡∏•‡∏ö</option>
                    </select>
                    <button class="action-btn btn-primary" onclick="executeAccessoryAction('${acc.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                </div>
            </td>
        </tr>
    `;
    }).join('');
}

// Search accessories
function searchAccessory() {
    const searchInput = document.getElementById('searchAccessory');
    if (searchInput) {
    currentAccessoryFilter.search = searchInput.value;
    loadAccessoriesData();
    }
}

// Filter accessories (old function - kept for compatibility but not used)
function filterAccessory() {
    // This function is deprecated - use filterAccessoryByDateRange() instead
    filterAccessoryByDateRange();
}

// Reset accessory filter
// Initialize accessory date filter
function initializeAccessoryDateFilter() {
    const monthSelect = document.getElementById('filterAccessoryMonth');
    const yearSelect = document.getElementById('filterAccessoryYear');

    if (!monthSelect || !yearSelect) return;

    // Clear existing options except the first one
    while (monthSelect.options.length > 1) {
        monthSelect.remove(1);
    }
    while (yearSelect.options.length > 1) {
        yearSelect.remove(1);
    }

    // Populate year dropdown
    const currentYear = new Date().getFullYear();
    for (let year = currentYear; year >= currentYear - 5; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = `${year + 543}`;
        yearSelect.appendChild(option);
    }

    // Populate month dropdown
    const thaiMonths = [
        '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
        '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'
    ];

    thaiMonths.forEach((month, index) => {
        const option = document.createElement('option');
        option.value = index + 1;
        option.textContent = month;
        monthSelect.appendChild(option);
    });
}

// Display claim accessories
function displayClaimAccessories(accessoriesList, tableBodyId) {
    console.log(`[displayClaimAccessories] ${tableBodyId}: ${accessoriesList.length} items, Brand filter: ${currentAccessoryBrand}`);
    
    const tbody = document.getElementById(tableBodyId);
    if (!tbody) return;

    // Brand categories
    const BRAND_CATEGORIES = ['Apple', 'Samsung', 'Redmi', 'Oppo', 'Vivo', 'Realme', 'Infinix'];
    
    // Filter by selected brand
    const filteredList = accessoriesList.filter(acc => {
        const brand = acc.brand || '';
        
        // Show all if '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' is selected
        if (currentAccessoryBrand === '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î') {
            return true;
        }
        
        if (currentAccessoryBrand === '‡∏≠‡∏∑‡πà‡∏ô‡πÜ') {
            return !BRAND_CATEGORIES.some(b => brand.toLowerCase().includes(b.toLowerCase()));
        } else {
            return brand.toLowerCase().includes(currentAccessoryBrand.toLowerCase());
        }
    });

    if (filteredList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡πÄ‡∏Ñ‡∏•‡∏°</td></tr>';
        return;
    }

    const typeNames = {
        battery: '‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà',
        screen: '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏à‡∏≠',
        charging: '‡∏ö‡∏≠‡∏£‡πå‡∏î‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        switch: '‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå'
    };

    tbody.innerHTML = filteredList.map(acc => {
        const claimQuantity = Number(acc.claim_quantity) || 0;
        const availableQuantity = Number(acc.quantity) - claimQuantity;

        return `
        <tr style="background: #fff8e1;">
            <td>${acc.code}</td>
            <td><span class="badge badge-warning">${typeNames[acc.type]}</span></td>
            <td>${acc.brand}</td>
            <td>${acc.models}</td>
            <td><strong style="color: #e67e22;">${claimQuantity}</strong></td>
            <td>${availableQuantity}</td>
            <td>${acc.claim_date ? formatDate(acc.claim_date) : '-'}</td>
            <td>
                <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                    <select class="accessory-action-select" id="acc-action-${acc.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                        <option value="return-stock">‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å</option>
                        <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                    </select>
                    <button class="action-btn btn-primary" onclick="executeAccessoryAction('${acc.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                </div>
            </td>
        </tr>
    `;
    }).join('');
}

// Display damage accessories
function displayDamageAccessories(accessoriesList, tableBodyId) {
    console.log(`[displayDamageAccessories] ${tableBodyId}: ${accessoriesList.length} items, Brand filter: ${currentAccessoryBrand}`);
    
    const tbody = document.getElementById(tableBodyId);
    if (!tbody) return;

    // Brand categories
    const BRAND_CATEGORIES = ['Apple', 'Samsung', 'Redmi', 'Oppo', 'Vivo', 'Realme', 'Infinix'];
    
    // Filter by selected brand
    const filteredList = accessoriesList.filter(acc => {
        const brand = acc.brand || '';
        
        // Show all if '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î' is selected
        if (currentAccessoryBrand === '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î') {
            return true;
        }
        
        if (currentAccessoryBrand === '‡∏≠‡∏∑‡πà‡∏ô‡πÜ') {
            return !BRAND_CATEGORIES.some(b => brand.toLowerCase().includes(b.toLowerCase()));
        } else {
            return brand.toLowerCase().includes(currentAccessoryBrand.toLowerCase());
        }
    });

    if (filteredList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢</td></tr>';
        return;
    }

    // Sort by damage_date (newest first)
    filteredList.sort((a, b) => {
        const dateA = new Date(a.damage_date || 0);
        const dateB = new Date(b.damage_date || 0);
        return dateB - dateA;
    });

    const typeNames = {
        battery: '‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà',
        screen: '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏à‡∏≠',
        charging: '‡∏ö‡∏≠‡∏£‡πå‡∏î‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        switch: '‡∏™‡∏ß‡∏¥‡∏ï‡∏ä‡πå'
    };

    tbody.innerHTML = filteredList.map(acc => {
        const damageQuantity = Number(acc.damage_quantity) || 0;
        const costPrice = parseFloat(acc.cost_price) || 0;

        return `
        <tr style="background: #ffe6e6;">
            <td>${acc.code}</td>
            <td><span class="badge badge-danger">${typeNames[acc.type]}</span></td>
            <td>${acc.brand}</td>
            <td>${acc.models}</td>
            <td><strong style="color: #dc2626;">${damageQuantity}</strong></td>
            <td>${formatCurrency(costPrice)}</td>
            <td>${acc.damage_date ? formatDate(acc.damage_date) : '-'}</td>
            <td>
                <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                    <select class="accessory-action-select damage-action-select" id="acc-action-${acc.id}" data-accessory-id="${acc.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                        <option value="edit-damage">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                        <option value="delete-damage">‡∏•‡∏ö</option>
                    </select>
                    <button class="action-btn btn-primary damage-action-btn" data-accessory-id="${acc.id}" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                </div>
            </td>
        </tr>
    `;
    }).join('');
    
    // Attach event listeners after rendering
    filteredList.forEach(acc => {
        const btn = tbody.querySelector(`button[data-accessory-id="${acc.id}"]`);
        const select = tbody.querySelector(`select[data-accessory-id="${acc.id}"]`);
        
        if (select) {
            // Add change event to highlight when selected
            select.addEventListener('change', function(e) {
                const selectedValue = e.target.value;
                console.log('üîÑ [dropdown changed]', { 
                    accessoryId: acc.id, 
                    selectedValue,
                    text: e.target.options[e.target.selectedIndex]?.text
                });
                
                // Visual feedback
                if (selectedValue) {
                    select.style.borderColor = '#667eea';
                    select.style.backgroundColor = '#f0f4ff';
                } else {
                    select.style.borderColor = '#ddd';
                    select.style.backgroundColor = 'white';
                }
            });
        }
        
        if (btn) {
            btn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üñ±Ô∏è [damage button clicked]', acc.id);
                executeAccessoryAction(acc.id);
            });
        }
    });
}

// Open claim modal
async function openClaimModal(accessoryId) {
    try {
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);

        const modal = document.getElementById('claimAccessoryModal');
        const claimQuantity = accessory.claim_quantity || 0;
        const availableQuantity = accessory.quantity - claimQuantity;

        document.getElementById('claimAccessoryInfo').textContent =
            `${accessory.code} - ${accessory.brand} ${accessory.models}`;
        document.getElementById('claimAvailableQuantity').textContent =
            `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ñ‡∏•‡∏°‡πÑ‡∏î‡πâ: ${availableQuantity} ‡∏ä‡∏¥‡πâ‡∏ô`;
        document.getElementById('claimQuantity').max = availableQuantity;
        document.getElementById('claimQuantity').value = '';
        document.getElementById('claimAccessoryId').value = accessoryId;

        modal.classList.add('show');
    } catch (error) {
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà');
        console.error(error);
    }
}

// Close claim modal
function closeClaimModal() {
    const modal = document.getElementById('claimAccessoryModal');
    modal.classList.remove('show');
}

// Send accessory to claim
async function sendAccessoryToClaim(event) {
    event.preventDefault();

    const accessoryId = document.getElementById('claimAccessoryId').value;
    const quantity = parseInt(document.getElementById('claimQuantity').value);

    try {
        await API.post(API_ENDPOINTS.accessoryClaim(accessoryId), { quantity });

        loadAccessoriesData();
        closeClaimModal();

        showNotification(`‡∏™‡πà‡∏á‡πÄ‡∏Ñ‡∏•‡∏°‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    } catch (error) {
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
        console.error(error);
    }
}

// ===== DAMAGE ACCESSORY =====

// Open damage modal
async function openDamageModal(accessoryId) {
    try {
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);

        const modal = document.getElementById('damageAccessoryModal');
        const claimQuantity = accessory.claim_quantity || 0;
        // ‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å damageQuantity ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ damage ‡∏à‡∏∞‡∏•‡∏î quantity ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
        const availableQuantity = accessory.quantity - claimQuantity;

        console.log('üìã [openDamageModal] Accessory:', {
            code: accessory.code,
            quantity: accessory.quantity,
            claim_quantity: claimQuantity,
            damage_quantity: accessory.damage_quantity,
            available: availableQuantity
        });

        document.getElementById('damageAccessoryInfo').textContent =
            `${accessory.code} - ${accessory.brand} ${accessory.models}`;
        document.getElementById('damageAvailableQuantity').textContent =
            `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡πÑ‡∏î‡πâ: ${availableQuantity} ‡∏ä‡∏¥‡πâ‡∏ô`;
        document.getElementById('damageQuantity').max = availableQuantity;
        document.getElementById('damageQuantity').value = '';
        document.getElementById('damageDate').value = new Date().toISOString().split('T')[0];
        document.getElementById('damageAccessoryId').value = accessoryId;

        modal.classList.add('show');
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
        console.error(error);
    }
}

// Close damage modal
function closeDamageModal() {
    const modal = document.getElementById('damageAccessoryModal');
    modal.classList.remove('show');
}

// Open edit damage modal
async function openEditDamageModal(accessoryId) {
    try {
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);

        const modal = document.getElementById('editDamageAccessoryModal');
        const damageQuantity = accessory.damage_quantity || 0;

        console.log('üìù [openEditDamageModal] Accessory:', {
            code: accessory.code,
            damage_quantity: damageQuantity,
            damage_date: accessory.damage_date
        });

        document.getElementById('editDamageAccessoryInfo').textContent =
            `${accessory.code} - ${accessory.brand} ${accessory.models}`;
        document.getElementById('editDamageQuantity').value = damageQuantity;
        document.getElementById('editDamageQuantity').max = 9999; // Allow any positive number
        document.getElementById('editDamageDate').value = accessory.damage_date ? 
            new Date(accessory.damage_date).toISOString().split('T')[0] : 
            new Date().toISOString().split('T')[0];
        document.getElementById('editDamageAccessoryId').value = accessoryId;

        modal.classList.add('show');
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
        console.error(error);
    }
}

// Close edit damage modal
function closeEditDamageModal() {
    const modal = document.getElementById('editDamageAccessoryModal');
    modal.classList.remove('show');
}

// Send accessory to damage
async function sendAccessoryToDamage(event) {
    event.preventDefault();

    const accessoryId = document.getElementById('damageAccessoryId').value;
    const quantity = parseInt(document.getElementById('damageQuantity').value);
    const damageDate = document.getElementById('damageDate').value;

    console.log('üî¥ [sendAccessoryToDamage] Marking accessory as damaged:', {
        accessoryId,
        quantity,
        damageDate
    });

    try {
        const result = await API.post(API_ENDPOINTS.accessoryDamage(accessoryId), { 
            quantity,
            damage_date: damageDate
        });

        console.log('‚úÖ [sendAccessoryToDamage] Success:', result);
        
        // Reload data to update stock and damage list
        await loadAccessoriesData();
        
        closeDamageModal();

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
        const remainingQty = result.remaining_quantity || 0;
        let message = `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`;
        if (remainingQty === 0) {
            message += '\n(‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö "‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏´‡∏°‡∏î")';
        } else {
            message += `\n(‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å ${remainingQty} ‡∏ä‡∏¥‡πâ‡∏ô)`;
        }
        
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: message,
            icon: 'success'
        });
    } catch (error) {
        console.error('‚ùå [sendAccessoryToDamage] Error:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Update accessory damage (edit damage quantity and date)
async function updateAccessoryDamage(event) {
    event.preventDefault();

    const accessoryId = document.getElementById('editDamageAccessoryId').value;
    const newQuantity = parseInt(document.getElementById('editDamageQuantity').value);
    const newDate = document.getElementById('editDamageDate').value;

    console.log('‚úèÔ∏è [updateAccessoryDamage] Updating damage info:', {
        accessoryId,
        newQuantity,
        newDate
    });

    if (newQuantity <= 0) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0',
            icon: 'warning'
        });
        return;
    }

    try {
        const result = await API.put(API_ENDPOINTS.accessoryUpdateDamage(accessoryId), { 
            damage_quantity: newQuantity,
            damage_date: newDate
        });

        console.log('‚úÖ [updateAccessoryDamage] Success:', result);
        
        // Reload data to update damage list
        await loadAccessoriesData();
        
        closeEditDamageModal();

        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            icon: 'success'
        });
    } catch (error) {
        console.error('‚ùå [updateAccessoryDamage] Error:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Delete damage accessory (remove from damage list)
async function deleteDamageAccessory(accessoryId) {
    console.log('üóëÔ∏è [deleteDamageAccessory] Starting delete for ID:', accessoryId);
    
    try {
        // Get current accessory data
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);
        console.log('üì¶ [deleteDamageAccessory] Accessory data:', accessory);
        
        if (!accessory) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
                icon: 'error'
            });
            return;
        }

        const damageQuantity = Number(accessory.damage_quantity) || 0;
        console.log('‚ùå [deleteDamageAccessory] Damage quantity:', damageQuantity);
        
        if (damageQuantity === 0) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢',
                message: '‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢',
                icon: 'warning'
            });
            return;
        }

        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢',
            message: '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
            icon: 'warning',
            confirmText: '‡∏•‡∏ö',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType: 'danger',
            list: [
                { icon: 'info', iconSymbol: 'üì¶', text: `‡∏£‡∏´‡∏±‡∏™: ${accessory.code}` },
                { icon: 'info', iconSymbol: 'üì±', text: `${accessory.brand} - ${accessory.models || '-'}` },
                { icon: 'info', iconSymbol: '‚ùå', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢: ${damageQuantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£' }
            ]
        });

        console.log('‚úÖ [deleteDamageAccessory] User confirmed:', confirmed);

        if (confirmed) {
            console.log('üîÑ [deleteDamageAccessory] Calling delete damage API...');
            
            // Use dedicated API endpoint for removing damage
            await API.post(API_ENDPOINTS.accessoryRemoveDamage(accessoryId), {});

            console.log('‚úÖ [deleteDamageAccessory] API call successful');
            
            await loadAccessoriesData();
            showNotification('‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
            console.log(`‚úÖ ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ Accessory ID: ${accessoryId}`);
        }
    } catch (error) {
        console.error('‚ùå [deleteDamageAccessory] Error:', error);
        console.error('Error message:', error.message);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// ===== CUT STOCK MODAL =====

// Open cut stock modal
async function openCutStockModal(accessoryId) {
    try {
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);

        const modal = document.getElementById('cutStockModal');
        const claimQuantity = Number(accessory.claim_quantity) || 0;
        const availableQuantity = Number(accessory.quantity) - claimQuantity;

        // Set accessory info
        document.getElementById('cutStockAccessoryInfo').textContent =
            `${accessory.code} - ${accessory.brand} ${accessory.models}`;
        
        // Set available quantity info
        document.getElementById('cutStockAvailableQuantity').textContent =
            `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡∏î‡πÑ‡∏î‡πâ: ${availableQuantity} ‡∏ä‡∏¥‡πâ‡∏ô`;
        
        // Set default values - DEFAULT TO TRANSFER!
        document.getElementById('cutStockAction').value = 'transfer';
        document.getElementById('cutStockQuantity').max = availableQuantity;
        document.getElementById('cutStockQuantity').value = '1';
        document.getElementById('cutStockPrice').value = accessory.repair_price || accessory.cost_price;
        document.getElementById('cutStockDate').value = new Date().toISOString().split('T')[0];
        document.getElementById('cutStockNote').value = '';
        document.getElementById('cutStockAccessoryId').value = accessoryId;
        
        // Filter target store options (exclude current store)
        const targetStoreSelect = document.getElementById('cutStockTargetStore');
        targetStoreSelect.innerHTML = '<option value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á</option>';
        if (accessory.store !== 'salaya') {
            targetStoreSelect.innerHTML += '<option value="salaya">‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤</option>';
        }
        if (accessory.store !== 'klongyong') {
            targetStoreSelect.innerHTML += '<option value="klongyong">‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á</option>';
        }
        
        // Auto-select first available store as default
        const firstOption = targetStoreSelect.options[1]; // Skip the placeholder option
        if (firstOption) {
            firstOption.selected = true;
        }

        // Reset UI - this will show transfer options by default
        toggleTransferOptions();

        modal.classList.add('show');
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
        console.error(error);
    }
}

// Toggle transfer options based on action
function toggleTransferOptions() {
    const action = document.getElementById('cutStockAction').value;
    const transferGroup = document.getElementById('transferStoreGroup');
    const cutPriceGroup = document.getElementById('cutPriceGroup');
    const targetStoreSelect = document.getElementById('cutStockTargetStore');
    const submitBtn = document.getElementById('cutStockSubmitBtn');
    
    if (action === 'transfer') {
        transferGroup.style.display = 'block';
        cutPriceGroup.style.display = 'none';
        targetStoreSelect.required = true;
        document.getElementById('cutStockPrice').required = false;
        submitBtn.textContent = '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà';
    } else {
        transferGroup.style.display = 'none';
        cutPriceGroup.style.display = 'block';
        targetStoreSelect.required = false;
        document.getElementById('cutStockPrice').required = true;
        submitBtn.textContent = '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà';
    }
}

// Close cut stock modal
function closeCutStockModal() {
    const modal = document.getElementById('cutStockModal');
    modal.classList.remove('show');
}

// Save cut stock
async function saveCutStock(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const accessoryId = formData.get('accessoryId');
    const action = formData.get('action');
    const quantity = parseInt(formData.get('quantity'));
    const price = parseFloat(formData.get('price')) || 0;
    const date = formData.get('date');
    const note = formData.get('note') || '';
    const targetStore = formData.get('targetStore');

    console.log('üîß [saveCutStock] START - Form data:', {
        accessoryId,
        action,
        quantity,
        price,
        date,
        note,
        targetStore
    });

    try {
        // Get current accessory data
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);

        if (!accessory) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà',
                icon: 'error'
            });
            return;
        }

        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
        const claimQuantity = Number(accessory.claim_quantity) || 0;
        const availableQuantity = Number(accessory.quantity) - claimQuantity;

        console.log(`[saveCutStock] Action: ${action}, Accessory: ${accessory.code}, quantity=${accessory.quantity}, claim=${claimQuantity}, available=${availableQuantity}`);

        // Validate quantity
        if (quantity <= 0) {
            await customAlert({
                title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                icon: 'warning'
            });
            return;
        }

        if (quantity > availableQuantity) {
            await customAlert({
                title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠',
                message: `‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏°‡∏µ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ (‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà ${availableQuantity} ‡∏ä‡∏¥‡πâ‡∏ô, ‡∏™‡πà‡∏á‡πÄ‡∏Ñ‡∏•‡∏°‡πÑ‡∏õ ${claimQuantity} ‡∏ä‡∏¥‡πâ‡∏ô)`,
                icon: 'warning'
            });
            return;
        }

        // Validate target store for transfer
        if (action === 'transfer' && !targetStore) {
            await customAlert({
                title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô',
                message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á',
                icon: 'warning'
            });
            return;
        }

        // Handle based on action
        if (action === 'transfer') {
            // ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô
            const targetStoreName = targetStore === 'salaya' ? '‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
            const sourceStoreName = accessory.store === 'salaya' ? '‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
            
            const confirmed = await customConfirm({
                title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà',
                message: '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
                icon: 'question',
                confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
                cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
                list: [
                    { icon: 'info', iconSymbol: 'üì¶', text: `${accessory.code} - ${accessory.brand} ${accessory.models}` },
                    { icon: 'info', iconSymbol: 'üî¢', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                    { icon: 'info', iconSymbol: 'üè™', text: `‡∏à‡∏≤‡∏Å: ${sourceStoreName}` },
                    { icon: 'info', iconSymbol: 'üè™', text: `‡πÑ‡∏õ: ${targetStoreName}` },
                    { icon: 'info', iconSymbol: 'üìÖ', text: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${formatDate(date)}` },
                    ...(note ? [{ icon: 'info', iconSymbol: 'üìù', text: `‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ${note}` }] : [])
                ]
            });

            if (!confirmed) return;

            try {
                console.log('üöÄüöÄüöÄ [TRANSFER v20251112d - WITH ID] Starting transfer process...');
                console.log('üìã [TRANSFER] Accessory:', accessory);
                console.log('üìã [TRANSFER] Quantity to transfer:', quantity);
                console.log('üìã [TRANSFER] Target store:', targetStore);

                // ‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° cut_quantity ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢ ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î)
                const newQuantity = Number(accessory.quantity) - quantity;
                console.log('üìâ [TRANSFER] Step 1: Reducing source store quantity:', {
                    accessoryId,
                    oldQuantity: accessory.quantity,
                    newQuantity,
                    transferredQuantity: quantity
                });

                await API.put(`${API_ENDPOINTS.accessories}/${accessoryId}`, {
                    type: accessory.type,
                    code: accessory.code,
                    brand: accessory.brand,
                    models: accessory.models,
                    quantity: newQuantity,
                    cost_price: accessory.cost_price,
                    repair_price: accessory.repair_price,
                    import_date: accessory.import_date,
                    claim_quantity: accessory.claim_quantity,
                    cut_quantity: accessory.cut_quantity || 0,
                    cut_price: accessory.cut_price || null,
                    cut_date: accessory.cut_date || null,
                    note: accessory.note ? `${accessory.note}\n‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ ${targetStoreName} ${date}: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` : `‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ ${targetStoreName} ${date}: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô`,
                    store: accessory.store
                });
                console.log('‚úÖ [TRANSFER] Step 1 completed: Source store updated');

                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ä‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                console.log('üîç [TRANSFER] Step 2: Checking existing accessories at target store');
                const targetAccessories = await API.get(API_ENDPOINTS.accessories, { store: targetStore });
                console.log('üì¶ [TRANSFER] Target store accessories:', targetAccessories.length);
                
                const existingAccessory = targetAccessories.find(a => 
                    a.type === accessory.type &&
                    a.code === accessory.code &&
                    a.brand === accessory.brand &&
                    a.models === accessory.models
                );
                
                if (existingAccessory) {
                    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô
                    console.log('‚úèÔ∏è [TRANSFER] Found existing accessory, updating quantity:', existingAccessory);
                    const updatedQuantity = Number(existingAccessory.quantity) + quantity;
                    await API.put(`${API_ENDPOINTS.accessories}/${existingAccessory.id}`, {
                        type: existingAccessory.type,
                        code: existingAccessory.code,
                        brand: existingAccessory.brand,
                        models: existingAccessory.models,
                        quantity: updatedQuantity,
                        cost_price: existingAccessory.cost_price,
                        repair_price: existingAccessory.repair_price,
                        import_date: existingAccessory.import_date,
                        claim_quantity: existingAccessory.claim_quantity || 0,
                        cut_quantity: existingAccessory.cut_quantity || 0,
                        note: existingAccessory.note ? `${existingAccessory.note}\n‡∏¢‡πâ‡∏≤‡∏¢‡∏à‡∏≤‡∏Å ${sourceStoreName} ${date}: +${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` : `‡∏¢‡πâ‡∏≤‡∏¢‡∏à‡∏≤‡∏Å ${sourceStoreName} ${date}: +${quantity} ‡∏ä‡∏¥‡πâ‡∏ô`,
                        store: targetStore
                    });
                    console.log('‚úÖ [TRANSFER] Existing accessory updated. New quantity:', updatedQuantity);
                } else {
                    // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
                    console.log('‚ûï [TRANSFER] No existing accessory found, creating new one');
                    const newAccessoryId = 'ACC' + Date.now();
                    const newAccessoryData = {
                        id: newAccessoryId,
                        type: accessory.type,
                        code: accessory.code,
                        brand: accessory.brand,
                        models: accessory.models,
                        quantity: quantity,
                        cost_price: accessory.cost_price,
                        repair_price: accessory.repair_price,
                        import_date: date,
                        claim_quantity: 0,
                        cut_quantity: 0,
                        note: `‡∏¢‡πâ‡∏≤‡∏¢‡∏à‡∏≤‡∏Å ${sourceStoreName} ${date}` + (note ? `\n${note}` : ''),
                        store: targetStore
                    };
                    console.log('‚ûï [TRANSFER] New accessory data:', newAccessoryData);

                    const createResult = await API.post(API_ENDPOINTS.accessories, newAccessoryData);
                    console.log('‚úÖ [TRANSFER] Step 2 completed: New accessory created:', createResult);
                }
            } catch (transferError) {
                console.error('‚ùå [TRANSFER] Error during transfer:', transferError);
                await customAlert({
                    title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                    message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ: ${transferError.message}`,
                    icon: 'error',
                    confirmType: 'danger'
                });
                return;
            }

            closeCutStockModal();

            // ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏´‡πâ‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏î‡∏π‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
            const confirmResult = await customConfirm({
                title: '‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                message: `‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏à‡∏≤‡∏Å ${sourceStoreName} ‡πÑ‡∏õ ${targetStoreName} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß\n\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`,
                icon: 'success',
                confirmText: `‡∏î‡∏π‡∏ó‡∏µ‡πà ${targetStoreName}`,
                cancelText: '‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà',
                list: [
                    { icon: 'info', iconSymbol: 'üì¶', text: `${accessory.code} - ${accessory.brand} ${accessory.models}` },
                    { icon: 'info', iconSymbol: 'üî¢', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                    { icon: 'success', iconSymbol: '‚úÖ', text: `‡∏¢‡πâ‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à` }
                ]
            });

            if (confirmResult) {
                // ‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
                currentStore = targetStore;
                localStorage.setItem('currentStore', targetStore);
                
                // Update store display in header
                const storeNameElement = document.querySelector('.store-name');
                if (storeNameElement) {
                    storeNameElement.textContent = targetStoreName;
                }
                
                // Update active store button
                document.querySelectorAll('.store-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-store') === targetStore) {
                        btn.classList.add('active');
                    }
                });
                
                showNotification(`‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡∏î‡∏π ${targetStoreName}`);
            }
            
            // ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà
            loadAccessoriesData();

            console.log('‚úÖ [saveCutStock] Transfer completed successfully');
            return; // ‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å transfer ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à

        } else if (action === 'cut') {
            // ‡∏ï‡∏±‡∏î‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏£‡πâ‡∏≤‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
            console.log('‚úÇÔ∏è [saveCutStock] Cutting for own store');
            const confirmed = await customConfirm({
                title: '‚ö†Ô∏è ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡πâ‡∏≤‡∏ô)',
                message: 'üî¥ ‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏™‡∏ï‡πá‡∏≠‡∏Å ‡πÅ‡∏ï‡πà‡∏à‡∏∞**‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô**\n\n‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô" ‡πÅ‡∏ó‡∏ô',
                icon: 'warning',
                confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏î (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡πâ‡∏≤‡∏ô)',
                cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
                list: [
                    { icon: 'info', iconSymbol: 'üì¶', text: `${accessory.code} - ${accessory.brand} ${accessory.models}` },
                    { icon: 'info', iconSymbol: 'üî¢', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                    { icon: 'info', iconSymbol: 'üí∞', text: `‡∏£‡∏≤‡∏Ñ‡∏≤: ${formatCurrency(price)}` },
                    { icon: 'info', iconSymbol: 'üìÖ', text: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${formatDate(date)}` },
                    { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: `‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô!` },
                    ...(note ? [{ icon: 'info', iconSymbol: 'üìù', text: `‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ${note}` }] : [])
                ]
            });

            if (!confirmed) return;

            // Call API to cut accessory
            const result = await API.post(API_ENDPOINTS.accessoryCut(accessoryId), {
                quantity: quantity,
                price: price,
                date: date,
                note: note
            });

            console.log(`[saveCutStock] Cut result:`, result);

            loadAccessoriesData();
            closeCutStockModal();
            
            if (result && result.remaining !== undefined) {
                showNotification(`‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏£‡∏≤‡∏Ñ‡∏≤ ${formatCurrency(price)}) ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${result.remaining}`);
            } else {
                showNotification(`‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏£‡∏≤‡∏Ñ‡∏≤ ${formatCurrency(price)})`);
            }
        } else {
            // action ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
            console.error('‚ùå [saveCutStock] Invalid action:', action);
            await customAlert({
                title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                message: `‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ${action}`,
                icon: 'error'
            });
        }
    } catch (error) {
        console.error('‚ùå [saveCutStock] Error:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Edit cut accessory
async function editCutAccessory(accessoryId) {
    try {
        console.log(`[editCutAccessory] Opening edit modal for accessory ID: ${accessoryId}`);
        
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);
        
        if (!accessory || !accessory.cut_quantity || accessory.cut_quantity === 0) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ô‡∏µ‡πâ',
                icon: 'error',
                confirmType: 'danger'
            });
            return;
        }
        
        // Fill form with current data
        document.getElementById('editCutAccessoryId').value = accessory.id;
        document.getElementById('editCutAccessoryInfo').textContent = 
            `${accessory.code} - ${getAccessoryTypeName(accessory.type)} - ${accessory.brand} ${accessory.models}`;
        document.getElementById('editCutQuantity').value = accessory.cut_quantity;
        document.getElementById('editCutPrice').value = accessory.repair_price || accessory.repairPrice;
        document.getElementById('editCutDate').value = accessory.cut_date || accessory.cutDate || getTodayDate();
        document.getElementById('editCutNote').value = accessory.note || '';
        
        // Show modal
        document.getElementById('editCutAccessoryModal').classList.add('show');
        
        console.log(`[editCutAccessory] Modal opened for:`, accessory);
    } catch (error) {
        console.error('Error opening edit cut accessory modal:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ',
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Close edit cut accessory modal
function closeEditCutAccessoryModal() {
    document.getElementById('editCutAccessoryModal').classList.remove('show');
    document.getElementById('editCutAccessoryForm').reset();
}

// Save edited cut accessory
async function saveEditCutAccessory(event) {
    event.preventDefault();
    
    const formData = new FormData(event.target);
    const accessoryId = formData.get('accessoryId');
    const quantity = parseInt(formData.get('quantity'));
    const price = parseFloat(formData.get('price'));
    const date = formData.get('date');
    const note = formData.get('note');
    
    console.log(`[saveEditCutAccessory] Updating cut:`, { accessoryId, quantity, price, date, note });
    
    try {
        // Update cut accessory data
        const result = await API.put(`${API_ENDPOINTS.accessories}/${accessoryId}/cut`, {
            cut_quantity: quantity,
            repair_price: price,
            cut_date: date,
            note: note
        });
        
        console.log(`[saveEditCutAccessory] Update result:`, result);
        
        loadAccessoriesData();
        closeEditCutAccessoryModal();
        
        showNotification(`‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    } catch (error) {
        console.error('Error updating cut accessory:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Delete cut accessory (revert cut)
async function deleteCutAccessory(accessoryId) {
    try {
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);
        
        if (!accessory || !accessory.cut_quantity || accessory.cut_quantity === 0) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÑ‡∏î‡πâ',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏ô‡∏µ‡πâ',
                icon: 'error',
                confirmType: 'danger'
            });
            return;
        }
        
        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
            message: `‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà ${accessory.code} (${accessory.cut_quantity} ‡∏ä‡∏¥‡πâ‡∏ô) ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n\n` +
                    `‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏à‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏™‡∏ï‡πá‡∏≠‡∏Å`,
            confirmText: '‡∏•‡∏ö',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
            confirmType: 'danger'
        });
        
        if (!confirmed) return;
        
        console.log(`[deleteCutAccessory] Deleting cut for accessory ID: ${accessoryId}`);
        
        // Delete cut (revert to stock)
        await API.delete(`${API_ENDPOINTS.accessories}/${accessoryId}/cut`);
        
        loadAccessoriesData();
        
        showNotification(`‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏Ñ‡∏∑‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏ï‡πá‡∏≠‡∏Å ${accessory.cut_quantity} ‡∏ä‡∏¥‡πâ‡∏ô)`);
    } catch (error) {
        console.error('Error deleting cut accessory:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Open return stock modal
async function openReturnStockModal(accessoryId) {
    try {
        const accessory = await API.get(`${API_ENDPOINTS.accessories}/${accessoryId}`);

        const modal = document.getElementById('returnStockModal');
        const claimQuantity = accessory.claim_quantity || 0;

        document.getElementById('returnAccessoryInfo').textContent =
            `${accessory.code} - ${accessory.brand} ${accessory.models}`;
        document.getElementById('returnClaimQuantity').textContent =
            `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡πÄ‡∏Ñ‡∏•‡∏°: ${claimQuantity} ‡∏ä‡∏¥‡πâ‡∏ô`;
        document.getElementById('returnQuantity').max = claimQuantity;
        document.getElementById('returnQuantity').value = '';
        document.getElementById('returnAccessoryId').value = accessoryId;

        modal.classList.add('show');
    } catch (error) {
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà');
        console.error(error);
    }
}

// Close return stock modal
function closeReturnStockModal() {
    const modal = document.getElementById('returnStockModal');
    modal.classList.remove('show');
}

// Return accessory to stock
async function returnAccessoryToStock(event) {
    event.preventDefault();

    const accessoryId = document.getElementById('returnAccessoryId').value;
    const quantity = parseInt(document.getElementById('returnQuantity').value);

    try {
        await API.post(API_ENDPOINTS.accessoryReturnStock(accessoryId), { quantity });

        loadAccessoriesData();
        closeReturnStockModal();

        showNotification(`‡∏Ñ‡∏∑‡∏ô‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`);
    } catch (error) {
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
        console.error(error);
    }
}

// ===== EXPENSES MANAGEMENT =====

// Initialize expense month selector
function initializeExpenseMonthSelector() {
    const monthSelect = document.getElementById('expenseMonthSelect');
    if (!monthSelect) return;

    // Generate last 12 months
    const months = [];
    const today = new Date();

    for (let i = 0; i < 12; i++) {
        const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const yearMonth = date.toISOString().slice(0, 7);
        const year = date.getFullYear();
        const month = date.getMonth();

        months.push({
            value: yearMonth,
            label: `${thaiMonths[month]} ${year}` // ‡πÅ‡∏™‡∏î‡∏á ‡∏Ñ.‡∏®.
        });
    }

    // Populate month selector
    monthSelect.innerHTML = months.map(m =>
        `<option value="${m.value}">${m.label}</option>`
    ).join('');

    // Set current month as selected
    monthSelect.value = currentMonth;

    // Add change event listener
    monthSelect.addEventListener('change', function() {
        currentMonth = this.value;
        loadExpenseData();
        loadExpenseTable(); // Reload expense table when month changes
    });
}

// Load and calculate expense data
function loadExpenseData() {
    const selectedMonth = document.getElementById('expenseMonthSelect')?.value || currentMonth;
    
    // Calculate expenses for each category
    const newDevicesExpense = calculateNewDevicesExpense(selectedMonth);
    const usedDevicesExpense = calculateUsedDevicesExpense(selectedMonth);
    const pawnExpense = calculatePawnExpense(selectedMonth);
    const accessoriesExpense = calculateAccessoriesExpense(selectedMonth);
    
    // Update summary cards
    updateExpenseSummary(newDevicesExpense, usedDevicesExpense, pawnExpense, accessoriesExpense);
    
    // Update expense details table
    updateExpenseDetailsTable(selectedMonth);
}

// Calculate new devices expense (purchase prices) - All stores
function calculateNewDevicesExpense(month) {
    // Get all devices from all stores
    const allDevices = newDevices;
    
    if (month) {
        const filteredDevices = allDevices.filter(device => {
            const deviceDate = new Date(device.importDate);
            const deviceMonth = deviceDate.toISOString().slice(0, 7);
            return deviceMonth === month;
        });
        return filteredDevices.reduce((sum, device) => sum + device.purchasePrice, 0);
    }
    
    return allDevices.reduce((sum, device) => sum + device.purchasePrice, 0);
}

// Calculate used devices expense (purchase prices) - All stores
function calculateUsedDevicesExpense(month) {
    // Get all devices from all stores
    const allDevices = usedDevices;
    
    if (month) {
        const filteredDevices = allDevices.filter(device => {
            const deviceDate = new Date(device.purchaseDate);
            const deviceMonth = deviceDate.toISOString().slice(0, 7);
            return deviceMonth === month;
        });
        return filteredDevices.reduce((sum, device) => sum + device.purchasePrice, 0);
    }
    
    return allDevices.reduce((sum, device) => sum + device.purchasePrice, 0);
}

// Calculate pawn expense (pawn amounts) - All stores
function calculatePawnExpense(month) {
    // Get all pawns from all stores
    const allPawns = pawnDevices;
    
    if (month) {
        const filteredPawns = allPawns.filter(pawn => {
            const pawnDate = new Date(pawn.receiveDate);
            const pawnMonth = pawnDate.toISOString().slice(0, 7);
            return pawnMonth === month;
        });
        return filteredPawns.reduce((sum, pawn) => sum + pawn.pawnAmount, 0);
    }
    
    return allPawns.reduce((sum, pawn) => sum + pawn.pawnAmount, 0);
}

// Calculate accessories expense (cost prices) - All stores
function calculateAccessoriesExpense(month) {
    // Get all accessories from all stores
    const allAccessories = accessories;
    
    if (month) {
        const filteredAccessories = allAccessories.filter(accessory => {
            const accessoryDate = new Date(accessory.importDate);
            const accessoryMonth = accessoryDate.toISOString().slice(0, 7);
            return accessoryMonth === month;
        });
        return filteredAccessories.reduce((sum, accessory) => sum + (accessory.costPrice * accessory.quantity), 0);
    }
    
    return allAccessories.reduce((sum, accessory) => sum + (accessory.costPrice * accessory.quantity), 0);
}

// Update expense summary cards
function updateExpenseSummary(newDevicesExpense, usedDevicesExpense, pawnExpense, accessoriesExpense) {
    const totalExpense = newDevicesExpense + usedDevicesExpense + pawnExpense + accessoriesExpense;
    
    // Update individual cards
    const newDevicesExpenseElement = document.getElementById('newDevicesExpense');
    const usedDevicesExpenseElement = document.getElementById('usedDevicesExpense');
    const pawnExpenseElement = document.getElementById('pawnExpense');
    const accessoriesExpenseElement = document.getElementById('accessoriesExpense');
    const totalExpenseElement = document.getElementById('totalExpenseAmount');
    
    if (newDevicesExpenseElement) newDevicesExpenseElement.textContent = formatCurrency(newDevicesExpense);
    if (usedDevicesExpenseElement) usedDevicesExpenseElement.textContent = formatCurrency(usedDevicesExpense);
    if (pawnExpenseElement) pawnExpenseElement.textContent = formatCurrency(pawnExpense);
    if (accessoriesExpenseElement) accessoriesExpenseElement.textContent = formatCurrency(accessoriesExpense);
    if (totalExpenseElement) totalExpenseElement.textContent = formatCurrency(totalExpense);
}

// Update expense details table - All stores
function updateExpenseDetailsTable(month) {
    const tbody = document.getElementById('expenseDetailsTableBody');
    if (!tbody) return;
    
    const expenseDetails = [];
    
    // New devices expenses - All stores
    const allNewDevices = newDevices;
    const filteredNewDevices = month ? allNewDevices.filter(device => {
        const deviceDate = new Date(device.importDate);
        const deviceMonth = deviceDate.toISOString().slice(0, 7);
        return deviceMonth === month;
    }) : allNewDevices;
    
    filteredNewDevices.forEach(device => {
        const storeName = stores[device.store] || device.store;
        expenseDetails.push({
            category: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà',
            item: `${device.brand} ${device.model} (${device.color})`,
            amount: device.purchasePrice,
            date: device.importDate,
            note: `${storeName} - IMEI: ${device.imei}`
        });
    });
    
    // Used devices expenses - All stores
    const allUsedDevices = usedDevices;
    const filteredUsedDevices = month ? allUsedDevices.filter(device => {
        const deviceDate = new Date(device.purchaseDate);
        const deviceMonth = deviceDate.toISOString().slice(0, 7);
        return deviceMonth === month;
    }) : allUsedDevices;
    
    filteredUsedDevices.forEach(device => {
        const storeName = stores[device.store] || device.store;
        expenseDetails.push({
            category: '‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≠‡∏á',
            item: `${device.brand} ${device.model} (${device.color})`,
            amount: device.purchasePrice,
            date: device.purchaseDate,
            note: `${storeName} - ‡∏™‡∏†‡∏≤‡∏û: ${device.condition}`
        });
    });
    
    // Pawn expenses - All stores
    const allPawns = pawnDevices;
    const filteredPawns = month ? allPawns.filter(pawn => {
        const pawnDate = new Date(pawn.receiveDate);
        const pawnMonth = pawnDate.toISOString().slice(0, 7);
        return pawnMonth === month;
    }) : allPawns;
    
    filteredPawns.forEach(pawn => {
        const storeName = stores[pawn.store] || pawn.store;
        expenseDetails.push({
            category: '‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≤‡∏¢‡∏ù‡∏≤‡∏Å',
            item: `${pawn.brand} ${pawn.model} (${pawn.color})`,
            amount: pawn.pawnAmount,
            date: pawn.receiveDate,
            note: `${storeName} - ‡∏î‡∏≠‡∏Å‡πÄ‡∏ö‡∏µ‡πâ‡∏¢: ${formatCurrency(pawn.interest)}`
        });
    });
    
    // Accessories expenses - All stores
    const allAccessories = accessories;
    const filteredAccessories = month ? allAccessories.filter(accessory => {
        const accessoryDate = new Date(accessory.importDate);
        const accessoryMonth = accessoryDate.toISOString().slice(0, 7);
        return accessoryMonth === month;
    }) : allAccessories;
    
    filteredAccessories.forEach(accessory => {
        const storeName = stores[accessory.store] || accessory.store;
        const totalCost = accessory.costPrice * accessory.quantity;
        expenseDetails.push({
            category: '‡∏Ñ‡πà‡∏≤‡∏≠‡∏∞‡πÑ‡∏´‡∏•‡πà',
            item: `${accessory.code} - ${accessory.brand} (${accessory.models})`,
            amount: totalCost,
            date: accessory.importDate,
            note: `${storeName} - ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${accessory.quantity} ‡∏ä‡∏¥‡πâ‡∏ô`
        });
    });
    
    // Sort by date (newest first)
    expenseDetails.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    // Display in table
    if (expenseDetails.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
    } else {
        tbody.innerHTML = expenseDetails.map(expense => `
            <tr>
                <td><span class="expense-category">${expense.category}</span></td>
                <td>${expense.item}</td>
                <td class="expense-amount-cell">${formatCurrency(expense.amount)}</td>
                <td>${formatDate(expense.date)}</td>
                <td>${expense.note}</td>
            </tr>
        `).join('');
    }
}

// Initialize expense card clicks
function initializeExpenseCardClicks() {
    const expenseCards = document.querySelectorAll('.expense-summary-card');
    
    expenseCards.forEach(card => {
        card.addEventListener('click', function() {
            const category = this.getAttribute('data-category');
            showExpenseDetail(category);
        });
    });
}

// Show expense detail page
function showExpenseDetail(category) {
    // Hide main expense page
    const expenseMain = document.querySelector('#expenses .expense-summary-section, #expenses .expense-controls, #expenses .expense-details-section');
    if (expenseMain) {
        expenseMain.style.display = 'none';
    }
    
    // Show detail page
    const detailPage = document.getElementById(`${category}-detail`);
    if (detailPage) {
        detailPage.classList.add('active');
        loadExpenseDetailData(category);
    }
}

// Show expense main page
function showExpenseMain() {
    // Hide all detail pages
    const detailPages = document.querySelectorAll('.expense-detail-page');
    detailPages.forEach(page => {
        page.classList.remove('active');
    });
    
    // Show main expense page
    const expenseMain = document.querySelector('#expenses .expense-summary-section, #expenses .expense-controls, #expenses .expense-details-section');
    if (expenseMain) {
        expenseMain.style.display = 'block';
    }
}

// Load expense detail data
function loadExpenseDetailData(category) {
    const selectedMonth = document.getElementById('expenseMonthSelect')?.value || '';
    
    switch(category) {
        case 'new-devices':
            loadNewDevicesDetail(selectedMonth);
            break;
        case 'used-devices':
            loadUsedDevicesDetail(selectedMonth);
            break;
        case 'pawn':
            loadPawnDetail(selectedMonth);
            break;
        case 'accessories':
            loadAccessoriesDetail(selectedMonth);
            break;
    }
}

// Load new devices detail
function loadNewDevicesDetail(month) {
    const allDevices = newDevices;
    const filteredDevices = month ? allDevices.filter(device => {
        const deviceDate = new Date(device.importDate);
        const deviceMonth = deviceDate.toISOString().slice(0, 7);
        return deviceMonth === month;
    }) : allDevices;
    
    // Update stats
    const totalAmount = filteredDevices.reduce((sum, device) => sum + device.purchasePrice, 0);
    const totalCount = filteredDevices.length;
    
    document.getElementById('newDevicesTotalAmount').textContent = formatCurrency(totalAmount);
    document.getElementById('newDevicesTotalCount').textContent = totalCount;
    
    // Update table
    const tbody = document.getElementById('newDevicesDetailTableBody');
    if (filteredDevices.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
    } else {
        tbody.innerHTML = filteredDevices.map(device => {
            const storeName = stores[device.store] || device.store;
            return `
                <tr>
                    <td>${storeName}</td>
                    <td>${device.brand} ${device.model} (${device.color})</td>
                    <td class="expense-amount-cell">${formatCurrency(device.purchasePrice)}</td>
                    <td>${formatDate(device.importDate)}</td>
                    <td>${device.imei}</td>
                </tr>
            `;
        }).join('');
    }
}

// Load used devices detail
function loadUsedDevicesDetail(month) {
    const allDevices = usedDevices;
    const filteredDevices = month ? allDevices.filter(device => {
        const deviceDate = new Date(device.purchaseDate);
        const deviceMonth = deviceDate.toISOString().slice(0, 7);
        return deviceMonth === month;
    }) : allDevices;
    
    // Update stats
    const totalAmount = filteredDevices.reduce((sum, device) => sum + device.purchasePrice, 0);
    const totalCount = filteredDevices.length;
    
    document.getElementById('usedDevicesTotalAmount').textContent = formatCurrency(totalAmount);
    document.getElementById('usedDevicesTotalCount').textContent = totalCount;
    
    // Update table
    const tbody = document.getElementById('usedDevicesDetailTableBody');
    if (filteredDevices.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
    } else {
        tbody.innerHTML = filteredDevices.map(device => {
            const storeName = stores[device.store] || device.store;
            return `
                <tr>
                    <td>${storeName}</td>
                    <td>${device.brand} ${device.model} (${device.color})</td>
                    <td class="expense-amount-cell">${formatCurrency(device.purchasePrice)}</td>
                    <td>${formatDate(device.purchaseDate)}</td>
                    <td>${device.condition}</td>
                </tr>
            `;
        }).join('');
    }
}

// Load pawn detail
function loadPawnDetail(month) {
    const allPawns = pawnDevices;
    const filteredPawns = month ? allPawns.filter(pawn => {
        const pawnDate = new Date(pawn.receiveDate);
        const pawnMonth = pawnDate.toISOString().slice(0, 7);
        return pawnMonth === month;
    }) : allPawns;
    
    // Update stats
    const totalAmount = filteredPawns.reduce((sum, pawn) => sum + pawn.pawnAmount, 0);
    const totalCount = filteredPawns.length;
    
    document.getElementById('pawnTotalAmount').textContent = formatCurrency(totalAmount);
    document.getElementById('pawnTotalCount').textContent = totalCount;
    
    // Update table
    const tbody = document.getElementById('pawnDetailTableBody');
    if (filteredPawns.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
    } else {
        tbody.innerHTML = filteredPawns.map(pawn => {
            const storeName = stores[pawn.store] || pawn.store;
            const interestMethod = (pawn.interestCollectionMethod || pawn.interest_collection_method) === 'deducted' ? '‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å' : '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å‡∏î‡∏≠‡∏Å';
            const redemptionAmount = pawn.redemptionAmount || pawn.redemption_amount || 0;
            return `
                <tr>
                    <td>${storeName}</td>
                    <td>${pawn.brand} ${pawn.model} (${pawn.color})</td>
                    <td class="expense-amount-cell">${formatCurrency(pawn.pawnAmount)}</td>
                    <td>${formatDate(pawn.receiveDate)}</td>
                    <td>${formatCurrency(pawn.interest)}</td>
                    <td>${interestMethod}</td>
                    <td>${formatCurrency(redemptionAmount)}</td>
                </tr>
            `;
        }).join('');
    }
}

// Load accessories detail
function loadAccessoriesDetail(month) {
    const allAccessories = accessories;
    const filteredAccessories = month ? allAccessories.filter(accessory => {
        const accessoryDate = new Date(accessory.importDate);
        const accessoryMonth = accessoryDate.toISOString().slice(0, 7);
        return accessoryMonth === month;
    }) : allAccessories;
    
    // Update stats
    const totalAmount = filteredAccessories.reduce((sum, accessory) => sum + (accessory.costPrice * accessory.quantity), 0);
    const totalCount = filteredAccessories.length;
    
    document.getElementById('accessoriesTotalAmount').textContent = formatCurrency(totalAmount);
    document.getElementById('accessoriesTotalCount').textContent = totalCount;
    
    // Update table
    const tbody = document.getElementById('accessoriesDetailTableBody');
    if (filteredAccessories.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
    } else {
        tbody.innerHTML = filteredAccessories.map(accessory => {
            const storeName = stores[accessory.store] || accessory.store;
            const costPrice = parseFloat(accessory.costPrice) || 0;
            const quantity = parseInt(accessory.quantity) || 0;
            const totalCost = costPrice * quantity;
            return `
                <tr>
                    <td>${storeName}</td>
                    <td>${accessory.code} - ${accessory.brand} (${accessory.models})</td>
                    <td style="text-align: right;">${formatCurrency(costPrice)}</td>
                    <td style="text-align: center;"><strong>${quantity}</strong></td>
                    <td class="expense-amount-cell" style="text-align: right;"><strong>${formatCurrency(totalCost)}</strong></td>
                    <td>${formatDate(accessory.importDate)}</td>
                </tr>
            `;
        }).join('');
    }
}

// ===== Settings: Notifications =====
function loadNotificationSettings() {
    // Load saved settings from localStorage
    const settings = {
        notifyPawnDue: localStorage.getItem('notifyPawnDue') !== 'false',
        notifyInstallmentDue: localStorage.getItem('notifyInstallmentDue') !== 'false',
        notifyRepairComplete: localStorage.getItem('notifyRepairComplete') !== 'false',
        notifyDailySales: localStorage.getItem('notifyDailySales') === 'true',
        notifyMonthlySales: localStorage.getItem('notifyMonthlySales') === 'true',
        notifyLowStock: localStorage.getItem('notifyLowStock') !== 'false'
    };

    // Update checkboxes
    Object.keys(settings).forEach(key => {
        const checkbox = document.getElementById(key);
        if (checkbox) {
            checkbox.checked = settings[key];
        }
    });
}

function saveNotificationSettings() {
    // Get all checkbox values
    const settings = {
        notifyPawnDue: document.getElementById('notifyPawnDue').checked,
        notifyInstallmentDue: document.getElementById('notifyInstallmentDue').checked,
        notifyRepairComplete: document.getElementById('notifyRepairComplete').checked,
        notifyDailySales: document.getElementById('notifyDailySales').checked,
        notifyMonthlySales: document.getElementById('notifyMonthlySales').checked,
        notifyLowStock: document.getElementById('notifyLowStock').checked
    };

    // Save to localStorage
    Object.keys(settings).forEach(key => {
        localStorage.setItem(key, settings[key]);
    });

    alert('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
}

// ===== Settings: Employees =====
let employees = [];

async function loadEmployeesData() {
    try {
        // ‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å API
        // employees = await API.get(API_ENDPOINTS.employees);
        
        // ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å localStorage ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
        const savedEmployees = localStorage.getItem('employees');
        if (savedEmployees) {
            employees = JSON.parse(savedEmployees);
        }
        
        displayEmployees();
    } catch (error) {
        console.error('Error loading employees:', error);
    }
}

function displayEmployees() {
    const tbody = document.getElementById('employeesTableBody');
    
    if (employees.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="empty-state">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô</td></tr>';
        return;
    }

    tbody.innerHTML = employees.map(emp => {
        const statusBadge = emp.status === 'active' ? 
            '<span class="badge badge-success">‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</span>' : 
            '<span class="badge badge-secondary">‡∏≠‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß</span>';
        
        return `
            <tr>
                <td>${emp.code}</td>
                <td>${emp.name}</td>
                <td>${emp.position}</td>
                <td>${emp.phone}</td>
                <td>${emp.stores || '-'}</td>
                <td>${statusBadge}</td>
                <td>
                    <button class="action-btn btn-edit" onclick="openEmployeeModal('${emp.id}')">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
                    <button class="action-btn btn-delete" onclick="deleteEmployee('${emp.id}')">‡∏•‡∏ö</button>
                </td>
            </tr>
        `;
    }).join('');
}

function openEmployeeModal(employeeId) {
    alert('‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï');
    // TODO: Implement employee modal
}

function deleteEmployee(employeeId) {
    if (confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡∏Ñ‡∏ô‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) {
        employees = employees.filter(emp => emp.id !== employeeId);
        localStorage.setItem('employees', JSON.stringify(employees));
        displayEmployees();
        alert('‡∏•‡∏ö‡∏û‡∏ô‡∏±‡∏Å‡∏á‡∏≤‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
    }
}

// ===== EQUIPMENT MANAGEMENT FUNCTIONS =====
// NOTE: equipmentData, currentEquipmentTab, and BRAND_CATEGORIES are declared at the top of the file (global scope)

// Load equipment data
async function loadEquipmentData() {
    try {
        equipmentData = await API.get(API_ENDPOINTS.equipment);
        
        console.log('üì¶ [loadEquipmentData] Equipment data loaded:', {
            totalCount: equipmentData.length,
            currentStore: localStorage.getItem('currentStore') || 'salaya',
            currentTab: currentEquipmentTab,
            allData: equipmentData.map(e => ({
                id: e.id,
                type: e.type,
                brand: e.brand,
                quantity: e.quantity,
                store: e.store
            }))
        });
        
        // Display current tab
        displayEquipmentByTab(currentEquipmentTab);
        updateEquipmentCounts();
        updateEquipmentDashboard();
    } catch (error) {
        console.error('‚ùå [loadEquipmentData] Error loading equipment:', error);
        equipmentData = [];
        displayEquipmentByTab(currentEquipmentTab);
    }
}

// Switch equipment tab
function switchEquipmentTab(tabName) {
    currentEquipmentTab = tabName;
    
    // Reset charger sub-tab when switching main tabs
    if (tabName === 'charger-set') {
        currentChargerSubTab = 'all';
        // Reset sub-tab active class
        setTimeout(() => {
            document.querySelectorAll('.sub-tab-btn').forEach(btn => btn.classList.remove('active'));
            const allBtn = document.querySelector('.sub-tab-btn[onclick*="all"]');
            if (allBtn) allBtn.classList.add('active');
        }, 0);
    }
    
    // Reset cable sub-tab when switching main tabs
    if (tabName === 'cable') {
        currentCableSubTab = 'all';
        // Reset sub-tab active class
        setTimeout(() => {
            document.querySelectorAll('.sub-tab-btn').forEach(btn => btn.classList.remove('active'));
            const allBtn = document.querySelector('.sub-tab-btn[onclick*="all"]');
            if (allBtn) allBtn.classList.add('active');
        }, 0);
    }
    
    // Reset adapter sub-tab when switching main tabs
    if (tabName === 'adapter') {
        currentAdapterSubTab = 'all';
        // Reset sub-tab active class
        setTimeout(() => {
            document.querySelectorAll('.sub-tab-btn').forEach(btn => btn.classList.remove('active'));
            const allBtn = document.querySelector('.sub-tab-btn[onclick*="all"]');
            if (allBtn) allBtn.classList.add('active');
        }, 0);
    }
    
    // Reset earphone sub-tab when switching main tabs
    if (tabName === 'earphone') {
        currentEarphoneSubTab = 'all';
        // Reset sub-tab active class
        setTimeout(() => {
            document.querySelectorAll('.sub-tab-btn').forEach(btn => btn.classList.remove('active'));
            const allBtn = document.querySelector('.sub-tab-btn[onclick*="all"]');
            if (allBtn) allBtn.classList.add('active');
        }, 0);
    }
    
    // Reset screen-protector sub-tab when switching main tabs
    if (tabName === 'screen-protector') {
        currentScreenProtectorSubTab = 'all';
        currentScreenProtectorBrand = 'all';
        // Reset sub-tab active class
        setTimeout(() => {
            document.querySelectorAll('.sub-tab-btn').forEach(btn => btn.classList.remove('active'));
            const allBtn = document.querySelector('.sub-tab-btn[onclick*="all"]');
            if (allBtn) allBtn.classList.add('active');
        }, 0);
    }
    
    // Reset case sub-tab when switching main tabs
    if (tabName === 'case') {
        currentCaseSubTab = 'all';
        // Reset sub-tab active class
        setTimeout(() => {
            document.querySelectorAll('.sub-tab-btn').forEach(btn => btn.classList.remove('active'));
            const allBtn = document.querySelector('.sub-tab-btn[onclick*="all"]');
            if (allBtn) allBtn.classList.add('active');
        }, 0);
    }
    
    // Remove active class from all tabs
    document.querySelectorAll('#equipment .tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Add active class to clicked tab
    const activeTab = document.querySelector(`[data-tab="equipment-${tabName}"]`);
    if (activeTab) {
        activeTab.classList.add('active');
    }
    
    // Hide all tab contents
    document.querySelectorAll('#equipment .tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Show selected tab content
    const selectedContent = document.getElementById(`equipment-${tabName}`);
    if (selectedContent) {
        selectedContent.classList.add('active');
    }
    
    // Display data for selected tab
    displayEquipmentByTab(tabName);
}

// Toggle brand rows visibility (expand/collapse)
function toggleBrandRows(brandId) {
    const rows = document.querySelectorAll(`tr.brand-item-row[data-brand="${brandId}"]`);
    const icon = document.getElementById(`${brandId}-icon`);

    if (!rows.length) return;

    // Check current state from first row
    const isVisible = rows[0].style.display !== 'none';

    // Toggle all rows
    rows.forEach(row => {
        row.style.display = isVisible ? 'none' : 'table-row';
    });

    // Toggle icon
    if (icon) {
        icon.textContent = isVisible ? '‚ñ∂' : '‚ñº';
    }
}

// Switch charger sub-tab
function switchChargerSubTab(subTab) {
    console.log(`üîÑ [switchChargerSubTab] Switching to: ${subTab}`);
    currentChargerSubTab = subTab;
    
    // Update active class for all sub-tab buttons
    document.querySelectorAll('.sub-tab-btn').forEach(btn => {
        const btnOnclick = btn.getAttribute('onclick');
        const isActive = btnOnclick && btnOnclick.includes(`'${subTab}'`);
        
        if (isActive) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Refresh display to show filtered equipment
    console.log(`üìä [switchChargerSubTab] Refreshing display for charger-set with filter: ${subTab}`);
    displayEquipmentByTab('charger-set');
}

// Switch cable sub-tab
function switchCableSubTab(subTab) {
    console.log(`üîÑ [switchCableSubTab] Switching to: ${subTab}`);
    currentCableSubTab = subTab;
    
    // Update active class for all sub-tab buttons
    document.querySelectorAll('.sub-tab-btn').forEach(btn => {
        const btnOnclick = btn.getAttribute('onclick');
        const isActive = btnOnclick && btnOnclick.includes(`'${subTab}'`);
        
        if (isActive) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Refresh display to show filtered equipment
    console.log(`üìä [switchCableSubTab] Refreshing display for cable with filter: ${subTab}`);
    displayEquipmentByTab('cable');
}

// Switch adapter sub-tab
function switchAdapterSubTab(subTab) {
    console.log(`üîÑ [switchAdapterSubTab] Switching to: ${subTab}`);
    currentAdapterSubTab = subTab;
    
    // Update active class for all sub-tab buttons
    document.querySelectorAll('.sub-tab-btn').forEach(btn => {
        const btnOnclick = btn.getAttribute('onclick');
        const isActive = btnOnclick && btnOnclick.includes(`'${subTab}'`);
        
        if (isActive) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Refresh display to show filtered equipment
    console.log(`üìä [switchAdapterSubTab] Refreshing display for adapter with filter: ${subTab}`);
    displayEquipmentByTab('adapter');
}

// Switch earphone sub-tab
function switchEarphoneSubTab(subTab) {
    console.log(`üîÑ [switchEarphoneSubTab] Switching to: ${subTab}`);
    currentEarphoneSubTab = subTab;
    
    // Update active class for all sub-tab buttons
    document.querySelectorAll('.sub-tab-btn').forEach(btn => {
        const btnOnclick = btn.getAttribute('onclick');
        const isActive = btnOnclick && btnOnclick.includes(`'${subTab}'`);
        
        if (isActive) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Refresh display to show filtered equipment
    console.log(`üìä [switchEarphoneSubTab] Refreshing display for earphone with filter: ${subTab}`);
    displayEquipmentByTab('earphone');
}

// Switch screen-protector sub-tab (‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠: Focus, U&I, etc.)
function switchScreenProtectorSubTab(subTab) {
    console.log(`üîÑ [switchScreenProtectorSubTab] Switching to: ${subTab}`);
    currentScreenProtectorSubTab = subTab;
    
    // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á reset brand filter ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏£‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
    
    // Update active class for all sub-tab buttons (only in second sub-tabs row)
    const allSubTabs = document.querySelectorAll('#equipment-screen-protector .sub-tabs');
    if (allSubTabs.length >= 2) {
        const secondSubTabs = allSubTabs[1]; // ‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 2 (‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠)
        secondSubTabs.querySelectorAll('.sub-tab-btn').forEach(btn => {
            const btnOnclick = btn.getAttribute('onclick');
            const isActive = btnOnclick && btnOnclick.includes(`'${subTab}'`);
            
            if (isActive) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }
    
    // Update counts to reflect the new sub-tab selection
    updateEquipmentCounts();
    
    // Refresh display to show filtered equipment
    console.log(`üìä [switchScreenProtectorSubTab] Refreshing display with brand=${currentScreenProtectorBrand}, subType=${subTab}`);
    displayEquipmentByTab('screen-protector');
}

// Switch screen-protector brand filter (‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö: Apple, Samsung, etc.)
function switchScreenProtectorBrand(brand) {
    console.log(`üîÑ [switchScreenProtectorBrand] Switching to: ${brand}`);
    currentScreenProtectorBrand = brand;
    
    // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á reset sub-tab filter ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏£‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
    
    // Update active class for brand filter buttons
    const brandTabs = document.getElementById('screenProtectorBrandTabs');
    if (brandTabs) {
        brandTabs.querySelectorAll('.sub-tab-btn').forEach(btn => {
            const btnOnclick = btn.getAttribute('onclick');
            const isActive = btnOnclick && btnOnclick.includes(`'${brand}'`);
            
            if (isActive) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }
    
    // Update counts to reflect the new brand selection
    updateEquipmentCounts();
    
    // Refresh display to show filtered equipment
    console.log(`üìä [switchScreenProtectorBrand] Refreshing display with brand=${brand}, subType=${currentScreenProtectorSubTab}`);
    displayEquipmentByTab('screen-protector');
}

// Switch case sub-tab (brand filter)
function switchCaseSubTab(subTab) {
    console.log(`üîÑ [switchCaseSubTab] Switching to: ${subTab}`);
    currentCaseSubTab = subTab;
    
    // Update active class for all sub-tab buttons
    document.querySelectorAll('#equipment-case .sub-tab-btn').forEach(btn => {
        const btnOnclick = btn.getAttribute('onclick');
        const isActive = btnOnclick && btnOnclick.includes(`'${subTab}'`);
        
        if (isActive) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    
    // Refresh display to show filtered equipment
    console.log(`üìä [switchCaseSubTab] Refreshing display for case with filter: ${subTab}`);
    displayEquipmentByTab('case');
}

// Display equipment grouped by brand
function displayEquipmentByTab(tabName) {
    const currentStore = localStorage.getItem('currentStore') || 'salaya';
    
    console.log('üñ•Ô∏è [displayEquipmentByTab] Displaying:', {
        tabName: tabName,
        currentStore: currentStore,
        totalEquipment: equipmentData.length,
        chargerSubTab: currentChargerSubTab
    });
    
    // Filter equipment by type and store
    let filteredEquipment = equipmentData.filter(item => {
        const matchStore = item.store === currentStore;

        // Special handling for outofstock tab
        if (tabName === 'outofstock') {
            const isOutOfStock = item.quantity === 0;
            console.log(`  ${item.code || item.id}: store=${item.store} (match=${matchStore}), qty=${item.quantity} (outofstock=${isOutOfStock})`);
            return matchStore && isOutOfStock;
        }

        // Special handling for damage tab - filter by current month
        if (tabName === 'damage') {
            const damageQuantity = item.damage_quantity || 0;
            const hasDamage = damageQuantity > 0;

            if (!hasDamage) return false;

            // Filter by current month
            const damageDate = item.damage_date;
            if (!damageDate) return false;

            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();

            const date = new Date(damageDate);
            const isCurrentMonth = date.getMonth() + 1 === currentMonth && date.getFullYear() === currentYear;

            console.log(`  ${item.code || item.id}: store=${item.store} (match=${matchStore}), damage_qty=${damageQuantity}, damage_date=${damageDate}, current_month=${isCurrentMonth}`);
            return matchStore && hasDamage && isCurrentMonth;
        }

        const matchType = item.type === tabName;
        const hasQuantity = item.quantity > 0;

        console.log(`  ${item.code || item.id}: store=${item.store} (match=${matchStore}), type=${item.type} (match=${matchType}), qty=${item.quantity} (>0=${hasQuantity})`);

        return matchStore && matchType && hasQuantity;
    });
    
    // Apply charger sub-tab filter if on charger-set tab
    if (tabName === 'charger-set' && currentChargerSubTab !== 'all') {
        console.log(`üîç [displayEquipmentByTab] Applying sub-tab filter: ${currentChargerSubTab}`);
        console.log(`  Before filter: ${filteredEquipment.length} items`);
        
        filteredEquipment = filteredEquipment.filter(item => {
            // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if (item.sub_type) {
                const match = item.sub_type === currentChargerSubTab;
                console.log(`  ${item.code}: sub_type=${item.sub_type}, filter=${currentChargerSubTab}, match=${match}`);
                return match;
            }
            
            // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
            const model = (item.model || '').toLowerCase();
            const brand = (item.brand || '').toLowerCase();
            const code = (item.code || '').toLowerCase();
            const note = (item.note || '').toLowerCase();
            
            const searchText = `${model} ${brand} ${code} ${note}`;
            console.log(`  ${item.code}: No sub_type, using searchText="${searchText}"`);
            
            switch (currentChargerSubTab) {
                case 'usb-type-c':
                    return searchText.includes('usb') && (searchText.includes('type-c') || searchText.includes('type c') || searchText.includes('typec'));
                case 'usb-lightning':
                    return searchText.includes('usb') && searchText.includes('lightning');
                case 'usb-micro':
                    return searchText.includes('usb') && searchText.includes('micro');
                case 'c-type-c':
                    return (searchText.includes('c to c') || searchText.includes('c-c') || (searchText.includes('type-c') && searchText.includes('to')));
                case 'c-lightning':
                    return (searchText.includes('c to lightning') || searchText.includes('c-lightning'));
                case 'other':
                    // Other = not matching any of the above
                    const isTypeC = searchText.includes('usb') && (searchText.includes('type-c') || searchText.includes('type c'));
                    const isLightning = searchText.includes('usb') && searchText.includes('lightning');
                    const isMicro = searchText.includes('usb') && searchText.includes('micro');
                    const isCtoC = (searchText.includes('c to c') || searchText.includes('c-c'));
                    const isCtoLightning = (searchText.includes('c to lightning') || searchText.includes('c-lightning'));
                    return !isTypeC && !isLightning && !isMicro && !isCtoC && !isCtoLightning;
                default:
                    return true;
            }
        });
        
        console.log(`  After filter: ${filteredEquipment.length} items`);
    }
    
    // Apply cable sub-tab filter if on cable tab
    if (tabName === 'cable' && currentCableSubTab !== 'all') {
        console.log(`üîç [displayEquipmentByTab] Applying cable sub-tab filter: ${currentCableSubTab}`);
        console.log(`  Before filter: ${filteredEquipment.length} items`);
        
        filteredEquipment = filteredEquipment.filter(item => {
            // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if (item.sub_type) {
                const match = item.sub_type === currentCableSubTab;
                console.log(`  ${item.code}: sub_type=${item.sub_type}, filter=${currentCableSubTab}, match=${match}`);
                return match;
            }
            
            // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
            const model = (item.model || '').toLowerCase();
            const brand = (item.brand || '').toLowerCase();
            const code = (item.code || '').toLowerCase();
            const note = (item.note || '').toLowerCase();
            
            const searchText = `${model} ${brand} ${code} ${note}`;
            console.log(`  ${item.code}: No sub_type, using searchText="${searchText}"`);
            
            switch (currentCableSubTab) {
                case 'usb-type-c':
                    return searchText.includes('usb') && (searchText.includes('type-c') || searchText.includes('type c') || searchText.includes('typec'));
                case 'usb-lightning':
                    return searchText.includes('usb') && searchText.includes('lightning');
                case 'usb-micro':
                    return searchText.includes('usb') && searchText.includes('micro');
                case 'c-type-c':
                    return (searchText.includes('c to c') || searchText.includes('c-c') || (searchText.includes('type-c') && searchText.includes('to')));
                case 'c-lightning':
                    return (searchText.includes('c to lightning') || searchText.includes('c-lightning'));
                case 'other':
                    // Other = not matching any of the above
                    const isTypeC = searchText.includes('usb') && (searchText.includes('type-c') || searchText.includes('type c'));
                    const isLightning = searchText.includes('usb') && searchText.includes('lightning');
                    const isMicro = searchText.includes('usb') && searchText.includes('micro');
                    const isCtoC = (searchText.includes('c to c') || searchText.includes('c-c'));
                    const isCtoLightning = (searchText.includes('c to lightning') || searchText.includes('c-lightning'));
                    return !isTypeC && !isLightning && !isMicro && !isCtoC && !isCtoLightning;
                default:
                    return true;
            }
        });
        
        console.log(`  After filter: ${filteredEquipment.length} items`);
    }
    
    // Apply adapter sub-tab filter if on adapter tab
    if (tabName === 'adapter' && currentAdapterSubTab !== 'all') {
        console.log(`üîç [displayEquipmentByTab] Applying adapter sub-tab filter: ${currentAdapterSubTab}`);
        console.log(`  Before filter: ${filteredEquipment.length} items`);
        
        filteredEquipment = filteredEquipment.filter(item => {
            // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if (item.sub_type) {
                const match = item.sub_type === currentAdapterSubTab;
                console.log(`  ${item.code}: sub_type=${item.sub_type}, filter=${currentAdapterSubTab}, match=${match}`);
                return match;
            }
            
            // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
            const model = (item.model || '').toLowerCase();
            const brand = (item.brand || '').toLowerCase();
            const code = (item.code || '').toLowerCase();
            const note = (item.note || '').toLowerCase();
            
            const searchText = `${model} ${brand} ${code} ${note}`;
            console.log(`  ${item.code}: No sub_type, using searchText="${searchText}"`);
            
            switch (currentAdapterSubTab) {
                case 'usb':
                    return searchText.includes('usb') && !searchText.includes('type-c') && !searchText.includes('2-usb') && !searchText.includes('2 usb');
                case 'type-c':
                    return searchText.includes('type-c') || searchText.includes('type c') || searchText.includes('typec');
                case '2-usb':
                    return searchText.includes('2-usb') || searchText.includes('2 usb') || searchText.includes('dual usb');
                case 'multi-charger':
                    return searchText.includes('multi') || searchText.includes('‡∏´‡∏•‡∏≤‡∏¢');
                case 'car-charger':
                    return searchText.includes('car') || searchText.includes('‡∏£‡∏ñ') || searchText.includes('‡∏ä‡∏≤‡∏£‡πå‡∏ï‡∏£‡∏ñ');
                case 'other':
                    // Other = not matching any of the above
                    const isUsb = searchText.includes('usb') && !searchText.includes('type-c') && !searchText.includes('2-usb');
                    const isTypeC = searchText.includes('type-c') || searchText.includes('type c');
                    const is2Usb = searchText.includes('2-usb') || searchText.includes('2 usb');
                    const isMulti = searchText.includes('multi') || searchText.includes('‡∏´‡∏•‡∏≤‡∏¢');
                    const isCar = searchText.includes('car') || searchText.includes('‡∏£‡∏ñ');
                    return !isUsb && !isTypeC && !is2Usb && !isMulti && !isCar;
                default:
                    return true;
            }
        });
        
        console.log(`  After filter: ${filteredEquipment.length} items`);
    }
    
    // Apply earphone sub-tab filter if on earphone tab
    if (tabName === 'earphone' && currentEarphoneSubTab !== 'all') {
        console.log(`üîç [displayEquipmentByTab] Applying earphone sub-tab filter: ${currentEarphoneSubTab}`);
        console.log(`  Before filter: ${filteredEquipment.length} items`);
        
        filteredEquipment = filteredEquipment.filter(item => {
            // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if (item.sub_type) {
                const match = item.sub_type === currentEarphoneSubTab;
                console.log(`  ${item.code}: sub_type=${item.sub_type}, filter=${currentEarphoneSubTab}, match=${match}`);
                return match;
            }
            
            return true; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ sub_type ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        });
        
        console.log(`  After filter: ${filteredEquipment.length} items`);
    }
    
    // Apply screen-protector sub-tab filter if on screen-protector tab
    if (tabName === 'screen-protector' && currentScreenProtectorSubTab !== 'all') {
        console.log(`üîç [displayEquipmentByTab] Applying screen-protector sub-tab filter: ${currentScreenProtectorSubTab}`);
        console.log(`  Before filter: ${filteredEquipment.length} items`);
        
        filteredEquipment = filteredEquipment.filter(item => {
            // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if (item.sub_type) {
                const match = item.sub_type === currentScreenProtectorSubTab;
                console.log(`  ${item.code}: sub_type=${item.sub_type}, filter=${currentScreenProtectorSubTab}, match=${match}`);
                return match;
            }
            
            // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
            const model = (item.model || '').toLowerCase();
            const brand = (item.brand || '').toLowerCase();
            const code = (item.code || '').toLowerCase();
            const note = (item.note || '').toLowerCase();
            
            const searchText = `${model} ${brand} ${code} ${note}`;
            console.log(`  ${item.code}: No sub_type, using searchText="${searchText}"`);
            
            switch (currentScreenProtectorSubTab) {
                case 'focus':
                    return searchText.includes('focus');
                case 'u-i':
                    return searchText.includes('u&i') || searchText.includes('u&amp;i') || searchText.includes('ui');
                case 'orange-box':
                    return searchText.includes('‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏™‡πâ‡∏°') || searchText.includes('orange') || searchText.includes('‡∏™‡πâ‡∏°');
                case 'lens':
                    return searchText.includes('‡πÄ‡∏•‡∏ô‡∏™‡πå') || searchText.includes('lens') || searchText.includes('‡∏Å‡∏•‡πâ‡∏≠‡∏á') || searchText.includes('camera');
                case 'tablet':
                    return searchText.includes('tablet') || searchText.includes('‡πÅ‡∏ó‡πá‡∏ö') || searchText.includes('ipad');
                case 'other':
                    // Other = not matching any of the above
                    const isFocus = searchText.includes('focus');
                    const isUI = searchText.includes('u&i') || searchText.includes('ui');
                    const isOrange = searchText.includes('‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏™‡πâ‡∏°') || searchText.includes('orange');
                    const isLens = searchText.includes('‡πÄ‡∏•‡∏ô‡∏™‡πå') || searchText.includes('lens');
                    const isTablet = searchText.includes('tablet') || searchText.includes('‡πÅ‡∏ó‡πá‡∏ö') || searchText.includes('ipad');
                    return !isFocus && !isUI && !isOrange && !isLens && !isTablet;
                default:
                    return true;
            }
        });
        
        console.log(`  After filter: ${filteredEquipment.length} items`);
    }
    
    // Apply screen-protector brand filter if applicable
    if (tabName === 'screen-protector' && currentScreenProtectorBrand !== 'all') {
        console.log(`üîç [displayEquipmentByTab] Applying screen-protector brand filter: ${currentScreenProtectorBrand}`);
        console.log(`  Before filter: ${filteredEquipment.length} items`);
        
        filteredEquipment = filteredEquipment.filter(item => {
            // ‡πÉ‡∏ä‡πâ brand_filter field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if (item.brand_filter) {
                const match = item.brand_filter === currentScreenProtectorBrand;
                console.log(`  ${item.code}: brand_filter=${item.brand_filter}, filter=${currentScreenProtectorBrand}, match=${match}`);
                return match;
            }
            
            // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å brand field
            const brand = (item.brand || '').toLowerCase();
            const model = (item.model || '').toLowerCase();
            const code = (item.code || '').toLowerCase();
            const note = (item.note || '').toLowerCase();
            
            const searchText = `${brand} ${model} ${code} ${note}`;
            console.log(`  ${item.code}: No brand_filter, using searchText="${searchText}"`);
            
            switch (currentScreenProtectorBrand) {
                case 'apple':
                    return searchText.includes('apple') || searchText.includes('iphone') || searchText.includes('ipad');
                case 'samsung':
                    return searchText.includes('samsung');
                case 'oppo':
                    return searchText.includes('oppo');
                case 'vivo':
                    return searchText.includes('vivo');
                case 'redmi':
                    return searchText.includes('redmi') || searchText.includes('xiaomi');
                case 'other':
                    // Other = not matching any of the above
                    const isApple = searchText.includes('apple') || searchText.includes('iphone') || searchText.includes('ipad');
                    const isSamsung = searchText.includes('samsung');
                    const isOppo = searchText.includes('oppo');
                    const isVivo = searchText.includes('vivo');
                    const isRedmi = searchText.includes('redmi') || searchText.includes('xiaomi');
                    return !isApple && !isSamsung && !isOppo && !isVivo && !isRedmi;
                default:
                    return true;
            }
        });
        
        console.log(`  After brand filter: ${filteredEquipment.length} items`);
    }
    
    // Apply case sub-tab filter (brand filter) if on case tab
    if (tabName === 'case' && currentCaseSubTab !== 'all') {
        console.log(`üîç [displayEquipmentByTab] Applying case sub-tab filter: ${currentCaseSubTab}`);
        console.log(`  Before filter: ${filteredEquipment.length} items`);
        
        filteredEquipment = filteredEquipment.filter(item => {
            // ‡πÉ‡∏ä‡πâ brand_filter field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
            if (item.brand_filter) {
                const match = item.brand_filter === currentCaseSubTab;
                console.log(`  ${item.code}: brand_filter=${item.brand_filter}, filter=${currentCaseSubTab}, match=${match}`);
                return match;
            }
            
            // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å brand, model, code, note
            const brand = (item.brand || '').toLowerCase();
            const model = (item.model || '').toLowerCase();
            const code = (item.code || '').toLowerCase();
            const note = (item.note || '').toLowerCase();
            
            const searchText = `${brand} ${model} ${code} ${note}`;
            console.log(`  ${item.code}: No brand_filter, using searchText="${searchText}"`);
            
            switch (currentCaseSubTab) {
                case 'apple':
                    return searchText.includes('apple') || searchText.includes('iphone') || searchText.includes('ipad');
                case 'samsung':
                    return searchText.includes('samsung');
                case 'oppo':
                    return searchText.includes('oppo');
                case 'vivo':
                    return searchText.includes('vivo');
                case 'redmi':
                    return searchText.includes('redmi') || searchText.includes('xiaomi');
                case 'other':
                    // Other = not matching any of the above
                    const isApple = searchText.includes('apple') || searchText.includes('iphone') || searchText.includes('ipad');
                    const isSamsung = searchText.includes('samsung');
                    const isOppo = searchText.includes('oppo');
                    const isVivo = searchText.includes('vivo');
                    const isRedmi = searchText.includes('redmi') || searchText.includes('xiaomi');
                    return !isApple && !isSamsung && !isOppo && !isVivo && !isRedmi;
                default:
                    return true;
            }
        });
        
        console.log(`  After case filter: ${filteredEquipment.length} items`);
    }
    
    console.log(`  ‚úÖ Filtered: ${filteredEquipment.length} items`);
    
    // Get table body ID based on tab
    const tableBodyId = getEquipmentTableBodyId(tabName);
    const tbody = document.getElementById(tableBodyId);
    
    if (!tbody) {
        console.error(`‚ùå [displayEquipmentByTab] Table body not found: ${tableBodyId}`);
        return;
    }
    
    // Build HTML - ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡πÅ‡∏¢‡∏Å‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠
    let html = '';
    
    // Sort by brand for better organization (optional)
    filteredEquipment.sort((a, b) => {
        const brandA = (a.brand || '').toLowerCase();
        const brandB = (b.brand || '').toLowerCase();
        return brandA.localeCompare(brandB);
    });
    
    // Display all equipment items directly
    filteredEquipment.forEach(item => {
        // Special handling for damage tab (6 columns)
        if (tabName === 'damage') {
            const damageQuantity = Number(item.damage_quantity) || 0;
            const costPrice = parseFloat(item.cost_price) || 0;

            html += `
            <tr style="background: #ffe6e6;">
                <td>${item.code || item.id}</td>
                <td>${item.brand}</td>
                <td><strong style="color: #dc2626;">${damageQuantity}</strong></td>
                <td>${formatCurrency(costPrice)}</td>
                <td>${item.damage_date ? formatDate(item.damage_date) : '-'}</td>
                <td>
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="equipment-action-select damage-action-select" id="equip-action-${item.id}" data-equipment-id="${item.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            <option value="edit-damage">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete-damage">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary damage-action-btn" data-equipment-id="${item.id}" onclick="executeEquipmentAction('${item.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                    </div>
                </td>
            </tr>
            `;
            return; // Skip to next item
        }
        
        // Special handling for outofstock tab (6 columns)
        if (tabName === 'outofstock') {
            const costPrice = parseFloat(item.cost_price) || 0;
            const salePrice = parseFloat(item.sale_price) || 0;

            html += `
            <tr>
                <td>${item.code || item.id}</td>
                <td>${item.brand}</td>
                <td>${formatCurrency(costPrice)}</td>
                <td>${formatCurrency(salePrice)}</td>
                <td>${formatDate(item.import_date)}</td>
                <td>
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="equipment-action-select" id="equip-action-${item.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary" onclick="executeEquipmentAction('${item.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                    </div>
                </td>
            </tr>
            `;
            return; // Skip to next item
        }
        
        // Format rows based on equipment type
        if (tabName === 'screen-protector') {
            // Screen Protector: ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏Ñ‡πà‡∏£‡∏∏‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ (7 columns)
            const modelDisplay = item.model || '-';
            
            html += `
            <tr>
                <td style="width: 14%; text-align: left;">${item.code || item.id}</td>
                <td style="width: 29%; text-align: left;">${modelDisplay}</td>
                <td style="width: 5%; text-align: center;"><strong>${item.quantity}</strong></td>
                <td style="width: 7.5%; text-align: right;">${formatCurrency(item.cost_price || 0)}</td>
                <td style="width: 10.5%; text-align: right;">${formatCurrency(item.sale_price || 0)}</td>
                <td style="width: 15%; text-align: center;">${formatDate(item.import_date)}</td>
                <td style="width: 19%; text-align: center;">
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="equipment-action-select" id="equip-action-${item.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            <option value="sell">‡∏Ç‡∏≤‡∏¢</option>
                            <option value="cut">‡∏ï‡∏±‡∏î</option>
                            <option value="damage">‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢</option>
                            <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary" onclick="executeEquipmentAction('${item.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                    </div>
                </td>
            </tr>
            `;
        } else if (tabName === 'charger-set' || tabName === 'cable' || tabName === 'adapter') {
            // Charger, Cable, Adapter: ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏Ñ‡πà‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠ (7 columns - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó)
            const brandDisplay = item.brand || '-';
            
            html += `
            <tr>
                <td style="width: 15%; text-align: left;">${item.code || item.id}</td>
                <td style="width: 15%; text-align: center;">${brandDisplay}</td>
                <td style="width: 10%; text-align: center;"><strong>${item.quantity}</strong></td>
                <td style="width: 15%; text-align: right;">${formatCurrency(item.cost_price || 0)}</td>
                <td style="width: 15%; text-align: right;">${formatCurrency(item.sale_price || 0)}</td>
                <td style="width: 15%; text-align: center;">${formatDate(item.import_date)}</td>
                <td style="width: 15%; text-align: center;">
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="equipment-action-select" id="equip-action-${item.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            <option value="sell">‡∏Ç‡∏≤‡∏¢</option>
                            <option value="cut">‡∏ï‡∏±‡∏î</option>
                            <option value="damage">‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢</option>
                            <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary" onclick="executeEquipmentAction('${item.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                    </div>
                </td>
            </tr>
            `;
        } else if (tabName === 'case') {
            // Case: ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏Ñ‡πà‡∏£‡∏∏‡πà‡∏ô (7 columns - ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠)
            const modelDisplay = item.model || '-';
            
            html += `
            <tr>
                <td style="width: 15%; text-align: left;">${item.code || item.id}</td>
                <td style="width: 15%; text-align: left;">${modelDisplay}</td>
                <td style="width: 10%; text-align: center;"><strong>${item.quantity}</strong></td>
                <td style="width: 15%; text-align: right;">${formatCurrency(item.cost_price || 0)}</td>
                <td style="width: 15%; text-align: right;">${formatCurrency(item.sale_price || 0)}</td>
                <td style="width: 15%; text-align: center;">${formatDate(item.import_date)}</td>
                <td style="width: 15%; text-align: center;">
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="equipment-action-select" id="equip-action-${item.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            <option value="sell">‡∏Ç‡∏≤‡∏¢</option>
                            <option value="cut">‡∏ï‡∏±‡∏î</option>
                            <option value="damage">‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢</option>
                            <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary" onclick="executeEquipmentAction('${item.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                    </div>
                </td>
            </tr>
            `;
        } else if (tabName === 'earphone') {
            // Earphone: ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÅ‡∏•‡∏∞‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠ (8 columns)
            let typeDisplay = '-';
            
            if (item.sub_type) {
                const subTypeLabels = {
                    'flat': '‡∏´‡∏π‡πÅ‡∏ö‡∏ô',
                    'earbuds': '‡∏´‡∏π‡∏à‡∏∏‡πä‡∏ö',
                    'over-ear': '‡∏Ñ‡∏£‡∏≠‡∏ö‡∏´‡∏π',
                    'c-earphone': 'C-‡∏´‡∏π‡∏ü‡∏±‡∏á',
                    'l-earphone': 'L-‡∏´‡∏π‡∏ü‡∏±‡∏á',
                    'aux': 'AUX',
                    'adapter': '‡∏´‡∏±‡∏ß‡πÅ‡∏õ‡∏•‡∏á',
                    'other': '‡∏≠‡∏∑‡πà‡∏ô‡πÜ'
                };
                typeDisplay = subTypeLabels[item.sub_type] || item.sub_type;
            }
            
            const brandDisplay = item.brand || '-';
            
            html += `
            <tr>
                <td style="width: 12%; text-align: left;">${item.code || item.id}</td>
                <td style="width: 12%; text-align: left;">${typeDisplay}</td>
                <td style="width: 12%; text-align: center;">${brandDisplay}</td>
                <td style="width: 8%; text-align: center;"><strong>${item.quantity}</strong></td>
                <td style="width: 12%; text-align: right;">${formatCurrency(item.cost_price || 0)}</td>
                <td style="width: 12%; text-align: right;">${formatCurrency(item.sale_price || 0)}</td>
                <td style="width: 12%; text-align: center;">${formatDate(item.import_date)}</td>
                <td style="width: 20%; text-align: center;">
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="equipment-action-select" id="equip-action-${item.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            <option value="sell">‡∏Ç‡∏≤‡∏¢</option>
                            <option value="cut">‡∏ï‡∏±‡∏î</option>
                            <option value="damage">‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢</option>
                            <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary" onclick="executeEquipmentAction('${item.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                    </div>
                    </td>
                </tr>
            `;
        } else {
            // Equipment without sub-type column
                html += `
            <tr>
                <td style="width: 15%; text-align: left;">${item.code || item.id}</td>
                <td style="width: 15%; text-align: left;">${item.brand}</td>
                <td style="width: 10%; text-align: center;"><strong>${item.quantity}</strong></td>
                <td style="width: 15%; text-align: right;">${formatCurrency(item.cost_price || 0)}</td>
                <td style="width: 15%; text-align: right;">${formatCurrency(item.sale_price || 0)}</td>
                <td style="width: 15%; text-align: center;">${formatDate(item.import_date)}</td>
                <td style="width: 15%; text-align: center;">
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="equipment-action-select" id="equip-action-${item.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            <option value="sell">‡∏Ç‡∏≤‡∏¢</option>
                            <option value="cut">‡∏ï‡∏±‡∏î</option>
                            <option value="damage">‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢</option>
                            <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary" onclick="executeEquipmentAction('${item.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                            </div>
                        </td>
                    </tr>
                `;
        }
    });
    
    // Adjust colspan based on tab type
    let colspanCount = 7;
    if (tabName === 'screen-protector' || tabName === 'charger-set' || tabName === 'cable' || tabName === 'adapter' || tabName === 'case') {
        colspanCount = 7; // ‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤, ‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠/‡∏£‡∏∏‡πà‡∏ô, ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô, ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô, ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢, ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤, ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£
    } else if (tabName === 'damage' || tabName === 'outofstock') {
        colspanCount = 6; // ‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤, ‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠, ..., ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÅ‡∏•‡∏∞‡∏£‡∏∏‡πà‡∏ô)
    } else if (tabName === 'earphone') {
        colspanCount = 8; // ‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤, ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó, ‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠, ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô, ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô, ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢, ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤, ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£
    }
    
    if (html === '') {
        console.log('  ‚ö†Ô∏è No equipment to display - showing empty state');
        tbody.innerHTML = `<tr><td colspan="${colspanCount}" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå</td></tr>`;
    } else {
        console.log(`  ‚úÖ Displaying ${filteredEquipment.length} equipment items`);
        tbody.innerHTML = html;
    }
}

// Get table body ID for equipment tab
function getEquipmentTableBodyId(tabName) {
    const mapping = {
        'charger-set': 'chargerSetTableBody',
        'cable': 'cableTableBody',
        'adapter': 'adapterTableBody',
        'earphone': 'earphoneTableBody',
        'bluetooth': 'bluetoothTableBody',
        'screen-protector': 'screenProtectorTableBody',
        'powerbank': 'powerbankTableBody',
        'case': 'caseTableBody',
        'speaker': 'speakerTableBody',
        'claim': 'claimTableBody',
        'damage': 'equipmentDamageTableBody',
        'outofstock': 'equipmentOutofstockTableBody'
    };
    return mapping[tabName] || 'chargerSetTableBody';
}

// Update equipment dashboard cards
function updateEquipmentDashboard() {
    const currentStore = localStorage.getItem('currentStore') || 'salaya';

    // Filter equipment for current store
    const storeEquipment = equipmentData.filter(item => item.store === currentStore);

    // Get date filter (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
    const startDate = currentEquipmentFilter.startDate || getFirstDayOfMonth();
    const endDate = currentEquipmentFilter.endDate || getLastDayOfMonth();

    console.log('üìÖ [updateEquipmentDashboard] Date Filter:', { startDate, endDate });

    // Calculate statistics
    let totalStock = 0;
    let totalExpense = 0;
    let totalIncome = 0;
    let totalProfit = 0;

    storeEquipment.forEach(item => {
        const quantity = parseInt(item.quantity) || 0;
        const cutQuantity = parseInt(item.cut_quantity) || 0;
        const damageQuantity = parseInt(item.damage_quantity) || 0;
        const totalQuantity = quantity + cutQuantity + damageQuantity;
        const costPrice = parseFloat(item.cost_price) || 0;
        const cutPrice = parseFloat(item.cut_price) || 0;

        // 1. ‡∏™‡∏ï‡πá‡∏≠‡∏Ñ: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡∏¥‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà)
        if (quantity > 0) {
            totalStock += quantity;
        }

        // 2. ‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢: ‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (cost_price * (quantity + cut_quantity + damage_quantity))
        // ‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà - ‡πÅ‡∏™‡∏î‡∏á‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏™‡∏°‡∏≠ (‡∏£‡∏ß‡∏° damage)
        totalExpense += costPrice * totalQuantity;

        // 3. ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö: ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏° cut_date (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ cut_date ‡πÉ‡∏ä‡πâ updated_at)
        if (cutQuantity > 0) {
            const itemDate = item.cut_date || item.updated_at;
            if (itemDate) {
                const cutDateOnly = itemDate.split('T')[0]; // YYYY-MM-DD
                if (cutDateOnly >= startDate && cutDateOnly <= endDate) {
        totalIncome += cutPrice * cutQuantity;

                    // 4. ‡∏Å‡∏≥‡πÑ‡∏£: ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö
        const profitPerUnit = cutPrice - costPrice;
        totalProfit += profitPerUnit * cutQuantity;
                }
            } else {
                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏¢ ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏ö‡∏£‡∏ß‡∏°‡πÑ‡∏ß‡πâ
                totalIncome += cutPrice * cutQuantity;
                const profitPerUnit = cutPrice - costPrice;
                totalProfit += profitPerUnit * cutQuantity;
            }
        }
    });

    console.log('üìä [updateEquipmentDashboard] Dashboard updated:', {
        store: currentStore,
        totalItems: storeEquipment.length,
        totalStock: `${totalStock} (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á)`,
        totalExpense: `‡∏ø${totalExpense.toLocaleString()} (‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏≠‡∏á)`,
        totalIncome: `‡∏ø${totalIncome.toLocaleString()} (‡∏Å‡∏£‡∏≠‡∏á ${startDate} - ${endDate})`,
        totalProfit: `‡∏ø${totalProfit.toLocaleString()} (‡∏Å‡∏£‡∏≠‡∏á ${startDate} - ${endDate})`
    });
    
    // Update UI
    document.getElementById('equipmentStockCount').textContent = totalStock.toLocaleString();
    document.getElementById('equipmentExpense').textContent = `‡∏ø${totalExpense.toLocaleString()}`;
    document.getElementById('equipmentIncome').textContent = `‡∏ø${totalIncome.toLocaleString()}`;
    document.getElementById('equipmentProfit').textContent = `‡∏ø${totalProfit.toLocaleString()}`;
}

// Update equipment counts
function updateEquipmentCounts() {
    const currentStore = localStorage.getItem('currentStore') || 'salaya';
    
    const counts = {
        'charger-set': 0,
        'cable': 0,
        'adapter': 0,
        'earphone': 0,
        'bluetooth': 0,
        'screen-protector': 0,
        'powerbank': 0,
        'case': 0,
        'speaker': 0,
        'claim': 0,
        'damage': 0,
        'outofstock': 0
    };
    
    // Charger sub-tab counts
    const chargerSubCounts = {
        'all': 0,
        'usb-type-c': 0,
        'usb-lightning': 0,
        'usb-micro': 0,
        'c-type-c': 0,
        'c-lightning': 0,
        'other': 0
    };
    
    // Cable sub-tab counts
    const cableSubCounts = {
        'all': 0,
        'usb-type-c': 0,
        'usb-lightning': 0,
        'usb-micro': 0,
        'c-type-c': 0,
        'c-lightning': 0,
        'other': 0
    };
    
    // Adapter sub-tab counts
    const adapterSubCounts = {
        'all': 0,
        'usb': 0,
        'type-c': 0,
        '2-usb': 0,
        'multi-charger': 0,
        'car-charger': 0,
        'other': 0
    };
    
    // Earphone sub-tab counts
    const earphoneSubCounts = {
        'all': 0,
        'flat': 0,
        'earbuds': 0,
        'over-ear': 0,
        'c-earphone': 0,
        'l-earphone': 0,
        'aux': 0,
        'adapter': 0,
        'other': 0
    };
    
    // Screen-protector sub-tab counts
    const screenProtectorSubCounts = {
        'all': 0,
        'focus': 0,
        'u-i': 0,
        'orange-box': 0,
        'lens': 0,
        'tablet': 0,
        'other': 0
    };
    
    // Screen-protector brand counts (nested by sub_type)
    const screenProtectorBrandCounts = {
        'all': { 'all': 0, 'apple': 0, 'samsung': 0, 'oppo': 0, 'vivo': 0, 'redmi': 0, 'other': 0 },
        'focus': { 'all': 0, 'apple': 0, 'samsung': 0, 'oppo': 0, 'vivo': 0, 'redmi': 0, 'other': 0 },
        'u-i': { 'all': 0, 'apple': 0, 'samsung': 0, 'oppo': 0, 'vivo': 0, 'redmi': 0, 'other': 0 },
        'orange-box': { 'all': 0, 'apple': 0, 'samsung': 0, 'oppo': 0, 'vivo': 0, 'redmi': 0, 'other': 0 },
        'lens': { 'all': 0, 'apple': 0, 'samsung': 0, 'oppo': 0, 'vivo': 0, 'redmi': 0, 'other': 0 },
        'tablet': { 'all': 0, 'apple': 0, 'samsung': 0, 'oppo': 0, 'vivo': 0, 'redmi': 0, 'other': 0 },
        'other': { 'all': 0, 'apple': 0, 'samsung': 0, 'oppo': 0, 'vivo': 0, 'redmi': 0, 'other': 0 }
    };
    
    // Screen-protector sub-type counts (nested by brand_filter) - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 3
    const screenProtectorSubCountsByBrand = {
        'all': { 'all': 0, 'focus': 0, 'u-i': 0, 'orange-box': 0, 'lens': 0, 'tablet': 0, 'other': 0 },
        'apple': { 'all': 0, 'focus': 0, 'u-i': 0, 'orange-box': 0, 'lens': 0, 'tablet': 0, 'other': 0 },
        'samsung': { 'all': 0, 'focus': 0, 'u-i': 0, 'orange-box': 0, 'lens': 0, 'tablet': 0, 'other': 0 },
        'oppo': { 'all': 0, 'focus': 0, 'u-i': 0, 'orange-box': 0, 'lens': 0, 'tablet': 0, 'other': 0 },
        'vivo': { 'all': 0, 'focus': 0, 'u-i': 0, 'orange-box': 0, 'lens': 0, 'tablet': 0, 'other': 0 },
        'redmi': { 'all': 0, 'focus': 0, 'u-i': 0, 'orange-box': 0, 'lens': 0, 'tablet': 0, 'other': 0 },
        'other': { 'all': 0, 'focus': 0, 'u-i': 0, 'orange-box': 0, 'lens': 0, 'tablet': 0, 'other': 0 }
    };
    
    // Case sub-tab counts (brand filter)
    const caseSubCounts = {
        'all': 0,
        'apple': 0,
        'samsung': 0,
        'oppo': 0,
        'vivo': 0,
        'redmi': 0,
        'other': 0
    };
    
    equipmentData.forEach(item => {
        if (item.store === currentStore) {
            const type = item.type;
            if (item.quantity > 0 && counts[type] !== undefined) {
                counts[type]++;
                
                // Count charger sub-categories
                if (type === 'charger-set') {
                    chargerSubCounts['all']++;
                    
                    // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                    if (item.sub_type && chargerSubCounts[item.sub_type] !== undefined) {
                        chargerSubCounts[item.sub_type]++;
                    } else {
                        // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
                        const model = (item.model || '').toLowerCase();
                        const brand = (item.brand || '').toLowerCase();
                        const code = (item.code || '').toLowerCase();
                        const note = (item.note || '').toLowerCase();
                        const searchText = `${model} ${brand} ${code} ${note}`;
                        
                        const isTypeC = searchText.includes('usb') && (searchText.includes('type-c') || searchText.includes('type c') || searchText.includes('typec'));
                        const isLightning = searchText.includes('usb') && searchText.includes('lightning');
                        const isMicro = searchText.includes('usb') && searchText.includes('micro');
                        const isCtoC = (searchText.includes('c to c') || searchText.includes('c-c'));
                        const isCtoLightning = (searchText.includes('c to lightning') || searchText.includes('c-lightning'));
                        
                        if (isTypeC) chargerSubCounts['usb-type-c']++;
                        else if (isLightning) chargerSubCounts['usb-lightning']++;
                        else if (isMicro) chargerSubCounts['usb-micro']++;
                        else if (isCtoC) chargerSubCounts['c-type-c']++;
                        else if (isCtoLightning) chargerSubCounts['c-lightning']++;
                        else chargerSubCounts['other']++;
                    }
                }
                
                // Count cable sub-categories
                if (type === 'cable') {
                    cableSubCounts['all']++;
                    
                    // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                    if (item.sub_type && cableSubCounts[item.sub_type] !== undefined) {
                        cableSubCounts[item.sub_type]++;
                    } else {
                        // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
                        const model = (item.model || '').toLowerCase();
                        const brand = (item.brand || '').toLowerCase();
                        const code = (item.code || '').toLowerCase();
                        const note = (item.note || '').toLowerCase();
                        const searchText = `${model} ${brand} ${code} ${note}`;
                        
                        const isTypeC = searchText.includes('usb') && (searchText.includes('type-c') || searchText.includes('type c') || searchText.includes('typec'));
                        const isLightning = searchText.includes('usb') && searchText.includes('lightning');
                        const isMicro = searchText.includes('usb') && searchText.includes('micro');
                        const isCtoC = (searchText.includes('c to c') || searchText.includes('c-c'));
                        const isCtoLightning = (searchText.includes('c to lightning') || searchText.includes('c-lightning'));
                        
                        if (isTypeC) cableSubCounts['usb-type-c']++;
                        else if (isLightning) cableSubCounts['usb-lightning']++;
                        else if (isMicro) cableSubCounts['usb-micro']++;
                        else if (isCtoC) cableSubCounts['c-type-c']++;
                        else if (isCtoLightning) cableSubCounts['c-lightning']++;
                        else cableSubCounts['other']++;
                    }
                }
                
                // Count adapter sub-categories
                if (type === 'adapter') {
                    adapterSubCounts['all']++;
                    
                    // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                    if (item.sub_type && adapterSubCounts[item.sub_type] !== undefined) {
                        adapterSubCounts[item.sub_type]++;
                    } else {
                        // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
                        const model = (item.model || '').toLowerCase();
                        const brand = (item.brand || '').toLowerCase();
                        const code = (item.code || '').toLowerCase();
                        const note = (item.note || '').toLowerCase();
                        const searchText = `${model} ${brand} ${code} ${note}`;
                        
                        const isUsb = searchText.includes('usb') && !searchText.includes('type-c') && !searchText.includes('2-usb') && !searchText.includes('2 usb');
                        const isTypeC = searchText.includes('type-c') || searchText.includes('type c');
                        const is2Usb = searchText.includes('2-usb') || searchText.includes('2 usb') || searchText.includes('dual usb');
                        const isMulti = searchText.includes('multi') || searchText.includes('‡∏´‡∏•‡∏≤‡∏¢');
                        const isCar = searchText.includes('car') || searchText.includes('‡∏£‡∏ñ') || searchText.includes('‡∏ä‡∏≤‡∏£‡πå‡∏ï‡∏£‡∏ñ');
                        
                        if (isUsb) adapterSubCounts['usb']++;
                        else if (isTypeC) adapterSubCounts['type-c']++;
                        else if (is2Usb) adapterSubCounts['2-usb']++;
                        else if (isMulti) adapterSubCounts['multi-charger']++;
                        else if (isCar) adapterSubCounts['car-charger']++;
                        else adapterSubCounts['other']++;
                    }
                }
                
                // Count earphone sub-categories
                if (type === 'earphone') {
                    earphoneSubCounts['all']++;
                    
                    // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                    if (item.sub_type && earphoneSubCounts[item.sub_type] !== undefined) {
                        earphoneSubCounts[item.sub_type]++;
                    }
                }
                
                // Count screen-protector sub-categories
                if (type === 'screen-protector') {
                    screenProtectorSubCounts['all']++;
                    
                    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î sub_type ‡∏Ç‡∏≠‡∏á item ‡∏ô‡∏µ‡πâ
                    let itemSubType = 'other';
                    
                    // ‡πÉ‡∏ä‡πâ sub_type field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                    if (item.sub_type && screenProtectorSubCounts[item.sub_type] !== undefined) {
                        screenProtectorSubCounts[item.sub_type]++;
                        itemSubType = item.sub_type;
                    } else {
                        // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ö‡∏ö‡πÄ‡∏î‡∏¥‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
                        const model = (item.model || '').toLowerCase();
                        const brand = (item.brand || '').toLowerCase();
                        const code = (item.code || '').toLowerCase();
                        const note = (item.note || '').toLowerCase();
                        const searchText = `${model} ${brand} ${code} ${note}`;
                        
                        const isFocus = searchText.includes('focus');
                        const isUI = searchText.includes('u&i') || searchText.includes('ui');
                        const isOrange = searchText.includes('‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏™‡πâ‡∏°') || searchText.includes('orange');
                        const isLens = searchText.includes('‡πÄ‡∏•‡∏ô‡∏™‡πå') || searchText.includes('lens');
                        const isTablet = searchText.includes('tablet') || searchText.includes('‡πÅ‡∏ó‡πá‡∏ö') || searchText.includes('ipad');
                        
                        if (isFocus) {
                            screenProtectorSubCounts['focus']++;
                            itemSubType = 'focus';
                        } else if (isUI) {
                            screenProtectorSubCounts['u-i']++;
                            itemSubType = 'u-i';
                        } else if (isOrange) {
                            screenProtectorSubCounts['orange-box']++;
                            itemSubType = 'orange-box';
                        } else if (isLens) {
                            screenProtectorSubCounts['lens']++;
                            itemSubType = 'lens';
                        } else if (isTablet) {
                            screenProtectorSubCounts['tablet']++;
                            itemSubType = 'tablet';
                        } else {
                            screenProtectorSubCounts['other']++;
                            itemSubType = 'other';
                        }
                    }
                    
                    // Count brand (‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏° sub_type)
                    screenProtectorBrandCounts['all']['all']++;
                    screenProtectorBrandCounts[itemSubType]['all']++;
                    
                    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î brand_filter ‡∏Ç‡∏≠‡∏á item ‡∏ô‡∏µ‡πâ
                    let itemBrandFilter = 'other';
                    
                    if (item.brand_filter && screenProtectorBrandCounts['all'][item.brand_filter] !== undefined) {
                        screenProtectorBrandCounts['all'][item.brand_filter]++;
                        screenProtectorBrandCounts[itemSubType][item.brand_filter]++;
                        itemBrandFilter = item.brand_filter;
                    } else {
                        // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å brand field
                        const brand = (item.brand || '').toLowerCase();
                        const model = (item.model || '').toLowerCase();
                        const code = (item.code || '').toLowerCase();
                        const note = (item.note || '').toLowerCase();
                        const searchText = `${brand} ${model} ${code} ${note}`;
                        
                        const isApple = searchText.includes('apple') || searchText.includes('iphone') || searchText.includes('ipad');
                        const isSamsung = searchText.includes('samsung');
                        const isOppo = searchText.includes('oppo');
                        const isVivo = searchText.includes('vivo');
                        const isRedmi = searchText.includes('redmi') || searchText.includes('xiaomi');
                        
                        if (isApple) {
                            screenProtectorBrandCounts['all']['apple']++;
                            screenProtectorBrandCounts[itemSubType]['apple']++;
                            itemBrandFilter = 'apple';
                        } else if (isSamsung) {
                            screenProtectorBrandCounts['all']['samsung']++;
                            screenProtectorBrandCounts[itemSubType]['samsung']++;
                            itemBrandFilter = 'samsung';
                        } else if (isOppo) {
                            screenProtectorBrandCounts['all']['oppo']++;
                            screenProtectorBrandCounts[itemSubType]['oppo']++;
                            itemBrandFilter = 'oppo';
                        } else if (isVivo) {
                            screenProtectorBrandCounts['all']['vivo']++;
                            screenProtectorBrandCounts[itemSubType]['vivo']++;
                            itemBrandFilter = 'vivo';
                        } else if (isRedmi) {
                            screenProtectorBrandCounts['all']['redmi']++;
                            screenProtectorBrandCounts[itemSubType]['redmi']++;
                            itemBrandFilter = 'redmi';
                        } else {
                            screenProtectorBrandCounts['all']['other']++;
                            screenProtectorBrandCounts[itemSubType]['other']++;
                            itemBrandFilter = 'other';
                        }
                    }
                    
                    // Count sub-type (‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏° brand_filter) - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 3
                    screenProtectorSubCountsByBrand['all']['all']++;
                    screenProtectorSubCountsByBrand['all'][itemSubType]++;
                    screenProtectorSubCountsByBrand[itemBrandFilter]['all']++;
                    screenProtectorSubCountsByBrand[itemBrandFilter][itemSubType]++;
                }
                
                // Count case sub-categories (brand filter)
                if (type === 'case') {
                    caseSubCounts['all']++;
                    
                    // ‡πÉ‡∏ä‡πâ brand_filter field ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                    if (item.brand_filter && caseSubCounts[item.brand_filter] !== undefined) {
                        caseSubCounts[item.brand_filter]++;
                    } else {
                        // Fallback: ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å brand, model, code, note
                        const brand = (item.brand || '').toLowerCase();
                        const model = (item.model || '').toLowerCase();
                        const code = (item.code || '').toLowerCase();
                        const note = (item.note || '').toLowerCase();
                        const searchText = `${brand} ${model} ${code} ${note}`;
                        
                        const isApple = searchText.includes('apple') || searchText.includes('iphone') || searchText.includes('ipad');
                        const isSamsung = searchText.includes('samsung');
                        const isOppo = searchText.includes('oppo');
                        const isVivo = searchText.includes('vivo');
                        const isRedmi = searchText.includes('redmi') || searchText.includes('xiaomi');
                        
                        if (isApple) caseSubCounts['apple']++;
                        else if (isSamsung) caseSubCounts['samsung']++;
                        else if (isOppo) caseSubCounts['oppo']++;
                        else if (isVivo) caseSubCounts['vivo']++;
                        else if (isRedmi) caseSubCounts['redmi']++;
                        else caseSubCounts['other']++;
                    }
                }
            } else if (item.quantity === 0) {
                counts['outofstock']++;
            }
        }
        
        // Count damage
        const damageQuantity = item.damage_quantity || 0;
        if (damageQuantity > 0) {
            counts['damage']++;
        }
    });
    
    // Update main badges
    document.getElementById('chargerSetCount').textContent = counts['charger-set'];
    document.getElementById('cableCount').textContent = counts['cable'];
    document.getElementById('adapterCount').textContent = counts['adapter'];
    document.getElementById('earphoneCount').textContent = counts['earphone'];
    document.getElementById('bluetoothCount').textContent = counts['bluetooth'];
    document.getElementById('screenProtectorCount').textContent = counts['screen-protector'];
    document.getElementById('powerbankCount').textContent = counts['powerbank'];
    document.getElementById('caseCount').textContent = counts['case'];
    document.getElementById('speakerCount').textContent = counts['speaker'];
    document.getElementById('claimCount').textContent = counts['claim'];
    document.getElementById('equipmentDamageCount').textContent = counts['damage'];
    document.getElementById('equipmentOutofstockCount').textContent = counts['outofstock'];
    
    // Update charger sub-tab badges
    const chargerAllCountEl = document.getElementById('chargerAllCount');
    const chargerTypeCCountEl = document.getElementById('chargerTypeCCount');
    const chargerLightningCountEl = document.getElementById('chargerLightningCount');
    const chargerMicroCountEl = document.getElementById('chargerMicroCount');
    const chargerCTypeCCountEl = document.getElementById('chargerCTypeCCount');
    const chargerCLightningCountEl = document.getElementById('chargerCLightningCount');
    const chargerOtherCountEl = document.getElementById('chargerOtherCount');
    
    if (chargerAllCountEl) chargerAllCountEl.textContent = chargerSubCounts['all'];
    if (chargerTypeCCountEl) chargerTypeCCountEl.textContent = chargerSubCounts['usb-type-c'];
    if (chargerLightningCountEl) chargerLightningCountEl.textContent = chargerSubCounts['usb-lightning'];
    if (chargerMicroCountEl) chargerMicroCountEl.textContent = chargerSubCounts['usb-micro'];
    if (chargerCTypeCCountEl) chargerCTypeCCountEl.textContent = chargerSubCounts['c-type-c'];
    if (chargerCLightningCountEl) chargerCLightningCountEl.textContent = chargerSubCounts['c-lightning'];
    if (chargerOtherCountEl) chargerOtherCountEl.textContent = chargerSubCounts['other'];
    
    // Update cable sub-tab badges
    const cableAllCountEl = document.getElementById('cableAllCount');
    const cableTypeCCountEl = document.getElementById('cableTypeCCount');
    const cableLightningCountEl = document.getElementById('cableLightningCount');
    const cableMicroCountEl = document.getElementById('cableMicroCount');
    const cableCTypeCCountEl = document.getElementById('cableCTypeCCount');
    const cableCLightningCountEl = document.getElementById('cableCLightningCount');
    const cableOtherCountEl = document.getElementById('cableOtherCount');
    
    if (cableAllCountEl) cableAllCountEl.textContent = cableSubCounts['all'];
    if (cableTypeCCountEl) cableTypeCCountEl.textContent = cableSubCounts['usb-type-c'];
    if (cableLightningCountEl) cableLightningCountEl.textContent = cableSubCounts['usb-lightning'];
    if (cableMicroCountEl) cableMicroCountEl.textContent = cableSubCounts['usb-micro'];
    if (cableCTypeCCountEl) cableCTypeCCountEl.textContent = cableSubCounts['c-type-c'];
    if (cableCLightningCountEl) cableCLightningCountEl.textContent = cableSubCounts['c-lightning'];
    if (cableOtherCountEl) cableOtherCountEl.textContent = cableSubCounts['other'];
    
    // Update adapter sub-tab badges
    const adapterAllCountEl = document.getElementById('adapterAllCount');
    const adapterUsbCountEl = document.getElementById('adapterUsbCount');
    const adapterTypeCCountEl = document.getElementById('adapterTypeCCount');
    const adapter2UsbCountEl = document.getElementById('adapter2UsbCount');
    const adapterMultiCountEl = document.getElementById('adapterMultiCount');
    const adapterCarCountEl = document.getElementById('adapterCarCount');
    const adapterOtherCountEl = document.getElementById('adapterOtherCount');
    
    if (adapterAllCountEl) adapterAllCountEl.textContent = adapterSubCounts['all'];
    if (adapterUsbCountEl) adapterUsbCountEl.textContent = adapterSubCounts['usb'];
    if (adapterTypeCCountEl) adapterTypeCCountEl.textContent = adapterSubCounts['type-c'];
    if (adapter2UsbCountEl) adapter2UsbCountEl.textContent = adapterSubCounts['2-usb'];
    if (adapterMultiCountEl) adapterMultiCountEl.textContent = adapterSubCounts['multi-charger'];
    if (adapterCarCountEl) adapterCarCountEl.textContent = adapterSubCounts['car-charger'];
    if (adapterOtherCountEl) adapterOtherCountEl.textContent = adapterSubCounts['other'];
    
    // Update earphone sub-tab badges
    const earphoneAllCountEl = document.getElementById('earphoneAllCount');
    const earphoneFlatCountEl = document.getElementById('earphoneFlatCount');
    const earphoneEarbudsCountEl = document.getElementById('earphoneEarbudsCount');
    const earphoneOverEarCountEl = document.getElementById('earphoneOverEarCount');
    const earphoneCCountEl = document.getElementById('earphoneCCount');
    const earphoneLCountEl = document.getElementById('earphoneLCount');
    const earphoneAuxCountEl = document.getElementById('earphoneAuxCount');
    const earphoneAdapterCountEl = document.getElementById('earphoneAdapterCount');
    const earphoneOtherCountEl = document.getElementById('earphoneOtherCount');
    
    if (earphoneAllCountEl) earphoneAllCountEl.textContent = earphoneSubCounts['all'];
    if (earphoneFlatCountEl) earphoneFlatCountEl.textContent = earphoneSubCounts['flat'];
    if (earphoneEarbudsCountEl) earphoneEarbudsCountEl.textContent = earphoneSubCounts['earbuds'];
    if (earphoneOverEarCountEl) earphoneOverEarCountEl.textContent = earphoneSubCounts['over-ear'];
    if (earphoneCCountEl) earphoneCCountEl.textContent = earphoneSubCounts['c-earphone'];
    if (earphoneLCountEl) earphoneLCountEl.textContent = earphoneSubCounts['l-earphone'];
    if (earphoneAuxCountEl) earphoneAuxCountEl.textContent = earphoneSubCounts['aux'];
    if (earphoneAdapterCountEl) earphoneAdapterCountEl.textContent = earphoneSubCounts['adapter'];
    if (earphoneOtherCountEl) earphoneOtherCountEl.textContent = earphoneSubCounts['other'];
    
    // Update screen-protector sub-tab badges
    const screenProtectorAllCountEl = document.getElementById('screenProtectorAllCount');
    const screenProtectorFocusCountEl = document.getElementById('screenProtectorFocusCount');
    const screenProtectorUICountEl = document.getElementById('screenProtectorUICount');
    const screenProtectorOrangeCountEl = document.getElementById('screenProtectorOrangeCount');
    const screenProtectorLensCountEl = document.getElementById('screenProtectorLensCount');
    const screenProtectorTabletCountEl = document.getElementById('screenProtectorTabletCount');
    const screenProtectorOtherCountEl = document.getElementById('screenProtectorOtherCount');
    
    // Update screen-protector sub-type badges (‡πÉ‡∏ä‡πâ counts ‡∏ï‡∏≤‡∏° currentScreenProtectorBrand)
    const currentBrand = currentScreenProtectorBrand || 'all';
    const subCountsForBrand = screenProtectorSubCountsByBrand[currentBrand] || screenProtectorSubCountsByBrand['all'];
    
    if (screenProtectorAllCountEl) screenProtectorAllCountEl.textContent = subCountsForBrand['all'];
    if (screenProtectorFocusCountEl) screenProtectorFocusCountEl.textContent = subCountsForBrand['focus'];
    if (screenProtectorUICountEl) screenProtectorUICountEl.textContent = subCountsForBrand['u-i'];
    if (screenProtectorOrangeCountEl) screenProtectorOrangeCountEl.textContent = subCountsForBrand['orange-box'];
    if (screenProtectorLensCountEl) screenProtectorLensCountEl.textContent = subCountsForBrand['lens'];
    if (screenProtectorTabletCountEl) screenProtectorTabletCountEl.textContent = subCountsForBrand['tablet'];
    if (screenProtectorOtherCountEl) screenProtectorOtherCountEl.textContent = subCountsForBrand['other'];
    
    // Update screen-protector brand badges (‡πÉ‡∏ä‡πâ counts ‡∏ï‡∏≤‡∏° currentScreenProtectorSubTab)
    const screenProtectorBrandAllCountEl = document.getElementById('screenProtectorBrandAllCount');
    const screenProtectorBrandAppleCountEl = document.getElementById('screenProtectorBrandAppleCount');
    const screenProtectorBrandSamsungCountEl = document.getElementById('screenProtectorBrandSamsungCount');
    const screenProtectorBrandOppoCountEl = document.getElementById('screenProtectorBrandOppoCount');
    const screenProtectorBrandVivoCountEl = document.getElementById('screenProtectorBrandVivoCount');
    const screenProtectorBrandRedmiCountEl = document.getElementById('screenProtectorBrandRedmiCount');
    const screenProtectorBrandOtherCountEl = document.getElementById('screenProtectorBrandOtherCount');
    
    // ‡πÉ‡∏ä‡πâ currentScreenProtectorSubTab ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    const currentSubTab = currentScreenProtectorSubTab || 'all';
    const brandCountsForSubTab = screenProtectorBrandCounts[currentSubTab] || screenProtectorBrandCounts['all'];
    
    if (screenProtectorBrandAllCountEl) screenProtectorBrandAllCountEl.textContent = brandCountsForSubTab['all'];
    if (screenProtectorBrandAppleCountEl) screenProtectorBrandAppleCountEl.textContent = brandCountsForSubTab['apple'];
    if (screenProtectorBrandSamsungCountEl) screenProtectorBrandSamsungCountEl.textContent = brandCountsForSubTab['samsung'];
    if (screenProtectorBrandOppoCountEl) screenProtectorBrandOppoCountEl.textContent = brandCountsForSubTab['oppo'];
    if (screenProtectorBrandVivoCountEl) screenProtectorBrandVivoCountEl.textContent = brandCountsForSubTab['vivo'];
    if (screenProtectorBrandRedmiCountEl) screenProtectorBrandRedmiCountEl.textContent = brandCountsForSubTab['redmi'];
    if (screenProtectorBrandOtherCountEl) screenProtectorBrandOtherCountEl.textContent = brandCountsForSubTab['other'];
    
    // Update case sub-tab badges (brand filter)
    const caseAllCountEl = document.getElementById('caseAllCount');
    const caseAppleCountEl = document.getElementById('caseAppleCount');
    const caseSamsungCountEl = document.getElementById('caseSamsungCount');
    const caseOppoCountEl = document.getElementById('caseOppoCount');
    const caseVivoCountEl = document.getElementById('caseVivoCount');
    const caseRedmiCountEl = document.getElementById('caseRedmiCount');
    const caseOtherCountEl = document.getElementById('caseOtherCount');
    
    if (caseAllCountEl) caseAllCountEl.textContent = caseSubCounts['all'];
    if (caseAppleCountEl) caseAppleCountEl.textContent = caseSubCounts['apple'];
    if (caseSamsungCountEl) caseSamsungCountEl.textContent = caseSubCounts['samsung'];
    if (caseOppoCountEl) caseOppoCountEl.textContent = caseSubCounts['oppo'];
    if (caseVivoCountEl) caseVivoCountEl.textContent = caseSubCounts['vivo'];
    if (caseRedmiCountEl) caseRedmiCountEl.textContent = caseSubCounts['redmi'];
    if (caseOtherCountEl) caseOtherCountEl.textContent = caseSubCounts['other'];
}

// Toggle equipment sub-type field
function toggleEquipmentSubType() {
    const typeSelect = document.getElementById('equipmentType');
    const subTypeGroup = document.getElementById('equipmentSubTypeGroup');
    const subTypeSelect = document.getElementById('equipmentSubType');
    const subTypeLabel = subTypeGroup.querySelector('label');
    const brandGroup = document.getElementById('equipmentBrandGroup');
    const brandSelect = document.getElementById('equipmentBrandFilter');
    const brandLabel = document.getElementById('equipmentBrandLabel');
    const brandInput = document.getElementById('equipmentBrand');
    
    // Hide both groups by default
    if (brandGroup) {
        brandGroup.style.display = 'none';
        if (brandSelect) {
            brandSelect.required = false;
            brandSelect.value = '';
        }
    }
    
    if (subTypeGroup) {
        subTypeGroup.style.display = 'none';
        subTypeSelect.required = false;
        subTypeSelect.value = '';
    }
    
    // Reset brand label to default
    if (brandLabel) {
        brandLabel.innerHTML = '‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠ <span class="required">*</span>';
    }
    if (brandInput) {
        brandInput.placeholder = '‡πÄ‡∏ä‡πà‡∏ô Anker, Belkin';
    }
    
    if (typeSelect.value === 'charger-set' || typeSelect.value === 'cable') {
        subTypeGroup.style.display = 'block';
        subTypeSelect.required = true;
        
        // Set options for charger-set and cable
        subTypeSelect.innerHTML = `
            <option value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠</option>
            <option value="usb-type-c">USB Type-C</option>
            <option value="usb-lightning">USB Lightning</option>
            <option value="usb-micro">USB Micro</option>
            <option value="c-type-c">C to Type-C</option>
            <option value="c-lightning">C to Lightning</option>
            <option value="other">‡∏≠‡∏∑‡πà‡∏ô‡πÜ</option>
        `;
    } else if (typeSelect.value === 'adapter') {
        subTypeGroup.style.display = 'block';
        subTypeSelect.required = true;
        
        // Set options for adapter
        subTypeSelect.innerHTML = `
            <option value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠</option>
            <option value="usb">USB</option>
            <option value="type-c">Type-C</option>
            <option value="2-usb">2-USB</option>
            <option value="multi-charger">Multi-‡∏ä‡∏≤‡∏£‡πå‡∏ï</option>
            <option value="car-charger">‡∏ä‡∏≤‡∏£‡πå‡∏ï‡∏£‡∏ñ</option>
            <option value="other">‡∏≠‡∏∑‡πà‡∏ô‡πÜ</option>
        `;
    } else if (typeSelect.value === 'earphone') {
        subTypeGroup.style.display = 'block';
        subTypeSelect.required = true;
        
        // Set options for earphone
        subTypeSelect.innerHTML = `
            <option value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠</option>
            <option value="flat">‡∏´‡∏π‡πÅ‡∏ö‡∏ô</option>
            <option value="earbuds">‡∏´‡∏π‡∏à‡∏∏‡πä‡∏ö</option>
            <option value="over-ear">‡∏Ñ‡∏£‡∏≠‡∏ö‡∏´‡∏π</option>
            <option value="c-earphone">C-‡∏´‡∏π‡∏ü‡∏±‡∏á</option>
            <option value="l-earphone">L-‡∏´‡∏π‡∏ü‡∏±‡∏á</option>
            <option value="aux">AUX</option>
            <option value="adapter">‡∏´‡∏±‡∏ß‡πÅ‡∏õ‡∏•‡∏á</option>
            <option value="other">‡∏≠‡∏∑‡πà‡∏ô‡πÜ</option>
        `;
    } else if (typeSelect.value === 'screen-protector') {
        // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ü‡∏¥‡∏•‡πå‡∏°‡∏Å‡∏±‡∏ô‡∏£‡∏≠‡∏¢ ‡πÅ‡∏™‡∏î‡∏á‡∏ä‡πà‡∏≠‡∏á "‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö" (brandGroup) ‡∏Å‡πà‡∏≠‡∏ô
        brandGroup.style.display = 'block';
        brandSelect.required = true;
        
        // Change brand label to "‡∏£‡∏∏‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ" for screen-protector
        if (brandLabel) {
            brandLabel.innerHTML = '‡∏£‡∏∏‡πà‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ <span class="required">*</span>';
        }
        if (brandInput) {
            brandInput.placeholder = '‡πÄ‡∏ä‡πà‡∏ô iPhone 14, iPhone 15 Pro Max';
        }
    }
}

// Toggle equipment brand field (for screen-protector)
function toggleEquipmentBrand() {
    const typeSelect = document.getElementById('equipmentType');
    const brandSelect = document.getElementById('equipmentBrandFilter');
    const subTypeGroup = document.getElementById('equipmentSubTypeGroup');
    const subTypeSelect = document.getElementById('equipmentSubType');
    
    // Show subType field (‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠) only if type is screen-protector AND brandFilter is selected
    if (typeSelect.value === 'screen-protector' && brandSelect.value !== '') {
        subTypeGroup.style.display = 'block';
        subTypeSelect.required = true;
        
        // Set options for screen-protector brands
        subTypeSelect.innerHTML = `
            <option value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠</option>
            <option value="focus">Focus</option>
            <option value="u-i">U&I</option>
            <option value="orange-box">‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏™‡πâ‡∏°</option>
            <option value="lens">‡πÄ‡∏•‡∏ô‡∏™‡πå‡∏Å‡∏•‡πâ‡∏≠‡∏á</option>
            <option value="tablet">Tablet</option>
            <option value="other">‡∏≠‡∏∑‡πà‡∏ô‡πÜ</option>
        `;
    } else {
        subTypeGroup.style.display = 'none';
        subTypeSelect.required = false;
        subTypeSelect.value = '';
    }
}

// Open equipment modal
// Open equipment modal for add/edit
function openEquipmentModal(equipmentId = null) {
    const modal = document.getElementById('equipmentModal');
    const form = document.getElementById('equipmentForm');
    const title = document.getElementById('equipmentModalTitle');

    // Reset form
    form.reset();
    document.getElementById('equipmentId').value = '';
    
    // Hide sub-type and brand filter fields by default
    document.getElementById('equipmentSubTypeGroup').style.display = 'none';
    document.getElementById('equipmentSubType').required = false;
    
    const brandGroup = document.getElementById('equipmentBrandGroup');
    if (brandGroup) {
        brandGroup.style.display = 'none';
        const brandSelect = document.getElementById('equipmentBrandFilter');
        if (brandSelect) brandSelect.required = false;
    }
    
    // Reset brand label to default
    const brandLabel = document.getElementById('equipmentBrandLabel');
    const brandInput = document.getElementById('equipmentBrand');
    if (brandLabel) {
        brandLabel.innerHTML = '‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠ <span class="required">*</span>';
    }
    if (brandInput) {
        brandInput.placeholder = '‡πÄ‡∏ä‡πà‡∏ô Anker, Belkin';
    }

    if (equipmentId) {
        // Edit mode
        title.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';
        loadEquipmentForEdit(equipmentId);
    } else {
        // Add mode
        title.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';
        // Set default date to today
        document.getElementById('equipmentImportDate').value = getTodayDate();
    }

    modal.classList.add('show');
}

// Close equipment modal
function closeEquipmentModal() {
    const modal = document.getElementById('equipmentModal');
    modal.classList.remove('show');
    document.getElementById('equipmentForm').reset();
    
    // Hide all conditional fields
    const subTypeGroup = document.getElementById('equipmentSubTypeGroup');
    const brandGroup = document.getElementById('equipmentBrandGroup');
    
    if (subTypeGroup) {
        subTypeGroup.style.display = 'none';
        const subTypeSelect = document.getElementById('equipmentSubType');
        if (subTypeSelect) subTypeSelect.required = false;
    }
    
    if (brandGroup) {
        brandGroup.style.display = 'none';
        const brandSelect = document.getElementById('equipmentBrandFilter');
        if (brandSelect) brandSelect.required = false;
    }
}

// Load equipment data for editing
async function loadEquipmentForEdit(equipmentId) {
    try {
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);

        document.getElementById('equipmentId').value = equipment.id;
        document.getElementById('equipmentType').value = equipment.type;
        document.getElementById('equipmentCode').value = equipment.code;
        document.getElementById('equipmentBrand').value = equipment.brand;
        document.getElementById('equipmentQuantity').value = equipment.quantity;
        document.getElementById('equipmentCostPrice').value = equipment.cost_price;
        document.getElementById('equipmentSalePrice').value = equipment.sale_price;
        document.getElementById('equipmentImportDate').value = equipment.import_date;
        document.getElementById('equipmentNote').value = equipment.note || '';
        
        // ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á subType ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô charger-set, cable, adapter ‡∏´‡∏£‡∏∑‡∏≠ earphone
        if (equipment.type === 'charger-set' || equipment.type === 'cable' || equipment.type === 'adapter' || equipment.type === 'earphone') {
            // Trigger toggleEquipmentSubType to show correct options
            toggleEquipmentSubType();
            
            // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ subType ‡∏à‡∏≤‡∏Å sub_type field
            const subTypeSelect = document.getElementById('equipmentSubType');
            if (equipment.sub_type && subTypeSelect) {
                subTypeSelect.value = equipment.sub_type;
            }
        }
        
        // ‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á brandFilter ‡πÅ‡∏•‡∏∞ subType ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö screen-protector
        if (equipment.type === 'screen-protector') {
            // Trigger toggleEquipmentSubType to show brandGroup (‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö)
            toggleEquipmentSubType();
            
            // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ brandFilter ‡∏à‡∏≤‡∏Å brand_filter field
            const brandFilterSelect = document.getElementById('equipmentBrandFilter');
            if (equipment.brand_filter && brandFilterSelect) {
                brandFilterSelect.value = equipment.brand_filter;
                
                // Trigger toggleEquipmentBrand to show subTypeGroup (‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠)
                toggleEquipmentBrand();
                
                // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ subType ‡∏à‡∏≤‡∏Å sub_type field
                const subTypeSelect = document.getElementById('equipmentSubType');
                if (equipment.sub_type && subTypeSelect) {
                    subTypeSelect.value = equipment.sub_type;
                }
            }
        }
    } catch (error) {
        console.error('Error loading equipment:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
        closeEquipmentModal();
    }
}

// Save equipment (add or edit)
async function saveEquipment(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const equipmentId = document.getElementById('equipmentId').value;
    const subType = formData.get('subType') || null;
    const brandFilter = formData.get('brandFilter') || null;

    const newEquipment = {
        type: formData.get('type'),
        code: formData.get('code'),
        brand: formData.get('brand'),
        model: formData.get('brand'), // ‡πÉ‡∏ä‡πâ brand ‡πÅ‡∏ó‡∏ô model
        sub_type: subType, // ‡πÄ‡∏û‡∏¥‡πà‡∏° subType
        brand_filter: brandFilter, // ‡πÄ‡∏û‡∏¥‡πà‡∏° brandFilter ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ü‡∏¥‡∏•‡πå‡∏°‡∏Å‡∏±‡∏ô‡∏£‡∏≠‡∏¢
        quantity: parseInt(formData.get('quantity')),
        cost_price: parseFloat(formData.get('costPrice')),
        sale_price: parseFloat(formData.get('salePrice')),
        import_date: formData.get('importDate'),
        note: formData.get('note') || null,
        store: currentStore
    };

    console.log('üíæ [saveEquipment] Saving equipment:', {
        equipmentId: equipmentId || 'NEW',
        equipmentData: newEquipment,
        currentStore: currentStore
    });

    try {
        if (equipmentId) {
            // Update existing equipment - preserve cut and damage fields
            const currentEquipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);
            newEquipment.cut_quantity = currentEquipment.cut_quantity || 0;
            newEquipment.cut_price = currentEquipment.cut_price || null;
            newEquipment.cut_date = currentEquipment.cut_date || null;

            // Preserve damage information (don't reset it)
            if (currentEquipment.damage_quantity !== undefined) {
                newEquipment.damage_quantity = currentEquipment.damage_quantity;
            }
            if (currentEquipment.damage_date !== undefined) {
                newEquipment.damage_date = currentEquipment.damage_date;
            }

            await API.put(`${API_ENDPOINTS.equipment}/${equipmentId}`, newEquipment);
            console.log('‚úÖ [saveEquipment] Updated successfully');
            showNotification('‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } else {
            // Create new equipment
            newEquipment.id = 'EQ' + Date.now();
            const result = await API.post(API_ENDPOINTS.equipment, newEquipment);
            console.log('‚úÖ [saveEquipment] Created successfully:', result);
            showNotification('‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }

        closeEquipmentModal();

        console.log('üîÑ [saveEquipment] Reloading equipment data...');
        await loadEquipmentData();
    } catch (error) {
        console.error('‚ùå [saveEquipment] Error saving equipment:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ: ${error.message}`,
            icon: 'error'
        });
    }
}

// Execute equipment action from dropdown
async function executeEquipmentAction(equipmentId) {
    const selectElement = document.getElementById(`equip-action-${equipmentId}`);
    const action = selectElement.value;

    if (!action) {
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'sell':
            await openClaimEquipmentModal(equipmentId);
            break;
        case 'cut':
            await openCutEquipmentModal(equipmentId);
            break;
        case 'damage':
            await openDamageEquipmentModal(equipmentId);
            break;
        case 'edit-damage':
            await openEditDamageEquipmentModal(equipmentId);
            break;
        case 'delete-damage':
            await deleteEquipmentDamage(equipmentId);
            break;
        case 'edit':
            await openEquipmentModal(equipmentId);
            break;
        case 'delete':
            await deleteEquipment(equipmentId);
            break;
        default:
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å',
                icon: 'error'
            });
    }

    // Reset select after action
    selectElement.value = '';
}

// Open sell equipment modal
async function openClaimEquipmentModal(equipmentId) {
    try {
        // Fetch equipment data
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);
        
        // Check if equipment has quantity
        if (equipment.quantity <= 0) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
                message: '‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å',
                icon: 'error'
            });
            return;
        }
        
        // Populate modal
        const modal = document.getElementById('sellEquipmentModal');
        const infoLabel = document.getElementById('sellEquipmentInfo');
        const quantityInput = document.getElementById('sellEquipmentQuantity');
        const priceInput = document.getElementById('sellEquipmentPrice');
        const dateInput = document.getElementById('sellEquipmentDate');
        const availableQuantity = document.getElementById('sellEquipmentAvailableQuantity');
        const equipmentIdInput = document.getElementById('sellEquipmentId');
        
        // Set equipment info
        const subTypeDisplay = equipment.sub_type ? getSubTypeLabel(equipment.sub_type) : '-';
        infoLabel.innerHTML = `
            <strong>‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤:</strong> ${equipment.code || equipment.id}<br>
            <strong>‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠:</strong> ${equipment.brand || '-'}<br>
            ${equipment.type === 'charger-set' || equipment.type === 'cable' || equipment.type === 'adapter' || equipment.type === 'screen-protector' ? `<strong>‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:</strong> ${subTypeDisplay}<br>` : ''}
            <strong>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠:</strong> ${equipment.quantity} ‡∏ä‡∏¥‡πâ‡∏ô<br>
            <strong>‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô:</strong> ${formatCurrency(equipment.sale_price || 0)}
        `;
        
        // Set default values
        quantityInput.value = 1;
        quantityInput.max = equipment.quantity;
        priceInput.value = equipment.sale_price || 0;
        dateInput.value = getTodayDate();
        equipmentIdInput.value = equipmentId;
        
        // Set available quantity info
        availableQuantity.textContent = `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${equipment.quantity} ‡∏ä‡∏¥‡πâ‡∏ô`;
        
        // Show modal
        modal.classList.add('show');
    } catch (error) {
        console.error('Error opening sell equipment modal:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Helper function to get sub-type label
function getSubTypeLabel(subType) {
    const labels = {
        // Charger & Cable
        'usb-type-c': 'USB Type-C',
        'usb-lightning': 'USB Lightning',
        'usb-micro': 'USB Micro',
        'c-type-c': 'C to Type-C',
        'c-lightning': 'C to Lightning',
        // Adapter
        'usb': 'USB',
        'type-c': 'Type-C',
        '2-usb': '2-USB',
        'multi-charger': 'Multi-‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        'car-charger': '‡∏ä‡∏≤‡∏£‡πå‡∏ï‡∏£‡∏ñ',
        // Earphone
        'flat': '‡∏´‡∏π‡πÅ‡∏ö‡∏ô',
        'earbuds': '‡∏´‡∏π‡∏à‡∏∏‡πä‡∏ö',
        'over-ear': '‡∏Ñ‡∏£‡∏≠‡∏ö‡∏´‡∏π',
        'c-earphone': 'C-‡∏´‡∏π‡∏ü‡∏±‡∏á',
        'l-earphone': 'L-‡∏´‡∏π‡∏ü‡∏±‡∏á',
        'aux': 'AUX',
        'adapter': '‡∏´‡∏±‡∏ß‡πÅ‡∏õ‡∏•‡∏á',
        // Screen Protector
        'focus': 'Focus',
        'u-i': 'U&I',
        'orange-box': '‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏™‡πâ‡∏°',
        'lens': '‡πÄ‡∏•‡∏ô‡∏™‡πå‡∏Å‡∏•‡πâ‡∏≠‡∏á',
        'tablet': 'Tablet',
        'other': '‡∏≠‡∏∑‡πà‡∏ô‡πÜ'
    };
    return labels[subType] || subType;
}

// Close sell equipment modal
function closeSellEquipmentModal() {
    const modal = document.getElementById('sellEquipmentModal');
    modal.classList.remove('show');
    document.getElementById('sellEquipmentForm').reset();
}

// Save sell equipment
async function saveSellEquipment(event) {
    event.preventDefault();
    
    const formData = new FormData(event.target);
    const equipmentId = formData.get('equipmentId');
    const quantity = parseInt(formData.get('quantity'));
    const price = parseFloat(formData.get('price'));
    const date = formData.get('date');
    const note = formData.get('note') || null;
    
    try {
        // Fetch current equipment data
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);
        
        // Validate quantity
        if (quantity > equipment.quantity) {
            await customAlert({
                title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                message: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢ (${quantity}) ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ (${equipment.quantity})`,
                icon: 'error'
            });
            return;
        }
        
        // Confirm sale
        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢',
            message: `‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡πÉ‡∏ô‡∏£‡∏≤‡∏Ñ‡∏≤ ${formatCurrency(price)} ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`,
            confirmText: '‡∏ï‡∏Å‡∏•‡∏á',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
        });
        
        if (!confirmed) return;
        
        // Calculate new quantity
        const newQuantity = equipment.quantity - quantity;

        // Calculate new cut_quantity (total sold items)
        const currentCutQuantity = equipment.cut_quantity || 0;
        const newCutQuantity = currentCutQuantity + quantity;

        // Update equipment (reduce quantity, add sold info)
        const updateData = {
            type: equipment.type,
            code: equipment.code,
            brand: equipment.brand,
            model: equipment.model,
            sub_type: equipment.sub_type || null,
            brand_filter: equipment.brand_filter || null,
            quantity: newQuantity,
            cost_price: equipment.cost_price,
            sale_price: equipment.sale_price,
            import_date: equipment.import_date,
            note: equipment.note,
            store: equipment.store,
            cut_quantity: newCutQuantity,
            cut_price: price,
            cut_date: date
        };
        
        await API.put(`${API_ENDPOINTS.equipment}/${equipmentId}`, updateData);
        
        // TODO: Record sale transaction (if needed)
        // You might want to create a sales table to track equipment sales
        
        // Show success message
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: `‡∏Ç‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß`,
            icon: 'success'
        });
        
        // Close modal
        closeSellEquipmentModal();
        
        // Reload equipment data
        await loadEquipmentData();
        
        // Show notification
        showNotification('‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
    } catch (error) {
        console.error('Error selling equipment:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Show equipment income detail page
// Show equipment expense detail
function showEquipmentExpenseDetail() {
    // Hide equipment main page
    document.getElementById('equipment').classList.remove('active');

    // Show expense detail page
    document.getElementById('equipment-expense-detail').classList.add('active');

    // Update page title
    document.getElementById('pageTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏£‡∏≤‡∏¢‡∏à‡πà‡∏≤‡∏¢ - ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';

    // Populate data
    populateEquipmentExpenseDetail();
}

function showEquipmentIncomeDetail() {
    // Hide equipment main page
    document.getElementById('equipment').classList.remove('active');

    // Show income detail page
    document.getElementById('equipment-income-detail').classList.add('active');

    // Update page title
    document.getElementById('pageTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';

    // Populate data
    populateEquipmentIncomeDetail();
}

// Show equipment profit detail
function showEquipmentProfitDetail() {
    // Hide equipment main page
    document.getElementById('equipment').classList.remove('active');

    // Show profit detail page
    document.getElementById('equipment-profit-detail').classList.add('active');

    // Update page title
    document.getElementById('pageTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Å‡∏≥‡πÑ‡∏£ - ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';

    // Populate data
    populateEquipmentProfitDetail();
}

// Back to equipment page
function backToEquipment() {
    // Hide detail pages
    document.getElementById('equipment-expense-detail').classList.remove('active');
    document.getElementById('equipment-income-detail').classList.remove('active');
    document.getElementById('equipment-profit-detail').classList.remove('active');

    // Show equipment main page
    document.getElementById('equipment').classList.add('active');

    // Update page title
    document.getElementById('pageTitle').textContent = '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';
}

// Populate equipment income detail table
async function populateEquipmentIncomeDetail() {
    try {
        console.log('üîç [populateEquipmentIncomeDetail] Loading equipment sales data...');
        console.log('üîç [populateEquipmentIncomeDetail] Current store:', currentStore);

        // Fetch fresh data from API
        const allEquipment = await API.get(`${API_ENDPOINTS.equipment}?store=${currentStore}`);

        console.log('üîç [populateEquipmentIncomeDetail] Total equipment items:', allEquipment.length);

        // Get date filter (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        const startDate = currentEquipmentFilter.startDate || getFirstDayOfMonth();
        const endDate = currentEquipmentFilter.endDate || getLastDayOfMonth();

        console.log('üìÖ [populateEquipmentIncomeDetail] Date Filter:', { startDate, endDate });

        // Filter equipment with cut_quantity > 0 AND filter by cut_date
        const soldEquipment = allEquipment.filter(item => {
            const cutQuantity = parseInt(item.cut_quantity) || 0;
            if (cutQuantity <= 0) return false;

            // Filter by cut_date (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ cut_date ‡πÉ‡∏ä‡πâ updated_at)
            const itemDate = item.cut_date || item.updated_at;
            if (!itemDate) return true; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏¢ ‡πÉ‡∏´‡πâ‡∏£‡∏ß‡∏°‡πÑ‡∏ß‡πâ

            const cutDateOnly = itemDate.split('T')[0]; // YYYY-MM-DD
            return cutDateOnly >= startDate && cutDateOnly <= endDate;
        });

        console.log('üîç [populateEquipmentIncomeDetail] Sold equipment items (filtered):', soldEquipment.length);
        console.log('üîç [populateEquipmentIncomeDetail] Sold equipment:', soldEquipment);

        const tableBody = document.getElementById('equipmentIncomeDetailTableBody');
        let totalIncome = 0;

        // Set filter text
        const now = new Date();
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        
        // ‡πÅ‡∏™‡∏î‡∏á filter text ‡∏ï‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
        let filterText;
        if (currentEquipmentFilter.startDate || currentEquipmentFilter.endDate) {
            const startDateObj = new Date(startDate);
            const endDateObj = new Date(endDate);
            filterText = `${startDateObj.getDate()} ${monthNames[startDateObj.getMonth()]} ${startDateObj.getFullYear() + 543} - ${endDateObj.getDate()} ${monthNames[endDateObj.getMonth()]} ${endDateObj.getFullYear() + 543}`;
        } else {
            filterText = `${monthNames[now.getMonth()]} ${now.getFullYear() + 543}`;
        }
        document.getElementById('equipmentIncomeMonth').textContent = filterText;

        if (soldEquipment.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="9" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ</td></tr>';
            document.getElementById('totalEquipmentIncomeDetail').textContent = formatCurrency(0);
            document.getElementById('equipmentIncomeDetailCount').textContent = '0';
            return;
        }

        // Sort by cut_date descending
        soldEquipment.sort((a, b) => {
            const dateA = a.cut_date || '';
            const dateB = b.cut_date || '';
            return dateB.localeCompare(dateA);
        });

        let html = '';
        soldEquipment.forEach(item => {
            const cutQuantity = parseInt(item.cut_quantity) || 0;
            const cutPrice = parseFloat(item.cut_price) || 0;
            const costPrice = parseFloat(item.cost_price) || 0;
            const totalSale = cutPrice * cutQuantity;
            const cutDate = item.cut_date || '-';

            const typeLabel = getEquipmentTypeLabel(item.type);
            const subTypeLabel = item.sub_type ? getSubTypeLabel(item.sub_type) : '';
            const displayType = subTypeLabel ? `${typeLabel} (${subTypeLabel})` : typeLabel;

            totalIncome += totalSale;

            html += `
                <tr>
                    <td style="width: 13%;">${item.code || item.id}</td>
                    <td style="width: 10%;">${item.brand || '-'}</td>
                    <td style="width: 20%;">${displayType}</td>
                    <td style="width: 6%; text-align: center;">${cutQuantity}</td>
                    <td style="width: 10%; text-align: right;">${formatCurrency(costPrice)}</td>
                    <td style="width: 10%; text-align: right;">${formatCurrency(cutPrice)}</td>
                    <td style="width: 9%; text-align: right;"><strong>${formatCurrency(totalSale)}</strong></td>
                    <td style="width: 10%; text-align: center;">${formatDate(cutDate)}</td>
                    <td style="width: 12%; text-align: center;">
                        <button class="action-btn btn-edit" onclick="editEquipmentSale('${item.id}')" title="‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
                        <button class="action-btn btn-delete" onclick="deleteEquipmentSale('${item.id}')" title="‡∏•‡∏ö">‡∏•‡∏ö</button>
                    </td>
                </tr>
            `;
        });

        tableBody.innerHTML = html;
        document.getElementById('totalEquipmentIncomeDetail').textContent = formatCurrency(totalIncome);
        document.getElementById('equipmentIncomeDetailCount').textContent = soldEquipment.length;

        console.log('‚úÖ [populateEquipmentIncomeDetail] Total income:', formatCurrency(totalIncome));
        console.log('‚úÖ [populateEquipmentIncomeDetail] Total items sold:', soldEquipment.length);
    } catch (error) {
        console.error('‚ùå [populateEquipmentIncomeDetail] Error:', error);
        document.getElementById('equipmentIncomeDetailTableBody').innerHTML =
            '<tr><td colspan="9" class="text-center">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        document.getElementById('totalEquipmentIncomeDetail').textContent = formatCurrency(0);
        document.getElementById('equipmentIncomeDetailCount').textContent = '0';
    }
}

// Populate equipment expense detail table
async function populateEquipmentExpenseDetail() {
    try {
        console.log('üîç [populateEquipmentExpenseDetail] Loading equipment data...');
        console.log('üîç [populateEquipmentExpenseDetail] Current store:', currentStore);

        // Fetch fresh data from API
        const allEquipment = await API.get(`${API_ENDPOINTS.equipment}?store=${currentStore}`);

        console.log('üîç [populateEquipmentExpenseDetail] Total equipment items:', allEquipment.length);

        const tableBody = document.getElementById('equipmentExpenseDetailTableBody');
        let totalExpense = 0;

        // Set filter text
        const now = new Date();
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        const filterText = `${monthNames[now.getMonth()]} ${now.getFullYear() + 543}`;
        document.getElementById('equipmentExpenseMonth').textContent = filterText;

        if (allEquipment.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="7" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
            document.getElementById('totalEquipmentExpenseDetail').textContent = formatCurrency(0);
            document.getElementById('equipmentExpenseDetailCount').textContent = '0';
            return;
        }

        // Sort by import_date descending
        allEquipment.sort((a, b) => {
            const dateA = a.import_date || '';
            const dateB = b.import_date || '';
            return dateB.localeCompare(dateA);
        });

        let html = '';
        allEquipment.forEach(item => {
            const quantity = parseInt(item.quantity) || 0;
            const cutQuantity = parseInt(item.cut_quantity) || 0;
            const totalQuantity = quantity + cutQuantity;
            const costPrice = parseFloat(item.cost_price) || 0;
            const totalCost = costPrice * totalQuantity;
            const importDate = item.import_date || '-';

            const typeLabel = getEquipmentTypeLabel(item.type);
            const subTypeLabel = item.sub_type ? getSubTypeLabel(item.sub_type) : '';
            const displayType = subTypeLabel ? `${typeLabel} (${subTypeLabel})` : typeLabel;

            totalExpense += totalCost;

            html += `
                <tr>
                    <td style="width: 12%; text-align: center;">${formatDate(importDate)}</td>
                    <td style="width: 13%;">${item.code || item.id}</td>
                    <td style="width: 10%;">${item.brand || '-'}</td>
                    <td style="width: 20%;">${displayType}</td>
                    <td style="width: 8%; text-align: center;">${totalQuantity}</td>
                    <td style="width: 12%; text-align: right;">${formatCurrency(costPrice)}</td>
                    <td style="width: 12%; text-align: right;"><strong style="color: #dc3545;">${formatCurrency(totalCost)}</strong></td>
                </tr>
            `;
        });

        tableBody.innerHTML = html;
        document.getElementById('totalEquipmentExpenseDetail').textContent = formatCurrency(totalExpense);
        document.getElementById('equipmentExpenseDetailCount').textContent = allEquipment.length;

        console.log('‚úÖ [populateEquipmentExpenseDetail] Total expense:', formatCurrency(totalExpense));
        console.log('‚úÖ [populateEquipmentExpenseDetail] Total items:', allEquipment.length);
    } catch (error) {
        console.error('‚ùå [populateEquipmentExpenseDetail] Error:', error);
        document.getElementById('equipmentExpenseDetailTableBody').innerHTML =
            '<tr><td colspan="7" class="text-center">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        document.getElementById('totalEquipmentExpenseDetail').textContent = formatCurrency(0);
        document.getElementById('equipmentExpenseDetailCount').textContent = '0';
    }
}

// Populate equipment profit detail table
async function populateEquipmentProfitDetail() {
    try {
        console.log('üîç [populateEquipmentProfitDetail] Loading equipment data...');
        console.log('üîç [populateEquipmentProfitDetail] Current store:', currentStore);

        // Fetch fresh data from API
        const allEquipment = await API.get(`${API_ENDPOINTS.equipment}?store=${currentStore}`);

        console.log('üîç [populateEquipmentProfitDetail] Total equipment items:', allEquipment.length);

        // Get date filter (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô)
        const startDate = currentEquipmentFilter.startDate || getFirstDayOfMonth();
        const endDate = currentEquipmentFilter.endDate || getLastDayOfMonth();

        console.log('üìÖ [populateEquipmentProfitDetail] Date Filter:', { startDate, endDate });

        // Filter equipment with cut_quantity > 0 AND filter by cut_date
        const soldEquipment = allEquipment.filter(item => {
            const cutQuantity = parseInt(item.cut_quantity) || 0;
            if (cutQuantity <= 0) return false;

            // Filter by cut_date (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ cut_date ‡πÉ‡∏ä‡πâ updated_at)
            const itemDate = item.cut_date || item.updated_at;
            if (!itemDate) return true; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏¢ ‡πÉ‡∏´‡πâ‡∏£‡∏ß‡∏°‡πÑ‡∏ß‡πâ

            const cutDateOnly = itemDate.split('T')[0]; // YYYY-MM-DD
            return cutDateOnly >= startDate && cutDateOnly <= endDate;
        });

        console.log('üîç [populateEquipmentProfitDetail] Sold equipment items (filtered):', soldEquipment.length);

        const tableBody = document.getElementById('equipmentProfitDetailTableBody');
        let totalExpense = 0;
        let totalIncome = 0;
        let totalProfit = 0;

        // Set filter text
        const now = new Date();
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        
        // ‡πÅ‡∏™‡∏î‡∏á filter text ‡∏ï‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
        let filterText;
        if (currentEquipmentFilter.startDate || currentEquipmentFilter.endDate) {
            const startDateObj = new Date(startDate);
            const endDateObj = new Date(endDate);
            filterText = `${startDateObj.getDate()} ${monthNames[startDateObj.getMonth()]} ${startDateObj.getFullYear() + 543} - ${endDateObj.getDate()} ${monthNames[endDateObj.getMonth()]} ${endDateObj.getFullYear() + 543}`;
        } else {
            filterText = `${monthNames[now.getMonth()]} ${now.getFullYear() + 543}`;
        }
        document.getElementById('equipmentProfitMonth').textContent = filterText;

        if (soldEquipment.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="9" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏µ‡πâ</td></tr>';
            document.getElementById('totalEquipmentProfitDetail').textContent = formatCurrency(0);
            document.getElementById('equipmentProfitDetailCount').textContent = '0';
            document.getElementById('equipmentProfitExpense').textContent = formatCurrency(0);
            document.getElementById('equipmentProfitIncome').textContent = formatCurrency(0);
            document.getElementById('equipmentProfitResult').textContent = formatCurrency(0);
            return;
        }

        // Sort by cut_date descending
        soldEquipment.sort((a, b) => {
            const dateA = a.cut_date || '';
            const dateB = b.cut_date || '';
            return dateB.localeCompare(dateA);
        });

        let html = '';
        soldEquipment.forEach(item => {
            const cutQuantity = parseInt(item.cut_quantity) || 0;
            const cutPrice = parseFloat(item.cut_price) || 0;
            const costPrice = parseFloat(item.cost_price) || 0;
            const profitPerUnit = cutPrice - costPrice;
            const totalProfitItem = profitPerUnit * cutQuantity;
            const totalSale = cutPrice * cutQuantity;
            const totalCost = costPrice * cutQuantity;
            const cutDate = item.cut_date || '-';

            const typeLabel = getEquipmentTypeLabel(item.type);
            const subTypeLabel = item.sub_type ? getSubTypeLabel(item.sub_type) : '';
            const displayType = subTypeLabel ? `${typeLabel} (${subTypeLabel})` : typeLabel;

            totalExpense += totalCost;
            totalIncome += totalSale;
            totalProfit += totalProfitItem;

            const profitColor = totalProfitItem >= 0 ? '#28a745' : '#dc3545';

            html += `
                <tr>
                    <td style="width: 10%; text-align: center;">${formatDate(cutDate)}</td>
                    <td style="width: 12%;">${item.code || item.id}</td>
                    <td style="width: 10%;">${item.brand || '-'}</td>
                    <td style="width: 18%;">${displayType}</td>
                    <td style="width: 6%; text-align: center;">${cutQuantity}</td>
                    <td style="width: 11%; text-align: right;">${formatCurrency(costPrice)}</td>
                    <td style="width: 11%; text-align: right;">${formatCurrency(cutPrice)}</td>
                    <td style="width: 11%; text-align: right; color: ${profitColor};">${formatCurrency(profitPerUnit)}</td>
                    <td style="width: 11%; text-align: right;"><strong style="color: ${profitColor};">${formatCurrency(totalProfitItem)}</strong></td>
                </tr>
            `;
        });

        tableBody.innerHTML = html;
        document.getElementById('totalEquipmentProfitDetail').textContent = formatCurrency(totalProfit);
        document.getElementById('equipmentProfitDetailCount').textContent = soldEquipment.length;
        document.getElementById('equipmentProfitExpense').textContent = formatCurrency(totalExpense);
        document.getElementById('equipmentProfitIncome').textContent = formatCurrency(totalIncome);
        document.getElementById('equipmentProfitResult').textContent = formatCurrency(totalProfit);

        console.log('‚úÖ [populateEquipmentProfitDetail] Total expense:', formatCurrency(totalExpense));
        console.log('‚úÖ [populateEquipmentProfitDetail] Total income:', formatCurrency(totalIncome));
        console.log('‚úÖ [populateEquipmentProfitDetail] Total profit:', formatCurrency(totalProfit));
        console.log('‚úÖ [populateEquipmentProfitDetail] Total items sold:', soldEquipment.length);
    } catch (error) {
        console.error('‚ùå [populateEquipmentProfitDetail] Error:', error);
        document.getElementById('equipmentProfitDetailTableBody').innerHTML =
            '<tr><td colspan="9" class="text-center">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        document.getElementById('totalEquipmentProfitDetail').textContent = formatCurrency(0);
        document.getElementById('equipmentProfitDetailCount').textContent = '0';
        document.getElementById('equipmentProfitExpense').textContent = formatCurrency(0);
        document.getElementById('equipmentProfitIncome').textContent = formatCurrency(0);
        document.getElementById('equipmentProfitResult').textContent = formatCurrency(0);
    }
}

// Get equipment type label
function getEquipmentTypeLabel(type) {
    const labels = {
        'charger-set': '‡∏ä‡∏∏‡∏î‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        'cable': '‡∏™‡∏≤‡∏¢‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        'adapter': '‡∏´‡∏±‡∏ß‡∏ä‡∏≤‡∏£‡πå‡∏ï',
        'earphone': '‡∏´‡∏π‡∏ü‡∏±‡∏á',
        'bluetooth': '‡∏´‡∏π‡∏ü‡∏±‡∏á‡∏ö‡∏•‡∏π‡∏ó‡∏π‡∏ò',
        'screen-protector': '‡∏ü‡∏¥‡∏•‡πå‡∏°‡∏Å‡∏±‡∏ô‡∏£‡∏≠‡∏¢',
        'powerbank': '‡πÅ‡∏ö‡∏ï‡∏™‡∏≥‡∏£‡∏≠‡∏á',
        'speaker': '‡∏•‡∏≥‡πÇ‡∏û‡∏á',
        'case': '‡πÄ‡∏Ñ‡∏™‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠'
    };
    return labels[type] || type;
}

// Edit equipment sale - Uses confirm dialog for simplicity
async function editEquipmentSale(equipmentId) {
    try {
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);

        // Check if equipment has sales
        if (!equipment.cut_quantity || equipment.cut_quantity <= 0) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ',
                message: '‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ô‡∏µ‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢',
                icon: 'error'
            });
            return;
        }

        // Prompt for new values using simple prompts
        const newCutQuantityStr = prompt(
            `‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢\n\n‡∏£‡∏´‡∏±‡∏™‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤: ${equipment.code || equipment.id}\n‡∏¢‡∏µ‡πà‡∏´‡πâ‡∏≠: ${equipment.brand}\n‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${equipment.cut_quantity} ‡∏ä‡∏¥‡πâ‡∏ô\n\n‡∏Å‡∏£‡∏≠‡∏Å‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà:`,
            equipment.cut_quantity
        );

        if (newCutQuantityStr === null) return; // User cancelled

        const newCutQuantity = parseInt(newCutQuantityStr) || 0;

        if (newCutQuantity < 0) {
            await customAlert({
                title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                message: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö 0',
                icon: 'error'
            });
            return;
        }

        const newCutPriceStr = prompt(
            `‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢\n\n‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${formatCurrency(equipment.cut_price || 0)}\n\n‡∏Å‡∏£‡∏≠‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà:`,
            equipment.cut_price || 0
        );

        if (newCutPriceStr === null) return; // User cancelled

        const newCutPrice = parseFloat(newCutPriceStr) || 0;

        const newCutDateStr = prompt(
            `‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢\n\n‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${equipment.cut_date || '-'}\n\n‡∏Å‡∏£‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡πÉ‡∏´‡∏°‡πà (YYYY-MM-DD):`,
            equipment.cut_date || getTodayDate()
        );

        if (newCutDateStr === null) return; // User cancelled

        // Calculate quantity adjustment
        const oldCutQuantity = equipment.cut_quantity || 0;
        const quantityDiff = newCutQuantity - oldCutQuantity;
        const newQuantity = equipment.quantity - quantityDiff;

        if (newQuantity < 0) {
            await customAlert({
                title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠\n\n‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: ${equipment.quantity} ‡∏ä‡∏¥‡πâ‡∏ô\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏µ‡∏Å: ${quantityDiff} ‡∏ä‡∏¥‡πâ‡∏ô`,
                icon: 'error'
            });
            return;
        }

        // Confirm changes
        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç',
            message: `‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n\n‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${equipment.cut_quantity} ‚Üí ${newCutQuantity} ‡∏ä‡∏¥‡πâ‡∏ô\n‡∏£‡∏≤‡∏Ñ‡∏≤: ${formatCurrency(equipment.cut_price)} ‚Üí ${formatCurrency(newCutPrice)}\n‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${equipment.cut_date} ‚Üí ${newCutDateStr}`,
            confirmText: '‡∏ï‡∏Å‡∏•‡∏á',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
        });

        if (!confirmed) return;

        // Update equipment
        const updateData = {
            type: equipment.type,
            code: equipment.code,
            brand: equipment.brand,
            model: equipment.model,
            sub_type: equipment.sub_type || null,
            brand_filter: equipment.brand_filter || null,
            quantity: newQuantity,
            cost_price: equipment.cost_price,
            sale_price: equipment.sale_price,
            import_date: equipment.import_date,
            note: equipment.note,
            store: equipment.store,
            cut_quantity: newCutQuantity,
            cut_price: newCutPrice,
            cut_date: newCutDateStr
        };

        await API.put(`${API_ENDPOINTS.equipment}/${equipmentId}`, updateData);

        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            icon: 'success'
        });

        // Reload data
        await loadEquipmentData();
        populateEquipmentIncomeDetail();
    } catch (error) {
        console.error('Error editing equipment sale:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Delete equipment sale
async function deleteEquipmentSale(equipmentId) {
    try {
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);

        // Check if equipment has sales
        if (!equipment.cut_quantity || equipment.cut_quantity <= 0) {
            await customAlert({
                title: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÑ‡∏î‡πâ',
                message: '‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ô‡∏µ‡πâ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢',
                icon: 'error'
            });
            return;
        }

        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
            message: `‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á ${equipment.brand || equipment.code} ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n\n‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢: ${equipment.cut_quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏∑‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏ï‡πá‡∏≠‡∏Ñ`,
            confirmText: '‡∏•‡∏ö',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
        });

        if (!confirmed) return;

        // Restore quantity and clear cut fields
        const newQuantity = equipment.quantity + equipment.cut_quantity;

        const updateData = {
            type: equipment.type,
            code: equipment.code,
            brand: equipment.brand,
            model: equipment.model,
            sub_type: equipment.sub_type || null,
            brand_filter: equipment.brand_filter || null,
            quantity: newQuantity,
            cost_price: equipment.cost_price,
            sale_price: equipment.sale_price,
            import_date: equipment.import_date,
            note: equipment.note,
            store: equipment.store,
            cut_quantity: 0,
            cut_price: null,
            cut_date: null
        };

        await API.put(`${API_ENDPOINTS.equipment}/${equipmentId}`, updateData);

        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            icon: 'success'
        });

        // Reload data
        await loadEquipmentData();
        populateEquipmentIncomeDetail();
    } catch (error) {
        console.error('Error deleting equipment sale:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Toggle equipment transfer options
function toggleEquipmentTransferOptions() {
    const action = document.getElementById('cutEquipmentAction').value;
    const transferStoreGroup = document.getElementById('equipmentTransferStoreGroup');
    const priceGroup = document.getElementById('cutEquipmentPriceGroup');
    const submitBtn = document.getElementById('cutEquipmentSubmitBtn');
    
    if (action === 'transfer') {
        transferStoreGroup.style.display = 'block';
        priceGroup.style.display = 'none';
        document.getElementById('cutEquipmentPrice').required = false;
        document.getElementById('cutEquipmentTargetStore').required = true;
        submitBtn.textContent = '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';
    } else {
        transferStoreGroup.style.display = 'none';
        priceGroup.style.display = 'block';
        document.getElementById('cutEquipmentPrice').required = true;
        document.getElementById('cutEquipmentTargetStore').required = false;
        submitBtn.textContent = '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏î‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå';
    }
}

// Open cut equipment modal
async function openCutEquipmentModal(equipmentId) {
    try {
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);

        const modal = document.getElementById('cutEquipmentModal');
        const availableQuantity = Number(equipment.quantity);

        // Set equipment info
        document.getElementById('cutEquipmentInfo').textContent =
            `${equipment.code} - ${equipment.brand}`;
        
        // Set available quantity info
        document.getElementById('cutEquipmentAvailableQuantity').textContent =
            `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡∏î‡πÑ‡∏î‡πâ: ${availableQuantity} ‡∏ä‡∏¥‡πâ‡∏ô`;
        
        // Set default values - DEFAULT TO TRANSFER!
        document.getElementById('cutEquipmentAction').value = 'transfer';
        document.getElementById('cutEquipmentQuantity').max = availableQuantity;
        document.getElementById('cutEquipmentQuantity').value = '1';
        document.getElementById('cutEquipmentPrice').value = equipment.sale_price || equipment.cost_price;
        document.getElementById('cutEquipmentDate').value = new Date().toISOString().split('T')[0];
        document.getElementById('cutEquipmentNote').value = '';
        document.getElementById('cutEquipmentId').value = equipmentId;
        
        // Filter target store options (exclude current store)
        const targetStoreSelect = document.getElementById('cutEquipmentTargetStore');
        targetStoreSelect.innerHTML = '<option value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á</option>';
        if (equipment.store !== 'salaya') {
            targetStoreSelect.innerHTML += '<option value="salaya">‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤</option>';
        }
        if (equipment.store !== 'klongyong') {
            targetStoreSelect.innerHTML += '<option value="klongyong">‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á</option>';
        }
        
        // Show/hide appropriate fields
        toggleEquipmentTransferOptions();

        modal.classList.add('show');
    } catch (error) {
        console.error('Error opening cut equipment modal:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ: ' + error.message,
            icon: 'error'
        });
    }
}

// Close cut equipment modal
function closeCutEquipmentModal() {
    const modal = document.getElementById('cutEquipmentModal');
    modal.classList.remove('show');
}

// Save cut equipment
async function saveCutEquipment(event) {
    event.preventDefault();

    const formData = new FormData(event.target);
    const equipmentId = formData.get('equipmentId');
    const action = formData.get('action');
    const quantity = parseInt(formData.get('quantity'));
    const price = parseFloat(formData.get('price')) || 0;
    const date = formData.get('date');
    const note = formData.get('note') || '';
    const targetStore = formData.get('targetStore');

    console.log('üîß [saveCutEquipment] START - Form data:', {
        equipmentId,
        action,
        quantity,
        price,
        date,
        note,
        targetStore
    });

    try {
        // Get current equipment data
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);

        if (!equipment) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå',
                icon: 'error'
            });
            return;
        }

        const availableQuantity = Number(equipment.quantity);

        console.log(`[saveCutEquipment] Action: ${action}, Equipment: ${equipment.code}, quantity=${equipment.quantity}, available=${availableQuantity}`);

        // Validate quantity
        if (quantity <= 0) {
            await customAlert({
                title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                icon: 'warning'
            });
            return;
        }

        if (quantity > availableQuantity) {
            await customAlert({
                title: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠',
                message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡∏î‡πÑ‡∏î‡πâ ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô\n‡∏°‡∏µ‡πÄ‡∏û‡∏µ‡∏¢‡∏á ${availableQuantity} ‡∏ä‡∏¥‡πâ‡∏ô‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å`,
                icon: 'warning'
            });
            return;
        }

        // Handle different actions
        if (action === 'transfer') {
            // ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥)
            console.log('üöÄ [saveCutEquipment] Transferring to another store');
            
            if (!targetStore) {
                await customAlert({
                    title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö',
                    message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á',
                    icon: 'warning'
                });
                return;
            }

            const targetStoreName = targetStore === 'salaya' ? '‡∏£‡πâ‡∏≤‡∏ô‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';
            
            const confirmed = await customConfirm({
                title: '‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå',
                message: `‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ${targetStoreName} ‡πÅ‡∏•‡∏∞‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡πâ‡∏≤‡∏ô‡∏ô‡∏±‡πâ‡∏ô`,
                icon: 'info',
                confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏¢‡πâ‡∏≤‡∏¢',
                cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
                list: [
                    { icon: 'info', iconSymbol: 'üì¶', text: `${equipment.code} - ${equipment.brand}` },
                    { icon: 'info', iconSymbol: 'üî¢', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                    { icon: 'info', iconSymbol: 'üè™', text: `‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ: ${targetStoreName}` },
                    { icon: 'info', iconSymbol: 'üìÖ', text: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${formatDate(date)}` },
                    ...(note ? [{ icon: 'info', iconSymbol: 'üìù', text: `‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ${note}` }] : [])
                ]
            });

            if (!confirmed) return;

            try {
                console.log('üöÄüöÄüöÄ [TRANSFER EQUIPMENT] Starting transfer process...');
                console.log('üìã [TRANSFER] Equipment:', equipment);
                console.log('üìã [TRANSFER] Quantity to transfer:', quantity);
                console.log('üìã [TRANSFER] Target store:', targetStore);

                // ‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á (‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° cut_quantity ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢ ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î)
                const newQuantity = Number(equipment.quantity) - quantity;
                console.log('üìâ [TRANSFER] Step 1: Reducing source store quantity:', {
                    equipmentId,
                    oldQuantity: equipment.quantity,
                    newQuantity,
                    transferredQuantity: quantity
                });

                await API.put(`${API_ENDPOINTS.equipment}/${equipmentId}`, {
                    type: equipment.type,
                    code: equipment.code,
                    brand: equipment.brand,
                    model: equipment.model,
                    sub_type: equipment.sub_type,
                    quantity: newQuantity,
                    cost_price: equipment.cost_price,
                    sale_price: equipment.sale_price,
                    import_date: equipment.import_date,
                    cut_quantity: equipment.cut_quantity || 0,
                    cut_price: equipment.cut_price || null,
                    cut_date: equipment.cut_date || null,
                    note: equipment.note ? `${equipment.note}\n‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ ${targetStoreName} ${date}: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` : `‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ ${targetStoreName} ${date}: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô`,
                    store: equipment.store
                });
                console.log('‚úÖ [TRANSFER] Step 1 completed: Source store updated');

                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ä‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                console.log('üîç [TRANSFER] Step 2: Checking if equipment exists at target store...');
                const targetEquipments = await API.get(API_ENDPOINTS.equipment, { store: targetStore });
                
                const existingEquipment = targetEquipments.find(e => 
                    e.type === equipment.type &&
                    e.code === equipment.code &&
                    e.brand === equipment.brand &&
                    e.sub_type === equipment.sub_type
                );

                if (existingEquipment) {
                    // ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô
                    console.log('‚úÖ [TRANSFER] Found existing equipment at target store:', existingEquipment);
                    const updatedQuantity = Number(existingEquipment.quantity) + quantity;
                    
                    console.log('‚ûï [TRANSFER] Step 3a: Updating existing equipment quantity:', {
                        existingId: existingEquipment.id,
                        oldQuantity: existingEquipment.quantity,
                        addedQuantity: quantity,
                        newQuantity: updatedQuantity
                    });

                    await API.put(`${API_ENDPOINTS.equipment}/${existingEquipment.id}`, {
                        type: existingEquipment.type,
                        code: existingEquipment.code,
                        brand: existingEquipment.brand,
                        model: existingEquipment.model,
                        sub_type: existingEquipment.sub_type,
                        quantity: updatedQuantity,
                        cost_price: existingEquipment.cost_price,
                        sale_price: existingEquipment.sale_price,
                        import_date: existingEquipment.import_date,
                        cut_quantity: existingEquipment.cut_quantity || 0,
                        cut_price: existingEquipment.cut_price || null,
                        cut_date: existingEquipment.cut_date || null,
                        note: existingEquipment.note ? `${existingEquipment.note}\n‡∏¢‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô ${equipment.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á'} ${date}: +${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` : `‡∏¢‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô ${equipment.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á'} ${date}: +${quantity} ‡∏ä‡∏¥‡πâ‡∏ô`,
                        store: targetStore
                    });
                    
                    console.log('‚úÖ [TRANSFER] Step 3a completed: Updated existing equipment');
                } else {
                    // ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏°‡πà‡∏°‡∏µ: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
                    console.log('‚ùå [TRANSFER] No existing equipment at target store');
                    console.log('‚ûï [TRANSFER] Step 3b: Creating new equipment at target store');
                    
                    const newEquipmentId = 'EQ' + Date.now();
                    await API.post(API_ENDPOINTS.equipment, {
                        id: newEquipmentId,
                        type: equipment.type,
                        code: equipment.code,
                        brand: equipment.brand,
                        model: equipment.model,
                        sub_type: equipment.sub_type,
                        quantity: quantity,
                        cost_price: equipment.cost_price,
                        sale_price: equipment.sale_price,
                        import_date: date,
                        cut_quantity: 0,
                        cut_price: null,
                        cut_date: null,
                        note: `‡∏¢‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏£‡πâ‡∏≤‡∏ô ${equipment.store === 'salaya' ? '‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á'} ${date}: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô`,
                        store: targetStore
                    });
                    
                    console.log('‚úÖ [TRANSFER] Step 3b completed: Created new equipment');
                }

                closeCutEquipmentModal();
                await loadEquipmentData();

                await customAlert({
                    title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                    message: `‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß\n‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô\n‡πÑ‡∏õ‡∏¢‡∏±‡∏á: ${targetStoreName}`,
                    icon: 'success',
                    confirmType: 'success'
                });

            } catch (transferError) {
                console.error('‚ùå [TRANSFER] Error during transfer:', transferError);
                await customAlert({
                    title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                    message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ: ${transferError.message}`,
                    icon: 'error',
                    confirmType: 'danger'
                });
            }

        } else if (action === 'cut') {
            // ‡∏ï‡∏±‡∏î‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏£‡πâ‡∏≤‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢)
            console.log('‚úÇÔ∏è [saveCutEquipment] Cutting for own store');
            const confirmed = await customConfirm({
                title: '‚ö†Ô∏è ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡πâ‡∏≤‡∏ô)',
                message: 'üî¥ ‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏™‡∏ï‡πá‡∏≠‡∏Å ‡πÅ‡∏ï‡πà‡∏à‡∏∞**‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô**\n\n‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "‡∏¢‡πâ‡∏≤‡∏¢‡∏†‡∏≤‡∏¢‡πÉ‡∏ô" ‡πÅ‡∏ó‡∏ô',
                icon: 'warning',
                confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏î (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡πâ‡∏≤‡∏ô)',
                cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
                list: [
                    { icon: 'info', iconSymbol: 'üì¶', text: `${equipment.code} - ${equipment.brand}` },
                    { icon: 'info', iconSymbol: 'üî¢', text: `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô` },
                    { icon: 'info', iconSymbol: 'üí∞', text: `‡∏£‡∏≤‡∏Ñ‡∏≤: ${formatCurrency(price)}` },
                    { icon: 'info', iconSymbol: 'üìÖ', text: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${formatDate(date)}` },
                    { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: `‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô!` },
                    ...(note ? [{ icon: 'info', iconSymbol: 'üìù', text: `‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ${note}` }] : [])
                ]
            });

            if (!confirmed) return;

            // Call API to cut equipment
            const result = await API.post(API_ENDPOINTS.equipmentCut(equipmentId), {
                quantity: quantity,
                price: price,
                date: date,
                note: note
            });

            console.log(`[saveCutEquipment] Cut result:`, result);

            closeCutEquipmentModal();
            await loadEquipmentData();

            await customAlert({
                title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                message: `‡∏ï‡∏±‡∏î‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß\n‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô\n‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠: ${result.remaining} ‡∏ä‡∏¥‡πâ‡∏ô`,
                icon: 'success',
                confirmType: 'success'
            });
        }

    } catch (error) {
        console.error('‚ùå [saveCutEquipment] Error:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏î‡πâ: ${error.message}`,
            icon: 'error',
            confirmType: 'danger'
        });
    }
}

// Delete equipment
async function deleteEquipment(id) {
    console.log('üóëÔ∏è [deleteEquipment] Attempting to delete equipment:', id);
    
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? ‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏à‡∏∞‡∏ñ‡∏≤‡∏ß‡∏£‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏π‡πâ‡∏Ñ‡∏∑‡∏ô‡πÑ‡∏î‡πâ',
        icon: 'warning',
        confirmText: '‡∏•‡∏ö',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
    });

    if (!confirmed) {
        console.log('‚ùå [deleteEquipment] User cancelled deletion');
        return;
    }

    try {
        console.log('üîÑ [deleteEquipment] Sending DELETE request to API...');
        const response = await API.delete(`${API_ENDPOINTS.equipment}/${id}`);
        console.log('‚úÖ [deleteEquipment] Equipment deleted successfully:', response);
        
        showNotification('‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', 'success');
        
        // Reload equipment data to refresh the display
        await loadEquipmentData();
        } catch (error) {
        console.error('‚ùå [deleteEquipment] Error deleting equipment:', error);
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ: ${error.message}`,
                icon: 'error'
            });
        }
}

// ============================================
// Equipment Damage Functions (‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢)
// ============================================

// Open damage equipment modal
async function openDamageEquipmentModal(equipmentId) {
    try {
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);

        const modal = document.getElementById('damageEquipmentModal');
        const claimQuantity = equipment.claim_quantity || 0;
        // ‡πÑ‡∏°‡πà‡∏´‡∏±‡∏Å damageQuantity ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ damage ‡∏à‡∏∞‡∏•‡∏î quantity ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
        const availableQuantity = equipment.quantity - claimQuantity;

        console.log('üìã [openDamageEquipmentModal] Equipment:', {
            code: equipment.code,
            quantity: equipment.quantity,
            claim_quantity: claimQuantity,
            damage_quantity: equipment.damage_quantity,
            available: availableQuantity
        });

        document.getElementById('damageEquipmentInfo').textContent =
            `${equipment.code} - ${equipment.brand || ''} ${equipment.model || ''}`;
        document.getElementById('damageEquipmentAvailableQuantity').textContent =
            `‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡πÑ‡∏î‡πâ: ${availableQuantity} ‡∏ä‡∏¥‡πâ‡∏ô`;
        document.getElementById('damageEquipmentQuantity').max = availableQuantity;
        document.getElementById('damageEquipmentQuantity').value = '';
        document.getElementById('damageEquipmentDate').value = new Date().toISOString().split('T')[0];
        document.getElementById('damageEquipmentId').value = equipmentId;

        modal.classList.add('show');
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
        console.error(error);
    }
}

// Close damage equipment modal
function closeDamageEquipmentModal() {
    const modal = document.getElementById('damageEquipmentModal');
    modal.classList.remove('show');
}

// Send equipment to damage
async function sendEquipmentToDamage(event) {
    event.preventDefault();

    const equipmentId = document.getElementById('damageEquipmentId').value;
    const quantity = parseInt(document.getElementById('damageEquipmentQuantity').value);
    const damageDate = document.getElementById('damageEquipmentDate').value;

    console.log('üî¥ [sendEquipmentToDamage] Marking equipment as damaged:', {
        equipmentId,
        quantity,
        damageDate
    });

    try {
        const result = await API.post(API_ENDPOINTS.equipmentDamage(equipmentId), { 
            quantity,
            damage_date: damageDate
        });

        console.log('‚úÖ [sendEquipmentToDamage] Success:', result);
        
        // Reload data to update stock and damage list
        await loadEquipmentData();
        
        closeDamageEquipmentModal();

        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
        const remainingQty = result.remaining_quantity || 0;
        let message = `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢ ${quantity} ‡∏ä‡∏¥‡πâ‡∏ô ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`;
        if (remainingQty === 0) {
            message += '\n(‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö "‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏´‡∏°‡∏î")';
        } else {
            message += `\n(‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å ${remainingQty} ‡∏ä‡∏¥‡πâ‡∏ô)`;
        }
        
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: message,
            icon: 'success'
        });
    } catch (error) {
        console.error('‚ùå [sendEquipmentToDamage] Error:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Open edit damage equipment modal
async function openEditDamageEquipmentModal(equipmentId) {
    try {
        const equipment = await API.get(`${API_ENDPOINTS.equipment}/${equipmentId}`);

        const modal = document.getElementById('editDamageEquipmentModal');
        const damageQuantity = equipment.damage_quantity || 0;

        console.log('üìù [openEditDamageEquipmentModal] Equipment:', {
            code: equipment.code,
            damage_quantity: damageQuantity,
            damage_date: equipment.damage_date
        });

        document.getElementById('editDamageEquipmentInfo').textContent =
            `${equipment.code} - ${equipment.brand || ''} ${equipment.model || ''}`;
        document.getElementById('editDamageEquipmentQuantity').value = damageQuantity;
        document.getElementById('editDamageEquipmentQuantity').max = 9999; // Allow any positive number
        document.getElementById('editDamageEquipmentDate').value = equipment.damage_date ? 
            new Date(equipment.damage_date).toISOString().split('T')[0] : 
            new Date().toISOString().split('T')[0];
        document.getElementById('editDamageEquipmentId').value = equipmentId;

        modal.classList.add('show');
    } catch (error) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
        console.error(error);
    }
}

// Close edit damage equipment modal
function closeEditDamageEquipmentModal() {
    const modal = document.getElementById('editDamageEquipmentModal');
    modal.classList.remove('show');
}

// Update equipment damage
async function updateEquipmentDamage(event) {
    event.preventDefault();

    const equipmentId = document.getElementById('editDamageEquipmentId').value;
    const newQuantity = parseInt(document.getElementById('editDamageEquipmentQuantity').value);
    const newDate = document.getElementById('editDamageEquipmentDate').value;

    console.log('‚úèÔ∏è [updateEquipmentDamage] Updating damage info:', {
        equipmentId,
        newQuantity,
        newDate
    });

    if (newQuantity <= 0) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0',
            icon: 'warning'
        });
        return;
    }

    try {
        const result = await API.put(API_ENDPOINTS.equipmentUpdateDamage(equipmentId), { 
            damage_quantity: newQuantity,
            damage_date: newDate
        });

        console.log('‚úÖ [updateEquipmentDamage] Success:', result);
        
        // Reload data to update damage list
        await loadEquipmentData();
        
        closeEditDamageEquipmentModal();

        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            icon: 'success'
        });
    } catch (error) {
        console.error('‚ùå [updateEquipmentDamage] Error:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Delete equipment damage (remove from damage list)
async function deleteEquipmentDamage(equipmentId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        icon: 'warning',
        confirmText: '‡∏•‡∏ö',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
    });

    if (!confirmed) {
        return;
    }

    try {
        const result = await API.post(API_ENDPOINTS.equipmentRemoveDamage(equipmentId));
        console.log('‚úÖ [deleteEquipmentDamage] Success:', result);
        
        // Reload data
        await loadEquipmentData();
        
        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏´‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            icon: 'success'
        });
    } catch (error) {
        console.error('‚ùå [deleteEquipmentDamage] Error:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ',
                icon: 'error'
            });
    }
}

// Search equipment
function searchEquipment() {
    const searchTerm = document.getElementById('searchEquipment').value.toLowerCase();
    
    if (!searchTerm) {
        displayEquipmentByTab(currentEquipmentTab);
        return;
    }
    
    const currentStore = localStorage.getItem('currentStore') || 'salaya';
    const filtered = equipmentData.filter(item => 
        item.store === currentStore &&
        item.type === currentEquipmentTab &&
        (item.brand.toLowerCase().includes(searchTerm) ||
         item.model.toLowerCase().includes(searchTerm) ||
         (item.code && item.code.toLowerCase().includes(searchTerm)))
    );
    
    // Display filtered results with brand grouping
    const groupedByBrand = {};
    BRAND_CATEGORIES.forEach(brand => {
        groupedByBrand[brand] = [];
    });
    groupedByBrand['‡∏≠‡∏∑‡πà‡∏ô‡πÜ'] = [];
    
    filtered.forEach(item => {
        const brand = item.brand || '';
        const brandKey = BRAND_CATEGORIES.find(b => 
            brand.toLowerCase().includes(b.toLowerCase())
        );
        
        if (brandKey) {
            groupedByBrand[brandKey].push(item);
        } else {
            groupedByBrand['‡∏≠‡∏∑‡πà‡∏ô‡πÜ'].push(item);
        }
    });
    
    const tableBodyId = getEquipmentTableBodyId(currentEquipmentTab);
    const tbody = document.getElementById(tableBodyId);
    
    if (!tbody) return;
    
    let html = '';
    let hasResults = false;
    
    [...BRAND_CATEGORIES, '‡∏≠‡∏∑‡πà‡∏ô‡πÜ'].forEach(brand => {
        const items = groupedByBrand[brand];
        if (items.length > 0) {
            hasResults = true;
            
            html += `
                <tr class="brand-header-row">
                    <td colspan="8" class="brand-header">
                        <strong>üì± ${brand}</strong> 
                        <span class="brand-count">(${items.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)</span>
                    </td>
                </tr>
            `;
            
            items.forEach(item => {
                html += `
                    <tr>
                        <td>${item.code || item.id}</td>
                        <td>${item.brand}</td>
                        <td>${item.model}</td>
                        <td style="text-align: center;"><strong>${item.quantity}</strong></td>
                        <td style="text-align: right;">${formatCurrency(item.cost_price || 0)}</td>
                        <td style="text-align: right;">${formatCurrency(item.sale_price || 0)}</td>
                        <td style="text-align: center;">${formatDate(item.import_date)}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-action btn-claim" onclick="openClaimEquipmentModal('${item.id}')" title="‡∏Ç‡∏≤‡∏¢‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå">
                                    <span>üì§</span>
                                </button>
                                <button class="btn-action btn-edit" onclick="openEquipmentModal('${item.id}')" title="‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç">
                                    <span>‚úèÔ∏è</span>
                                </button>
                                <button class="btn-action btn-delete" onclick="deleteEquipment('${item.id}')" title="‡∏•‡∏ö">
                                    <span>üóëÔ∏è</span>
                                </button>
                            </div>
                        </td>
                    </tr>
                `;
            });
        }
    });
    
    if (!hasResults) {
        tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</td></tr>';
    } else {
        tbody.innerHTML = html;
    }
}

// Export equipment stock
function exportEquipmentStock() {
    customAlert({
        title: 'Export Excel',
        message: '‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤',
        icon: 'info'
    });
}

// ==================== Bills Management Functions ====================

// Global variable to store bills data
let billsData = [];

// Load bills data
async function loadBillsData() {
    try {
        console.log('Loading bills data...');
        // TODO: Replace with actual API call when backend is ready
        // billsData = await API.get('/api/bills');
        
        // For now, use empty array or mock data
        billsData = [];
        
        displayBills();
        updateBillsStats();
    } catch (error) {
        console.error('Error loading bills:', error);
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏¥‡∏•‡πÑ‡∏î‡πâ: ' + error.message,
            confirmText: '‡∏ï‡∏Å‡∏•‡∏á'
        });
    }
}

// NOTE: Duplicate functions removed (loadEquipmentData, displayEquipmentByTypeAndBrand, displayEquipmentByBrand, displayOutOfStockEquipment, updateEquipmentCounts)
// These functions were causing conflicts by using undefined 'equipment' variable instead of 'equipmentData'
// The correct implementations are defined above (around line 15715-15920)

// Display equipment
function displayEquipment(equipmentList, tableBodyId) {
    const tbody = document.getElementById(tableBodyId);
    if (!tbody) return;

    tbody.innerHTML = '';

    if (equipmentList.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        return;
    }

    equipmentList.forEach(equipment => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${equipment.code || '-'}</td>
            <td>${equipment.brand || '-'}</td>
            <td>${equipment.quantity || 0}</td>
            <td>‡∏ø${Number(equipment.cost_price || 0).toLocaleString()}</td>
            <td>‡∏ø${Number(equipment.selling_price || 0).toLocaleString()}</td>
            <td>${equipment.import_date ? new Date(equipment.import_date).toLocaleDateString('th-TH') : '-'}</td>
            <td>
                <button class="btn btn-sm btn-primary" onclick="openEquipmentModal('${equipment.id}')">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</button>
                <button class="btn btn-sm btn-danger" onclick="deleteEquipment('${equipment.id}')">‡∏•‡∏ö</button>
            </td>
        `;
        tbody.appendChild(row);
    });
}

// Delete equipment function (duplicate removed - using the one above with customConfirm)

// Search equipment
function searchEquipment() {
    const searchInput = document.getElementById('searchEquipment');
    const searchTerm = searchInput.value.toLowerCase();
    
    // TODO: Implement search functionality
    loadEquipmentData();
}

// Filter equipment
// Initialize equipment date filter
function initializeEquipmentDateFilter() {
    const monthSelect = document.getElementById('filterEquipmentMonth');
    const yearSelect = document.getElementById('filterEquipmentYear');

    if (!monthSelect || !yearSelect) return;

    // Clear existing options except the first one
    while (monthSelect.options.length > 1) {
        monthSelect.remove(1);
    }
    while (yearSelect.options.length > 1) {
        yearSelect.remove(1);
    }

    // Populate year dropdown
    const currentYear = new Date().getFullYear();
    for (let year = currentYear; year >= currentYear - 5; year--) {
        const option = document.createElement('option');
        option.value = year;
        option.textContent = `${year + 543}`;
        yearSelect.appendChild(option);
    }

    // Populate month dropdown
    const thaiMonths = [
        '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
        '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'
    ];

    thaiMonths.forEach((month, index) => {
        const option = document.createElement('option');
        option.value = index + 1;
        option.textContent = month;
        monthSelect.appendChild(option);
    });
}

function filterEquipment() {
    const monthSelect = document.getElementById('filterEquipmentMonth');
    const yearSelect = document.getElementById('filterEquipmentYear');

    // TODO: Implement filter functionality
    loadEquipmentData();
}

// ===== DATE RANGE FILTER FUNCTIONS (used by header filter) =====
// All filter functions are called from filterDashboardByDateRange() and clearDashboardDateFilter()
// Individual page filters have been removed from HTML and replaced with single header filter

// EQUIPMENT (‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå)
function filterEquipmentByDateRange() {
    const startDate = document.getElementById('filterEquipmentStartDate').value;
    const endDate = document.getElementById('filterEquipmentEndDate').value;

    console.log('üîç Filtering Equipment:', { startDate, endDate });
    loadEquipmentData();
}

function resetEquipmentFilter() {
    const startDateInput = document.getElementById('filterEquipmentStartDate');
    const endDateInput = document.getElementById('filterEquipmentEndDate');
    const searchInput = document.getElementById('searchEquipment');
    
    if (startDateInput) startDateInput.value = '';
    if (endDateInput) endDateInput.value = '';
    if (searchInput) searchInput.value = '';
    
    loadEquipmentData();
}

// EXPENSES (‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢)
function filterExpensesByDateRange() {
    const startDate = document.getElementById('expenseStartDate').value;
    const endDate = document.getElementById('expenseEndDate').value;

    console.log('üîç Filtering Expenses:', { startDate, endDate });
    
    if (startDate || endDate) {
        filterExpensesByCustomRange(startDate, endDate);
    } else {
        loadExpenseData();
    }
}

function clearExpenseFilter() {
    const startDateInput = document.getElementById('expenseStartDate');
    const endDateInput = document.getElementById('expenseEndDate');
    
    if (startDateInput) startDateInput.value = '';
    if (endDateInput) endDateInput.value = '';
    
    loadExpenseData();
}

function filterExpensesByCustomRange(startDate, endDate) {
    console.log('üìä Filtering expenses from', startDate, 'to', endDate);
    loadExpenseData(); // TODO: Add date range filtering logic
}

// Sync filter inputs with current page filter
function syncFilterInputs(pageName) {
    const startDateInput = document.getElementById('dashboardStartDate');
    const endDateInput = document.getElementById('dashboardEndDate');
    
    if (!startDateInput || !endDateInput) return;

    let startDate = '';
    let endDate = '';

    // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ filter ‡∏ï‡∏≤‡∏°‡∏´‡∏ô‡πâ‡∏≤
    switch(pageName) {
        case 'dashboard':
            startDate = currentDashboardFilter.startDate || '';
            endDate = currentDashboardFilter.endDate || '';
            break;
        case 'new-devices':
            startDate = currentNewDevicesFilter.startDate || '';
            endDate = currentNewDevicesFilter.endDate || '';
            break;
        case 'used-devices':
            startDate = currentUsedDevicesFilter.startDate || '';
            endDate = currentUsedDevicesFilter.endDate || '';
            break;
        case 'installment':
            startDate = currentInstallmentFilter.startDate || '';
            endDate = currentInstallmentFilter.endDate || '';
            break;
        case 'pawn':
            startDate = currentPawnFilter.startDate || '';
            endDate = currentPawnFilter.endDate || '';
            break;
        case 'repair':
            startDate = currentRepairFilter.startDate || '';
            endDate = currentRepairFilter.endDate || '';
            break;
        case 'accessories':
            startDate = currentAccessoryFilter.startDate || '';
            endDate = currentAccessoryFilter.endDate || '';
            break;
        case 'equipment':
            startDate = currentEquipmentFilter.startDate || '';
            endDate = currentEquipmentFilter.endDate || '';
            break;
        default:
            startDate = '';
            endDate = '';
    }

    startDateInput.value = startDate;
    endDateInput.value = endDate;
}

// DASHBOARD
function filterDashboardByDateRange() {
    const startDate = document.getElementById('dashboardStartDate').value;
    const endDate = document.getElementById('dashboardEndDate').value;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏´‡∏ô
    const activePage = document.querySelector('.page-content.active');
    if (!activePage) return;

    const pageId = activePage.id;

    console.log('üîç [filterDashboardByDateRange] ========== CALLED ==========');
    console.log('üîç Active Page:', pageId);
    console.log('üîç Start Date Input:', startDate);
    console.log('üîç End Date Input:', endDate);

    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å filter function ‡∏ï‡∏≤‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    switch(pageId) {
        case 'dashboard':
        case 'income-breakdown':
        case 'expense-breakdown':
        case 'profit-breakdown':
    currentDashboardFilter.startDate = startDate;
    currentDashboardFilter.endDate = endDate;
            console.log('üîç [Dashboard Breakdown Pages] Filter set to:', currentDashboardFilter);
    updateDashboard();
            break;
        case 'new-devices':
            currentNewDevicesFilter.startDate = startDate;
            currentNewDevicesFilter.endDate = endDate;
            applyNewDevicesFilter();
            break;
        case 'used-devices':
            currentUsedDevicesFilter.startDate = startDate;
            currentUsedDevicesFilter.endDate = endDate;
            applyUsedDevicesFilter();
            break;
        case 'installment':
            currentInstallmentFilter.startDate = startDate;
            currentInstallmentFilter.endDate = endDate;
            loadInstallmentData();
            break;
        case 'pawn':
            currentPawnFilter.startDate = startDate;
            currentPawnFilter.endDate = endDate;
            loadPawnData();
            break;
        case 'repair':
            currentRepairFilter.startDate = startDate;
            currentRepairFilter.endDate = endDate;
            loadRepairData();
            break;
        case 'accessories':
            currentAccessoryFilter.startDate = startDate;
            currentAccessoryFilter.endDate = endDate;
            loadAccessoriesData();
            break;
        case 'equipment':
            currentEquipmentFilter.startDate = startDate;
            currentEquipmentFilter.endDate = endDate;
            loadEquipmentData();
            break;
        default:
            console.log('No filter function for this page');
    }
}

function clearDashboardDateFilter() {
    const startDateInput = document.getElementById('dashboardStartDate');
    const endDateInput = document.getElementById('dashboardEndDate');
    
    if (startDateInput) startDateInput.value = '';
    if (endDateInput) endDateInput.value = '';
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏´‡∏ô
    const activePage = document.querySelector('.page-content.active');
    if (!activePage) return;

    const pageId = activePage.id;

    console.log('üîç Clearing filter for page:', pageId);

    // ‡∏•‡πâ‡∏≤‡∏á filter ‡∏ï‡∏≤‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    switch(pageId) {
        case 'dashboard':
        case 'income-breakdown':
        case 'expense-breakdown':
        case 'profit-breakdown':
    currentDashboardFilter = { startDate: '', endDate: '' };
    updateDashboard();
            break;
        case 'new-devices':
            currentNewDevicesFilter.startDate = '';
            currentNewDevicesFilter.endDate = '';
            applyNewDevicesFilter();
            break;
        case 'used-devices':
            currentUsedDevicesFilter.startDate = '';
            currentUsedDevicesFilter.endDate = '';
            applyUsedDevicesFilter();
            break;
        case 'installment':
            currentInstallmentFilter.startDate = '';
            currentInstallmentFilter.endDate = '';
            loadInstallmentData();
            break;
        case 'pawn':
            currentPawnFilter.startDate = '';
            currentPawnFilter.endDate = '';
            loadPawnData();
            break;
        case 'repair':
            currentRepairFilter.startDate = '';
            currentRepairFilter.endDate = '';
            loadRepairData();
            break;
        case 'accessories':
            currentAccessoryFilter.startDate = '';
            currentAccessoryFilter.endDate = '';
            loadAccessoriesData();
            break;
        case 'equipment':
            currentEquipmentFilter.startDate = '';
            currentEquipmentFilter.endDate = '';
            loadEquipmentData();
            break;
        default:
            console.log('No filter function for this page');
    }
}

// ===== MEMBERS MANAGEMENT FUNCTIONS =====
let membersData = [];

// Load members data
async function loadMembersData() {
    try {
        // TODO: Fetch from API
        // membersData = await API.get(API_ENDPOINTS.members);
        
        // Mock data for now
        membersData = [
            {
                id: 'M001',
                name: '‡∏™‡∏°‡∏ä‡∏≤‡∏¢ ‡πÉ‡∏à‡∏î‡∏µ',
                phone: '081-234-5678',
                email: 'somchai@example.com',
                join_date: '2024-01-15',
                status: 'active'
            },
            {
                id: 'M002',
                name: '‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á ‡∏£‡∏±‡∏Å‡∏™‡∏á‡∏ö',
                phone: '082-345-6789',
                email: 'somying@example.com',
                join_date: '2024-02-20',
                status: 'active'
            }
        ];
        
        displayMembers();
        updateMembersStats();
    } catch (error) {
        console.error('Error loading members:', error);
    }
}

// Display members in table
function displayMembers() {
    const tbody = document.getElementById('membersTableBody');
    if (!tbody) return;
    
    if (membersData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å</td></tr>';
        return;
    }
    
    tbody.innerHTML = membersData.map(member => `
        <tr>
            <td>${member.id}</td>
            <td>${member.name}</td>
            <td>${member.phone}</td>
            <td>${member.email || '-'}</td>
            <td>${formatDate(member.join_date)}</td>
            <td>
                <span class="status-badge ${member.status === 'active' ? 'success' : 'secondary'}">
                    ${member.status === 'active' ? '‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà' : '‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'}
                </span>
            </td>
            <td>
                <div class="action-buttons">
                    <button class="btn-action btn-view" onclick="viewMemberDetail('${member.id}')" title="‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î">
                        <span>üëÅÔ∏è</span>
                    </button>
                    <button class="btn-action btn-edit" onclick="editMember('${member.id}')" title="‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç">
                        <span>‚úèÔ∏è</span>
                    </button>
                    <button class="btn-action btn-delete" onclick="deleteMember('${member.id}')" title="‡∏•‡∏ö">
                        <span>üóëÔ∏è</span>
                    </button>
                </div>
            </td>
        </tr>
    `).join('');
}

// Update members statistics
function updateMembersStats() {
    const totalMembersEl = document.getElementById('totalMembers');
    const activeMembersEl = document.getElementById('activeMembers');
    const newMembersThisMonthEl = document.getElementById('newMembersThisMonth');
    
    if (totalMembersEl) totalMembersEl.textContent = membersData.length;
    
    const activeCount = membersData.filter(m => m.status === 'active').length;
    if (activeMembersEl) activeMembersEl.textContent = activeCount;
    
    // Count new members this month
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth();
    const currentYear = currentDate.getFullYear();
    const newMembersCount = membersData.filter(m => {
        const joinDate = new Date(m.join_date);
        return joinDate.getMonth() === currentMonth && joinDate.getFullYear() === currentYear;
    }).length;
    if (newMembersThisMonthEl) newMembersThisMonthEl.textContent = newMembersCount;
}

// Open create member modal
function openCreateMemberModal() {
    customAlert({
        title: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÉ‡∏´‡∏°‡πà',
        message: '‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤',
        icon: 'info'
    });
}

// View member detail
function viewMemberDetail(memberId) {
    const member = membersData.find(m => m.id === memberId);
    if (!member) return;
    
    customAlert({
        title: '‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å',
        message: `‡∏£‡∏´‡∏±‡∏™: ${member.id}\n‡∏ä‡∏∑‡πà‡∏≠: ${member.name}\n‡πÄ‡∏ö‡∏≠‡∏£‡πå: ${member.phone}\n‡∏≠‡∏µ‡πÄ‡∏°‡∏•: ${member.email || '-'}\n‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏±‡∏Ñ‡∏£: ${formatDate(member.join_date)}`,
        icon: 'info'
    });
}

// Edit member
function editMember(memberId) {
    customAlert({
        title: '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å',
        message: '‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤',
        icon: 'info'
    });
}

// Delete member
async function deleteMember(memberId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà? ‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ',
        icon: 'warning'
    });
    
    if (confirmed) {
        try {
            // TODO: Delete via API
            membersData = membersData.filter(m => m.id !== memberId);
            displayMembers();
            updateMembersStats();
            
            await customAlert({
                title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                message: '‡∏•‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
                icon: 'success'
            });
        } catch (error) {
            console.error('Error deleting member:', error);
            await customAlert({
                title: '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÑ‡∏î‡πâ',
                icon: 'error'
            });
        }
    }
}

// Search members
document.addEventListener('DOMContentLoaded', function() {
    const searchMembersInput = document.getElementById('searchMembers');
    if (searchMembersInput) {
        searchMembersInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const filteredMembers = membersData.filter(member => 
                member.name.toLowerCase().includes(searchTerm) ||
                member.phone.includes(searchTerm) ||
                (member.email && member.email.toLowerCase().includes(searchTerm)) ||
                member.id.toLowerCase().includes(searchTerm)
            );
            
            const tbody = document.getElementById('membersTableBody');
            if (!tbody) return;
            
            if (filteredMembers.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</td></tr>';
                return;
            }
            
            tbody.innerHTML = filteredMembers.map(member => `
                <tr>
                    <td>${member.id}</td>
                    <td>${member.name}</td>
                    <td>${member.phone}</td>
                    <td>${member.email || '-'}</td>
                    <td>${formatDate(member.join_date)}</td>
                    <td>
                        <span class="status-badge ${member.status === 'active' ? 'success' : 'secondary'}">
                            ${member.status === 'active' ? '‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà' : '‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'}
                        </span>
                    </td>
                    <td>
                        <div class="action-buttons">
                            <button class="btn-action btn-view" onclick="viewMemberDetail('${member.id}')" title="‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î">
                                <span>üëÅÔ∏è</span>
                            </button>
                            <button class="btn-action btn-edit" onclick="editMember('${member.id}')" title="‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç">
                                <span>‚úèÔ∏è</span>
                            </button>
                            <button class="btn-action btn-delete" onclick="deleteMember('${member.id}')" title="‡∏•‡∏ö">
                                <span>üóëÔ∏è</span>
                            </button>
                        </div>
                    </td>
                </tr>
            `).join('');
        });
    }
});

// ===================================
// Simcard Functions
// ===================================

// Initialize simcard page
async function initializeSimcardDatabase() {
    try {
        const simcards = await API.get(`${API_ENDPOINTS.simcard}?store=${currentStore}`);
        console.log('Simcard data loaded:', simcards);
    } catch (error) {
        console.error('Error initializing simcard database:', error);
    }
}

// Initialize simcard tabs
function initializeSimcardTabs() {
    const tabs = document.querySelectorAll('[data-tab^="simcard-"]');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            const tabContents = document.querySelectorAll('[id^="simcard-"][id$="-tab"]');
            tabContents.forEach(content => content.classList.remove('active'));

            const targetId = tab.dataset.tab + '-tab';
            const targetContent = document.getElementById(targetId);
            if (targetContent) targetContent.classList.add('active');
        });
    });
}

// Open simcard modal
async function openSimcardModal(simcardId = null) {
    const modal = document.getElementById('simcardModal');
    const modalTitle = document.getElementById('simcardModalTitle');
    const form = document.getElementById('simcardForm');

    // Reset form
    form.reset();
    currentSimcardEditId = simcardId;

    if (simcardId) {
        // Edit mode
        modalTitle.textContent = '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î';

        try {
            const simcard = await API.get(`${API_ENDPOINTS.simcard}/${simcardId}`);

            if (simcard) {
                document.getElementById('simcardId').value = simcard.id;
                document.getElementById('simcardProvider').value = simcard.provider;
                document.getElementById('simcardPhoneNumber').value = simcard.phone_number;
                document.getElementById('simcardPackage').value = simcard.package || '-';
                // ‡∏•‡∏ö‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î simcardPackageSale ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏≠‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Modal ‡πÅ‡∏•‡πâ‡∏ß
                document.getElementById('simcardCostPrice').value = simcard.cost_price || 0;
                document.getElementById('simcardSalePrice').value = simcard.sale_price || 0;
                document.getElementById('simcardImportDate').value = simcard.import_date ? simcard.import_date.split('T')[0] : '';
                document.getElementById('simcardExpiryDate').value = simcard.expiry_date ? simcard.expiry_date.split('T')[0] : '';
                document.getElementById('simcardStatus').value = simcard.status || 'available';
                document.getElementById('simcardNote').value = simcard.note || '';
            }
        } catch (error) {
            console.error('Error loading simcard:', error);
            alert('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÑ‡∏î‡πâ');
            return;
        }
    } else {
        // Add mode
        modalTitle.textContent = '‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î';
        // Set default date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('simcardImportDate').value = today;
        // Clear expiry date
        document.getElementById('simcardExpiryDate').value = '';
    }

    modal.classList.add('show');
}

// Close simcard modal
function closeSimcardModal() {
    const modal = document.getElementById('simcardModal');
    modal.classList.remove('show');
    currentSimcardEditId = null;
}

// Save simcard
async function saveSimcard(event) {
    event.preventDefault();

    const formData = new FormData(event.target);

    const simcardData = {
        provider: formData.get('provider'),
        phone_number: formData.get('phoneNumber'),
        package: formData.get('package'),
        package_sale: formData.get('packageSale') || null,
        cost_price: parseFloat(formData.get('costPrice')),
        sale_price: parseFloat(formData.get('salePrice')),
        import_date: formData.get('importDate'),
        expiry_date: formData.get('expiryDate'),
        status: formData.get('status'),
        note: formData.get('note') || null,
        store: currentStore
    };

    try {
        if (currentSimcardEditId) {
            // Update
            await API.put(`${API_ENDPOINTS.simcard}/${currentSimcardEditId}`, simcardData);
            alert('‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        } else {
            // Create
            simcardData.id = 'SIM-' + Date.now();
            await API.post(API_ENDPOINTS.simcard, simcardData);
            alert('‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        }

        closeSimcardModal();
        loadSimcardData();
    } catch (error) {
        console.error('Error saving simcard:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î');
    }
}

// Load simcard data
async function loadSimcardData() {
    try {
        const simcards = await API.get(`${API_ENDPOINTS.simcard}?store=${currentStore}`);

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // Auto-update expired simcards: ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô status ‡πÄ‡∏õ‡πá‡∏ô 'expired' ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
        for (const simcard of simcards) {
            const expiryDate = simcard.expiry_date ? new Date(simcard.expiry_date) : null;
            const isExpired = expiryDate && expiryDate < today;
            
            // ‡∏ñ‡πâ‡∏≤‡∏ã‡∏¥‡∏°‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏ï‡πà status ‡∏¢‡∏±‡∏á‡πÄ‡∏õ‡πá‡∏ô 'available' ‡∏´‡∏£‡∏∑‡∏≠ 'returned'
            if (isExpired && (simcard.status === 'available' || simcard.status === 'returned')) {
                try {
                    // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï status ‡πÄ‡∏õ‡πá‡∏ô 'expired'
                    simcard.status = 'expired';
                    await API.put(`${API_ENDPOINTS.simcard}/${simcard.id}`, simcard);
                    console.log(`[Auto-Expire] Updated simcard ${simcard.phone_number} to expired`);
                } catch (error) {
                    console.error(`[Auto-Expire] Error updating simcard ${simcard.id}:`, error);
                }
            }
        }

        // Filter by status
        const available = simcards.filter(s => {
            return (s.status === 'available' || s.status === 'returned');
        });

        const sold = simcards.filter(s => s.status === 'sold');

        const removed = simcards.filter(s => s.status === 'removed');

        const expired = simcards.filter(s => s.status === 'expired');

        // Store data globally for tab switching
        simcardData = { available, sold, removed, expired };

        // Filter by current provider
        const filteredAvailable = filterByProvider(available, currentSimcardProvider);
        const filteredSold = filterByProvider(sold, currentSimcardProvider);
        const filteredRemoved = filterByProvider(removed, currentSimcardProvider);
        const filteredExpired = filterByProvider(expired, currentSimcardProvider);

        // Display in tables
        displaySimcards(filteredAvailable, 'simcardAvailableTableBody', 'available');
        displaySimcards(filteredSold, 'simcardSoldTableBody', 'sold');
        displaySimcards(filteredRemoved, 'simcardRemovedTableBody', 'removed');
        displaySimcards(filteredExpired, 'simcardExpiredTableBody', 'expired');

        // Update counts
        updateSimcardTabCounts({ available, sold, removed, expired });
        updateSimcardProviderCounts({ available, sold, removed, expired });
        updateSimcardDashboardCards({ available, sold, removed, expired, allSimcards: simcards });
    } catch (error) {
        console.error('Error loading simcard data:', error);
    }
}

// Display simcards in table
function displaySimcards(simcards, tableBodyId, status) {
    const tbody = document.getElementById(tableBodyId);

    if (!tbody) return;

    if (simcards.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="empty-state">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
        return;
    }

    tbody.innerHTML = simcards.map(simcard => {
        const displayDate = status === 'sold' ? simcard.sale_date :
                          status === 'expired' ? simcard.expiry_date :
                          simcard.import_date;

        // Format ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£: ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó (‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô/‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏≠‡∏¥‡∏ô‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï)
        let packageDisplay = '-';
        if (simcard.package && simcard.package !== '-') {
            packageDisplay = simcard.package;
        }

        // Format ‡∏¢‡∏≠‡∏î‡πÄ‡∏ï‡∏¥‡∏°: ‡πÅ‡∏™‡∏î‡∏á ‡∏ø100 ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ ‡∏´‡∏£‡∏∑‡∏≠ - ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
        const topupAmountDisplay = simcard.topup_amount && simcard.topup_amount > 0
            ? `‡∏ø${parseFloat(simcard.topup_amount).toLocaleString()}`
            : '-';

        return `
            <tr>
                <td>${simcard.provider}</td>
                <td>${simcard.phone_number}</td>
                <td>${packageDisplay}</td>
                <td style="text-align: center;">${topupAmountDisplay}</td>
                <td style="text-align: right;">‡∏ø${simcard.cost_price.toLocaleString()}</td>
                <td style="text-align: right;">‡∏ø${simcard.sale_price.toLocaleString()}</td>
                <td style="text-align: center;">${displayDate ? new Date(displayDate).toLocaleDateString('th-TH') : '-'}</td>
                <td style="text-align: center;">
                    <div style="display: flex; gap: 5px; align-items: center; justify-content: center;">
                        <select class="simcard-action-select" id="simcard-action-${simcard.id}" style="padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ --</option>
                            ${status === 'available' ? `
                                <option value="sold">‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß</option>
                                <option value="cut">‡∏ï‡∏±‡∏î</option>
                            ` : ''}
                            ${status === 'sold' ? `<option value="return">‡∏Ñ‡∏∑‡∏ô‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î</option>` : ''}
                            ${status === 'expired' ? `<option value="cut">‡∏ï‡∏±‡∏î</option>` : ''}
                            <option value="edit">‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç</option>
                            <option value="delete">‡∏•‡∏ö</option>
                        </select>
                        <button class="action-btn btn-primary" onclick="executeSimcardAction('${simcard.id}')" style="padding: 6px 15px;">‡∏ï‡∏Å‡∏•‡∏á</button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
}

// Execute simcard action from dropdown
async function executeSimcardAction(simcardId) {
    const selectElement = document.getElementById(`simcard-action-${simcardId}`);
    
    if (!selectElement) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏û‡∏ö dropdown ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£',
            icon: 'error'
        });
        return;
    }
    
    const action = selectElement.value;

    if (!action || action === '') {
        await customAlert({
            title: '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡∏ï‡∏Å‡∏•‡∏á"',
            icon: 'warning'
        });
        return;
    }

    // Execute action based on selection
    switch (action) {
        case 'sold':
            await markSimcardAsSold(simcardId);
            break;
        case 'return':
            await returnSimcard(simcardId);
            break;
        case 'markExpired':
            await markSimcardExpired(simcardId);
            break;
        case 'cut':
            await openCutSimcardModal(simcardId);
            break;
        case 'edit':
            await openSimcardModal(simcardId);
            break;
        case 'delete':
            await deleteSimcard(simcardId);
            break;
    }
    
    // Reset dropdown after action
    selectElement.value = '';
}

// Open sell simcard modal
async function markSimcardAsSold(simcardId) {
    try {
        console.log('[markSimcardAsSold] Fetching simcard:', simcardId);
        console.log('[markSimcardAsSold] Endpoint:', `${API_ENDPOINTS.simcard}/${simcardId}`);
        
        const simcard = await API.get(`${API_ENDPOINTS.simcard}/${simcardId}`);
        console.log('[markSimcardAsSold] Simcard data:', simcard);

        if (!simcard) {
            throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î');
        }

        currentSellSimcardId = simcardId;

        // Set simcard info in modal
        document.getElementById('sellSimcardProvider').textContent = simcard.provider || '-';
        document.getElementById('sellSimcardPhone').textContent = simcard.phone_number || '-';
        document.getElementById('sellSimcardSalePrice').textContent = `‡∏ø${(simcard.sale_price || 0).toLocaleString()}`;

        // Set default values
        document.getElementById('sellSimcardType').value = '';
        document.getElementById('sellSimcardAmount').value = ''; // ‡∏¢‡∏≠‡∏î‡πÄ‡∏ï‡∏¥‡∏°‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏£‡∏≠‡∏Å‡πÄ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡∏ã‡∏¥‡∏°)
        document.getElementById('sellSimcardDate').value = new Date().toISOString().split('T')[0];
        document.getElementById('sellSimcardNote').value = '';

        // Show modal
        document.getElementById('sellSimcardModal').classList.add('show');
    } catch (error) {
        console.error('[markSimcardAsSold] Error:', error);
        console.error('[markSimcardAsSold] Error details:', {
            message: error.message,
            stack: error.stack,
            simcardId: simcardId
        });
        
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close sell simcard modal
function closeSellSimcardModal() {
    document.getElementById('sellSimcardModal').classList.remove('show');
    currentSellSimcardId = null;
}

// Save sell simcard
async function saveSellSimcard(event) {
    event.preventDefault();

    if (!currentSellSimcardId) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢',
            icon: 'error'
        });
        return;
    }

    const type = document.getElementById('sellSimcardType').value;
    const amount = parseFloat(document.getElementById('sellSimcardAmount').value);
    const saleDate = document.getElementById('sellSimcardDate').value;
    const note = document.getElementById('sellSimcardNote').value;

    if (!type) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó',
            icon: 'warning'
        });
        return;
    }

    if (!amount || amount <= 0) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô',
            icon: 'warning'
        });
        return;
    }

    if (!saleDate) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢',
            icon: 'warning'
        });
        return;
    }

    try {
        const confirmed = await customConfirm({
            title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢',
            message: `‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n\n‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: ${type === 'topup' ? '‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô' : '‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏≠‡∏¥‡∏ô‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï'}\n‡∏¢‡∏≠‡∏î‡πÄ‡∏ï‡∏¥‡∏°: ‡∏ø${amount.toLocaleString()}\n‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢: ${new Date(saleDate).toLocaleDateString('th-TH')}`,
            confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
            cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
        });

        if (!confirmed) return;

        const simcard = await API.get(`${API_ENDPOINTS.simcard}/${currentSellSimcardId}`);
        simcard.status = 'sold';
        simcard.sale_date = saleDate;
        simcard.topup_amount = amount; // ‡∏¢‡∏≠‡∏î‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô/‡∏≠‡∏¥‡∏ô‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô topup_amount
        simcard.package = type === 'topup' ? '‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô' : '‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏≠‡∏¥‡∏ô‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï';
        if (note) {
            simcard.note = note;
        }

        console.log('[saveSellSimcard] Saving simcard with complete data:', {
            id: simcard.id,
            status: simcard.status,
            cost_price: simcard.cost_price,      // ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô‡∏ã‡∏¥‡∏°
            sale_price: simcard.sale_price,      // ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡∏ã‡∏¥‡∏° (50)
            topup_amount: simcard.topup_amount,  // ‡∏¢‡∏≠‡∏î‡πÄ‡∏ï‡∏¥‡∏° (‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏ô topup_amount)
            package: simcard.package,
            sale_date: simcard.sale_date
        });

        await API.put(`${API_ENDPOINTS.simcard}/${currentSellSimcardId}`, simcard);

        closeSellSimcardModal();
        await loadSimcardData();

        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            icon: 'success',
            confirmType: 'success'
        });

    } catch (error) {
        console.error('Error selling simcard:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Return simcard
async function returnSimcard(simcardId) {
    if (!confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∑‡∏ô‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) return;

    try {
        const simcard = await API.get(`${API_ENDPOINTS.simcard}/${simcardId}`);
        simcard.status = 'available';
        simcard.return_date = new Date().toISOString().split('T')[0];

        await API.put(`${API_ENDPOINTS.simcard}/${simcardId}`, simcard);
        alert('‡∏Ñ‡∏∑‡∏ô‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        loadSimcardData();
    } catch (error) {
        console.error('Error returning simcard:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∑‡∏ô‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î');
    }
}

// Mark simcard as expired
async function markSimcardExpired(simcardId) {
    const confirmed = await customConfirm({
        title: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏',
        message: '‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô "‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?',
        confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
        cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å'
    });

    if (!confirmed) return;

    try {
        const simcard = await API.get(`${API_ENDPOINTS.simcard}/${simcardId}`);

        // Set expiry date to yesterday to mark as expired
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        simcard.expiry_date = yesterday.toISOString().split('T')[0];

        await API.put(`${API_ENDPOINTS.simcard}/${simcardId}`, simcard);

        await customAlert({
            title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
            message: '‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏õ‡πá‡∏ô "‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            icon: 'success',
            confirmType: 'success'
        });

        loadSimcardData();
    } catch (error) {
        console.error('Error marking simcard as expired:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Open cut simcard modal
// Toggle simcard transfer options based on action
function toggleSimcardTransferOptions() {
    const action = document.getElementById('cutSimcardAction').value;
    const transferStoreGroup = document.getElementById('simcardTransferStoreGroup');
    const priceGroup = document.getElementById('cutSimcardPriceGroup');
    const submitBtn = document.getElementById('cutSimcardSubmitBtn');

    if (action === 'transfer') {
        transferStoreGroup.style.display = 'block';
        priceGroup.style.display = 'none';
        document.getElementById('cutSimcardPrice').required = false;
        document.getElementById('cutSimcardTargetStore').required = true;
        submitBtn.textContent = '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î';
    } else {
        transferStoreGroup.style.display = 'none';
        priceGroup.style.display = 'block';
        document.getElementById('cutSimcardPrice').required = true;
        document.getElementById('cutSimcardTargetStore').required = false;
        submitBtn.textContent = '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏î‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î';
    }
}

async function openCutSimcardModal(simcardId) {
    try {
        const simcard = await API.get(`${API_ENDPOINTS.simcard}/${simcardId}`);

        currentCutSimcardId = simcardId;

        // Set simcard info in modal
        document.getElementById('cutSimcardProvider').textContent = simcard.provider;
        document.getElementById('cutSimcardPhone').textContent = simcard.phone_number;
        document.getElementById('cutSimcardCostPrice').textContent = `‡∏ø${simcard.cost_price.toLocaleString()}`;

        // Set default values - DEFAULT TO TRANSFER!
        document.getElementById('cutSimcardAction').value = 'transfer';
        document.getElementById('cutSimcardPrice').value = simcard.cost_price;
        document.getElementById('cutSimcardDate').value = new Date().toISOString().split('T')[0];
        document.getElementById('cutSimcardNote').value = '';
        document.getElementById('cutSimcardId').value = simcardId;

        // Filter target store options (exclude current store)
        const targetStoreSelect = document.getElementById('cutSimcardTargetStore');
        targetStoreSelect.innerHTML = '<option value="">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á</option>';
        if (simcard.store !== 'salaya') {
            targetStoreSelect.innerHTML += '<option value="salaya">‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤</option>';
        }
        if (simcard.store !== 'klongyong') {
            targetStoreSelect.innerHTML += '<option value="klongyong">‡∏£‡πâ‡∏≤‡∏ô‡πÑ‡∏≠‡πÄ‡∏•‡∏¥‡∏ü‡πÇ‡∏ü‡∏ô - ‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á</option>';
        }

        // Show/hide appropriate fields
        toggleSimcardTransferOptions();

        // Show modal
        document.getElementById('cutSimcardModal').classList.add('show');
    } catch (error) {
        console.error('Error opening cut simcard modal:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Close cut simcard modal
function closeCutSimcardModal() {
    document.getElementById('cutSimcardModal').classList.remove('show');
    currentCutSimcardId = null;
}

// Save cut simcard
async function saveCutSimcard(event) {
    event.preventDefault();

    if (!currentCutSimcardId) {
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î',
            icon: 'error'
        });
        return;
    }

    const formData = new FormData(event.target);
    const simcardId = formData.get('simcardId');
    const action = formData.get('action');
    const price = parseFloat(formData.get('price')) || 0;
    const date = formData.get('date');
    const note = formData.get('note') || '';
    const targetStore = formData.get('targetStore');

    console.log('üîß [saveCutSimcard] START - Form data:', {
        simcardId,
        action,
        price,
        date,
        note,
        targetStore
    });

    if (!date) {
        await customAlert({
            title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
            message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà',
            icon: 'warning'
        });
        return;
    }

    try {
        // Get current simcard data
        const simcard = await API.get(`${API_ENDPOINTS.simcard}/${simcardId}`);

        if (!simcard) {
            await customAlert({
                title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î',
                icon: 'error'
            });
            return;
        }

        console.log(`[saveCutSimcard] Action: ${action}, Simcard: ${simcard.provider} ${simcard.phone_number}`);

        // Handle different actions
        if (action === 'transfer') {
            // ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥)
            console.log('üöÄ [saveCutSimcard] Transferring to another store');

            if (!targetStore) {
                await customAlert({
                    title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö',
                    message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á',
                    icon: 'warning'
                });
                return;
            }

            const targetStoreName = targetStore === 'salaya' ? '‡∏£‡πâ‡∏≤‡∏ô‡∏®‡∏≤‡∏•‡∏≤‡∏¢‡∏≤' : '‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡∏•‡∏≠‡∏á‡πÇ‡∏¢‡∏á';

            const confirmed = await customConfirm({
                title: '‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î',
                message: `‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ${targetStoreName} ‡πÅ‡∏•‡∏∞‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡πâ‡∏≤‡∏ô‡∏ô‡∏±‡πâ‡∏ô`,
                icon: 'info',
                confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏¢‡πâ‡∏≤‡∏¢',
                cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
                list: [
                    { icon: 'info', iconSymbol: 'üì±', text: `${simcard.provider} - ${simcard.phone_number}` },
                    { icon: 'info', iconSymbol: 'üè™', text: `‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ: ${targetStoreName}` },
                    { icon: 'info', iconSymbol: 'üìÖ', text: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${formatDate(date)}` },
                    ...(note ? [{ icon: 'info', iconSymbol: 'üìù', text: `‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ${note}` }] : [])
                ]
            });

            if (!confirmed) return;

            try {
                console.log('üöÄüöÄüöÄ [TRANSFER SIMCARD] Starting transfer process...');
                console.log('üìã [TRANSFER] Simcard:', simcard);
                console.log('üìã [TRANSFER] Target store:', targetStore);

                // ‡∏¢‡πâ‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
                let transferNote = simcard.note
                    ? `${simcard.note}\n‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ ${targetStoreName} ${date}`
                    : `‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ ${targetStoreName} ${date}`;

                if (note) {
                    transferNote += ` - ${note}`;
                }

                await API.put(`${API_ENDPOINTS.simcard}/${simcardId}`, {
                    ...simcard,
                    store: targetStore,
                    note: transferNote
                });
                console.log('‚úÖ [TRANSFER] Simcard transferred successfully');

                closeCutSimcardModal();
                await loadSimcardData();

                await customAlert({
                    title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                    message: `‡∏¢‡πâ‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß\n‡πÑ‡∏õ‡∏¢‡∏±‡∏á: ${targetStoreName}`,
                    icon: 'success',
                    confirmType: 'success'
                });

            } catch (transferError) {
                console.error('‚ùå [TRANSFER] Error during transfer:', transferError);
                await customAlert({
                    title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
                    message: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≤‡∏¢‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÑ‡∏î‡πâ: ${transferError.message}`,
                    icon: 'error',
                    confirmType: 'danger'
                });
            }

        } else if (action === 'cut') {
            // ‡∏ï‡∏±‡∏î‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏£‡πâ‡∏≤‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢)
            console.log('‚úÇÔ∏è [saveCutSimcard] Cutting for own store');

            if (!price || price < 0) {
                await customAlert({
                    title: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                    message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
                    icon: 'warning'
                });
                return;
            }

            const confirmed = await customConfirm({
                title: '‚ö†Ô∏è ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡πâ‡∏≤‡∏ô)',
                message: 'üî¥ ‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡∏î‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏™‡∏ï‡πá‡∏≠‡∏Å ‡πÅ‡∏ï‡πà‡∏à‡∏∞**‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô**\n\n‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "‡∏¢‡πâ‡∏≤‡∏¢‡∏†‡∏≤‡∏¢‡πÉ‡∏ô" ‡πÅ‡∏ó‡∏ô',
                icon: 'warning',
                confirmText: '‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏î (‡πÑ‡∏°‡πà‡∏¢‡πâ‡∏≤‡∏¢‡∏£‡πâ‡∏≤‡∏ô)',
                cancelText: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å',
                list: [
                    { icon: 'info', iconSymbol: 'üì±', text: `${simcard.provider} - ${simcard.phone_number}` },
                    { icon: 'info', iconSymbol: 'üí∞', text: `‡∏£‡∏≤‡∏Ñ‡∏≤: ${formatCurrency(price)}` },
                    { icon: 'info', iconSymbol: 'üìÖ', text: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: ${formatDate(date)}` },
                    { icon: 'warning', iconSymbol: '‚ö†Ô∏è', text: `‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏£‡πâ‡∏≤‡∏ô‡∏≠‡∏∑‡πà‡∏ô!` },
                    ...(note ? [{ icon: 'info', iconSymbol: 'üìù', text: `‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ${note}` }] : [])
                ]
            });

            if (!confirmed) return;

            // Call API to cut simcard
            await API.post(`${API_ENDPOINTS.simcard}/${currentCutSimcardId}/cut`, {
                price: price,
                date: date,
                note: note,
                store: currentStore
            });

            console.log(`[saveCutSimcard] Cut completed`);

            closeCutSimcardModal();
            await loadSimcardData();

            await customAlert({
                title: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
                message: '‡∏ï‡∏±‡∏î‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
                icon: 'success',
                confirmType: 'success'
            });
        }

    } catch (error) {
        console.error('Error in saveCutSimcard:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: error.message || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Delete simcard
async function deleteSimcard(simcardId) {
    if (!confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) return;

    try {
        await API.delete(`${API_ENDPOINTS.simcard}/${simcardId}`);
        alert('‡∏•‡∏ö‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
        loadSimcardData();
    } catch (error) {
        console.error('Error deleting simcard:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏ã‡∏¥‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î');
    }
}

// Update simcard tab counts
// Filter simcards by provider
function filterByProvider(simcards, provider) {
    if (provider === '‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î') return simcards;
    return simcards.filter(s => s.provider === provider);
}

// Switch simcard tab
function switchSimcardTab(tab) {
    currentSimcardTab = tab;

    // Update tab buttons
    const tabButtons = document.querySelectorAll('#simcard .tabs button[data-tab^="simcard-"]');
    tabButtons.forEach(btn => {
        const tabName = btn.getAttribute('data-tab').replace('simcard-', '');
        if (tabName === tab) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });

    // Update tab contents
    const tabContents = document.querySelectorAll('#simcard .tab-content[id^="simcard-"]');
    tabContents.forEach(content => {
        const tabName = content.id.replace('simcard-', '').replace('-tab', '');
        if (tabName === tab) {
            content.classList.add('active');
        } else {
            content.classList.remove('active');
        }
    });

    // Update provider counts for the selected tab
    updateSimcardProviderCounts(simcardData);
}

// Switch simcard provider filter
function switchSimcardProvider(provider, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }

    currentSimcardProvider = provider;

    // Update active button
    const providerButtons = document.querySelectorAll('#simcardProviderTabs .brand-tab-btn');
    providerButtons.forEach(btn => {
        btn.classList.remove('active');
    });
    if (event) {
        event.currentTarget.classList.add('active');
    }

    // Reload data with new filter
    loadSimcardData();
}

function updateSimcardTabCounts(data) {
    const availableCount = document.getElementById('simcardAvailableCount');
    const soldCount = document.getElementById('simcardSoldCount');
    const removedCount = document.getElementById('simcardRemovedCount');
    const expiredCount = document.getElementById('simcardExpiredCount');

    if (availableCount) availableCount.textContent = data.available.length;
    if (soldCount) soldCount.textContent = data.sold.length;
    if (removedCount) removedCount.textContent = data.removed.length;
    if (expiredCount) expiredCount.textContent = data.expired.length;
}

function updateSimcardProviderCounts(data) {
    // Get simcards for current selected tab only
    let currentTabSimcards = [];
    switch(currentSimcardTab) {
        case 'available':
            currentTabSimcards = data.available;
            break;
        case 'sold':
            currentTabSimcards = data.sold;
            break;
        case 'removed':
            currentTabSimcards = data.removed;
            break;
        case 'expired':
            currentTabSimcards = data.expired;
            break;
        default:
            currentTabSimcards = data.available;
    }

    // Count by provider for current tab only
    const allCount = currentTabSimcards.length;
    const aisCount = currentTabSimcards.filter(s => s.provider === 'AIS').length;
    const dtacCount = currentTabSimcards.filter(s => s.provider === 'DTAC').length;
    const trueCount = currentTabSimcards.filter(s => s.provider === 'TRUE').length;

    // Update badges
    const providerAllCountEl = document.getElementById('providerAllCount');
    const providerAISCountEl = document.getElementById('providerAISCount');
    const providerDTACCountEl = document.getElementById('providerDTACCount');
    const providerTRUECountEl = document.getElementById('providerTRUECount');

    if (providerAllCountEl) providerAllCountEl.textContent = allCount;
    if (providerAISCountEl) providerAISCountEl.textContent = aisCount;
    if (providerDTACCountEl) providerDTACCountEl.textContent = dtacCount;
    if (providerTRUECountEl) providerTRUECountEl.textContent = trueCount;
}

// Update simcard dashboard cards
function updateSimcardDashboardCards(data) {
    const totalCount = document.getElementById('simcardTotalCount');
    const expense = document.getElementById('simcardExpense');
    const income = document.getElementById('simcardIncome');
    const profit = document.getElementById('simcardProfit');

    // Use pre-filtered available count (already filtered in loadSimcardData)
    const availableCount = data.available.length;
    const simcards = data.allSimcards;

    // Get current month/year for default filtering
    const now = new Date();
    const currentMonth = now.getMonth() + 1;
    const currentYear = now.getFullYear();

    // Calculate expense: total cost_price of simcards imported in current month (by import_date)
    const expenseSimcards = simcards.filter(s => {
        const importDate = new Date(s.import_date);
        return importDate.getMonth() + 1 === currentMonth && 
               importDate.getFullYear() === currentYear;
    });
    const totalExpense = expenseSimcards.reduce((sum, s) => sum + (parseFloat(s.cost_price) || 0), 0);
    
    // Calculate income: (sale_price + topup_amount) of SOLD simcards in current month (by sale_date)
    const soldSimcards = simcards.filter(s => {
        if (s.status !== 'sold' || !s.sale_date) return false;
        const saleDate = new Date(s.sale_date);
        return saleDate.getMonth() + 1 === currentMonth && 
               saleDate.getFullYear() === currentYear;
    });
    
    const totalIncome = soldSimcards.reduce((sum, s) => {
        const salePrice = parseFloat(s.sale_price) || 0;
        const topupAmount = parseFloat(s.topup_amount) || 0;
        return sum + salePrice + topupAmount; // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö = ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢‡∏ã‡∏¥‡∏° + ‡∏¢‡∏≠‡∏î‡πÄ‡∏ï‡∏¥‡∏°
    }, 0);
    
    // Calculate profit: (sale_price - cost_price) for sold simcards in current month
    const totalProfit = soldSimcards.reduce((sum, s) => {
        const salePrice = parseFloat(s.sale_price) || 0;
        const costPrice = parseFloat(s.cost_price) || 0;
        return sum + (salePrice - costPrice); // ‡∏Å‡∏≥‡πÑ‡∏£ = ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢ - ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏∏‡∏ô
    }, 0);

    // Debug log
    console.log('[updateSimcardDashboardCards] Summary:', {
        availableCount,
        totalExpense,
        totalIncome,
        totalProfit,
        soldCount: soldSimcards.length,
        soldSimcards: soldSimcards.map(s => ({
            id: s.id,
            sale_price: s.sale_price,
            topup_amount: s.topup_amount,
            cost_price: s.cost_price,
            total_income: (parseFloat(s.sale_price) || 0) + (parseFloat(s.topup_amount) || 0)
        }))
    });

    if (totalCount) totalCount.textContent = availableCount;
    if (expense) expense.textContent = `‡∏ø${totalExpense.toLocaleString()}`;
    if (income) income.textContent = `‡∏ø${totalIncome.toLocaleString()}`;
    if (profit) profit.textContent = `‡∏ø${totalProfit.toLocaleString()}`;
}

// Initialize simcard search
function initializeSimcardSearch() {
    const searchInput = document.getElementById('searchSimcard');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            filterSimcards(e.target.value);
        });
    }
}

// Filter simcards
function filterSimcards(searchTerm) {
    const searchLower = searchTerm.toLowerCase();
    const tables = ['simcardAvailableTableBody', 'simcardSoldTableBody', 'simcardRemovedTableBody', 'simcardExpiredTableBody'];

    tables.forEach(tableId => {
        const tbody = document.getElementById(tableId);
        if (!tbody) return;

        const rows = tbody.getElementsByTagName('tr');
        let hasVisibleRows = false;

        for (let row of rows) {
            const cells = row.getElementsByTagName('td');
            if (cells.length === 0) continue;

            const provider = cells[0]?.textContent.toLowerCase() || '';
            const phoneNumber = cells[1]?.textContent.toLowerCase() || '';
            const packageName = cells[2]?.textContent.toLowerCase() || '';

            const matches = provider.includes(searchLower) ||
                          phoneNumber.includes(searchLower) ||
                          packageName.includes(searchLower);

            row.style.display = matches ? '' : 'none';
            if (matches) hasVisibleRows = true;
        }

        if (!hasVisibleRows && rows.length > 0) {
            const emptyRow = tbody.querySelector('.empty-state');
            if (!emptyRow) {
                tbody.innerHTML = '<tr><td colspan="7" class="empty-state">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</td></tr>';
            }
        }
    });
}

// Show simcard expense detail
async function showSimcardExpenseDetail() {
    console.log('Show simcard expense detail');
    // Implementation similar to showRepairExpenseDetail
}

// Show simcard income detail
async function showSimcardIncomeDetail() {
    try {
        const tableBody = document.getElementById('simcardIncomeDetailTableBody');

        // Get all simcards
        const allSimcards = await API.get(`${API_ENDPOINTS.simcard}?store=${currentStore}`);

        // Filter sold simcards in current month
        const now = new Date();
        const currentMonth = now.getMonth() + 1;
        const currentYear = now.getFullYear();

        const soldSimcards = allSimcards.filter(s => {
            if (s.status !== 'sold' || !s.sale_date) return false;
            const saleDate = new Date(s.sale_date);
            return saleDate.getMonth() + 1 === currentMonth &&
                   saleDate.getFullYear() === currentYear;
        });

        // Calculate total income
        let totalIncome = 0;

        // Sort by sale_date (newest first)
        soldSimcards.sort((a, b) => {
            const dateA = new Date(a.sale_date || 0);
            const dateB = new Date(b.sale_date || 0);
            return dateB - dateA;
        });

        // Build table rows
        if (soldSimcards.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="6" class="text-center">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡πÉ‡∏ô‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</td></tr>';
        } else {
            tableBody.innerHTML = soldSimcards.map(simcard => {
                const salePrice = parseFloat(simcard.sale_price || 0);
                const topupAmount = parseFloat(simcard.topup_amount || 0);
                const costPrice = parseFloat(simcard.cost_price || 0);
                const income = salePrice + topupAmount; // ‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö = ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏≤‡∏¢ + ‡∏¢‡∏≠‡∏î‡πÄ‡∏ï‡∏¥‡∏°
                totalIncome += income;

                const saleDate = simcard.sale_date;
                const formattedDate = saleDate ? new Date(saleDate).toLocaleDateString('th-TH') : '-';

                return `
                    <tr>
                        <td style="width: 15%;">${simcard.provider || '-'}</td>
                        <td style="width: 20%;">${simcard.phone_number || '-'}</td>
                        <td style="width: 15%; text-align: right;">${formatCurrency(costPrice)}</td>
                        <td style="width: 15%; text-align: right;"><strong>${formatCurrency(salePrice)}</strong></td>
                        <td style="width: 15%; text-align: right;">${formatCurrency(topupAmount)}</td>
                        <td style="width: 20%; text-align: center;">${formattedDate}</td>
                    </tr>
                `;
            }).join('');
        }

        // Set filter text
        const monthNames = ['‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô', '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô',
                          '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°', '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'];
        const filterText = `${monthNames[now.getMonth()]} ${now.getFullYear() + 543}`;

        // Update summary
        document.getElementById('totalSimcardIncomeDetail').textContent = formatCurrency(totalIncome);
        document.getElementById('simcardIncomeDetailCount').textContent = soldSimcards.length;
        document.getElementById('simcardIncomeMonth').textContent = filterText;

        // Hide main page and show detail page
        document.getElementById('simcard').classList.remove('active');
        document.getElementById('simcard-income-detail').classList.add('active');

    } catch (error) {
        console.error('Error loading simcard income detail:', error);
        await customAlert({
            title: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î',
            message: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏¢‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ',
            icon: 'error'
        });
    }
}

// Back to simcard page
function backToSimcard() {
    const incomeDetail = document.getElementById('simcard-income-detail');
    const profitDetail = document.getElementById('simcard-profit-detail');

    if (incomeDetail) incomeDetail.classList.remove('active');
    if (profitDetail) profitDetail.classList.remove('active');

    document.getElementById('simcard').classList.add('active');
}

// Show simcard profit detail
async function showSimcardProfitDetail() {
    console.log('Show simcard profit detail');
    // Implementation similar to showRepairProfitDetail
}
